<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android配置EGL环境C++版]]></title>
    <url>%2FAndroid%E9%85%8D%E7%BD%AEEGL%E7%8E%AF%E5%A2%83C%2B%2B%E7%89%88.html</url>
    <content type="text"><![CDATA[android搭建opengles 的egl环境之前使用java已经写过，但是一般实际开发opengles的相关代码都在native层，因为native的话效率会比java高很多，步骤都是一致的，只是换一种语言写而已。之前使用java写的opengles egl环境搭建点击下面链接:https://www.jianshu.com/p/ce3496ab9e02 本文demo下载地址:https://github.com/ChinaZeng/NativeEglDemo 步骤都是一样的： 1、得到Egl实例2、得到默认的显示设备（就是窗口）3、初始化默认显示设备4、设置显示设备的属性5、从系统中获取对应属性的配置6、创建EglContext7、创建渲染的Surface8、绑定EglContext和Surface到显示设备中9、刷新数据，显示渲染场景 代码目录: 首先配置android ndk开发环境，我使用的是cmake 12345678910111213141516cmake_minimum_required(VERSION 3.4.1)add_library( # Sets the name of the library. native-lib SHARED native-lib.cpp egl/EglHelper.cpp )target_link_libraries( native-lib EGL GLESv2 android log) 书写EglHelper，这个类主要负责egl的环境初始化，绘制和销毁 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100//环境搭建初始化int EglHelper::initEgl(EGLNativeWindowType window) &#123; //1.得到默认的显示设备（就是窗口） -- eglGetDisplay mEglDisplay = eglGetDisplay(EGL_DEFAULT_DISPLAY); if (mEglDisplay == EGL_NO_DISPLAY) &#123; LOGE("eglGetDisplay error"); return -1; &#125; //2. 初始化默认显示设备 -- eglInitialize EGLint *version = new EGLint[2]; if (!eglInitialize(mEglDisplay, &amp;version[0], &amp;version[1])) &#123; LOGE("eglInitialize error"); return -1; &#125; //3. 设置显示设备的属性 const EGLint attrib_config_list[] = &#123; EGL_RED_SIZE, 8, EGL_GREEN_SIZE, 8, EGL_BLUE_SIZE, 8, EGL_ALPHA_SIZE, 8, EGL_DEPTH_SIZE, 8, EGL_STENCIL_SIZE, 8,// 眼睛屏幕的距离 EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,//版本号 EGL_NONE &#125;; //3.1 根据所需的参数获取符合该参数的config_size，主要是解决有些手机eglChooseConfig失败的兼容性问题 EGLint num_config; if (!eglChooseConfig(mEglDisplay, attrib_config_list, NULL, 1, &amp;num_config)) &#123; LOGE("eglChooseConfig error"); return -1; &#125; //3.2 根据获取到的config_size得到eglConfig EGLConfig eglConfig; if (!eglChooseConfig(mEglDisplay, attrib_config_list, &amp;eglConfig, num_config, &amp;num_config)) &#123; LOGE("eglChooseConfig error"); return -1; &#125; //4. 创建egl上下文 eglCreateContext const EGLint attrib_ctx_list[] = &#123; EGL_CONTEXT_CLIENT_VERSION, 2, EGL_NONE &#125;; mEglContext = eglCreateContext(mEglDisplay, eglConfig, NULL, attrib_ctx_list); if (mEglContext == EGL_NO_CONTEXT) &#123; LOGE("eglCreateContext error"); return -1; &#125; //5.创建渲染的surface mEglSurface = eglCreateWindowSurface(mEglDisplay, eglConfig, window, NULL); if (mEglSurface == EGL_NO_SURFACE) &#123; LOGE("eglCreateWindowSurface error"); return -1; &#125; //6. 绑定eglContext和surface到display if (!eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface, mEglContext)) &#123; LOGE("eglMakeCurrent error"); return -1; &#125; //7. 刷新数据，显示渲染场景 -- eglSwapBuffers return 0;&#125;//交换缓冲 绘制int EglHelper::swapBuffers() &#123; if (mEglDisplay != EGL_NO_DISPLAY &amp;&amp; mEglSurface != EGL_NO_SURFACE &amp;&amp; eglSwapBuffers(mEglDisplay, mEglSurface)) &#123; return 0; &#125; return -1;&#125;//销毁void EglHelper::destroyEgl() &#123; if (mEglDisplay != EGL_NO_DISPLAY) &#123; //解绑display上的eglContext和surface eglMakeCurrent(mEglDisplay, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT); //销毁surface 和 eglContext if (mEglSurface != EGL_NO_SURFACE) &#123; eglDestroySurface(mEglDisplay, mEglSurface); mEglSurface = EGL_NO_SURFACE; &#125; if (mEglContext != EGL_NO_CONTEXT) &#123; eglDestroyContext(mEglDisplay, mEglContext); mEglContext = EGL_NO_CONTEXT; &#125; if (mEglDisplay != EGL_NO_DISPLAY) &#123; eglTerminate(mEglDisplay); mEglDisplay = EGL_NO_DISPLAY; &#125; &#125;&#125; 书写EglThread，顾名思义，这个类主要负责开启一个线程然后根据外部的生命周期调用EglHelper完成egl的环境搭建，并且和外部交互。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106EglThread::EglThread() &#123; pthread_mutex_init(&amp;pthread_mutex, NULL); pthread_cond_init(&amp;pthread_cond, NULL);&#125;EglThread::~EglThread() &#123; pthread_mutex_destroy(&amp;pthread_mutex); pthread_cond_destroy(&amp;pthread_cond);&#125;void *eglThreadImpl(void *context) &#123; EglThread *eglThread = static_cast&lt;EglThread *&gt;(context); if (!eglThread) &#123; LOGE("eglThreadImpl eglThread is null"); return 0; &#125; EglHelper *eglHelper = new EglHelper(); if (eglHelper-&gt;initEgl(eglThread-&gt;mANativeWindow) != 0) &#123; LOGE("eglHelper initEgl error"); return 0; &#125; eglThread-&gt;isExit = false; while (!eglThread-&gt;isExit) &#123; if (eglThread-&gt;isCreate) &#123; eglThread-&gt;isCreate = false; eglThread-&gt;onCreate(); &#125; if (eglThread-&gt;isChange) &#123; eglThread-&gt;isChange = false; eglThread-&gt;isStart = true; eglThread-&gt;onChange(eglThread-&gt;surfaceWidth, eglThread-&gt;surfaceHeight); &#125; if (eglThread-&gt;isStart) &#123; eglThread-&gt;onDraw(); //切换缓冲区，显示 eglHelper-&gt;swapBuffers(); if (eglThread-&gt;mRenderType == RENDER_MODULE_AUTO) &#123; usleep(1000000 / 60); &#125; else &#123; pthread_mutex_lock(&amp;eglThread-&gt;pthread_mutex); pthread_cond_wait(&amp;eglThread-&gt;pthread_cond, &amp;eglThread-&gt;pthread_mutex); pthread_mutex_unlock(&amp;eglThread-&gt;pthread_mutex); &#125; &#125; &#125; eglHelper-&gt;destroyEgl(); delete eglHelper; eglHelper = NULL; //return 0表示线程结束 return 0;&#125;void EglThread::onSurfaceCreate(EGLNativeWindowType window) &#123; if (mEglThread == -1) &#123; isCreate = true; mANativeWindow = window; pthread_create(&amp;mEglThread, NULL, eglThreadImpl, this); &#125;&#125;void EglThread::onSurfaceChange(int width, int height) &#123; if (mEglThread != -1) &#123; surfaceWidth = width; surfaceHeight = height; isChange = true; notifyRender(); &#125;&#125;void EglThread::setRenderModule(int renderType) &#123; mRenderType = renderType; notifyRender();&#125;void EglThread::notifyRender() &#123; pthread_mutex_lock(&amp;pthread_mutex); pthread_cond_signal(&amp;pthread_cond); pthread_mutex_unlock(&amp;pthread_mutex);&#125;void EglThread::callBackOnCreate(EglThread::OnCreate onCreate) &#123; this-&gt;onCreate = onCreate;&#125;void EglThread::callBackOnChange(EglThread::OnChange onChange) &#123; this-&gt;onChange = onChange;&#125;void EglThread::callBackOnDraw(EglThread::OnDraw onDraw) &#123; this-&gt;onDraw = onDraw;&#125; 书写java层和native层交互，对应生命周期回调即可NationOpenGL.java12345678910111213public class NationOpenGL &#123; static &#123; System.loadLibrary("native-lib"); &#125; public native void nativeSurfaceCreate(Surface surface); public native void nativeSurfaceChanged(int width, int height); public native void nativeSurfaceDestroyed();&#125; NativeGLSurfaceView.java1234567891011121314151617181920212223242526272829303132public class NativeGLSurfaceView extends SurfaceView implements SurfaceHolder.Callback &#123; private NationOpenGL mNationOpenGL; public NativeGLSurfaceView(Context context) &#123; this(context, null); &#125; public NativeGLSurfaceView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public NativeGLSurfaceView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); mNationOpenGL = new NationOpenGL(); getHolder().addCallback(this); &#125; @Override public void surfaceCreated(SurfaceHolder holder) &#123; mNationOpenGL.nativeSurfaceCreate(holder.getSurface()); &#125; @Override public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123; mNationOpenGL.nativeSurfaceChanged(width, height); &#125; @Override public void surfaceDestroyed(SurfaceHolder holder) &#123; mNationOpenGL.nativeSurfaceDestroyed(); &#125;&#125; native-lib.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556EglThread *eglThread = NULL;void callBackOnCreate() &#123; LOGE("callBackOnCreate");&#125;void callBackOnChange(int width, int height) &#123; glViewport(0, 0, width, height); LOGE("callBackOnChange");&#125;void callBackOnDraw() &#123; glClearColor(0.0f, 1.0f, 1.0f, 1.0f); glClear(GL_COLOR_BUFFER_BIT); LOGE("callBackOnDraw");&#125;extern "C"JNIEXPORT void JNICALLJava_com_zzw_nativeopnegldemo_opengl_NationOpenGL_nativeSurfaceCreate(JNIEnv *env, jobject instance, jobject surface) &#123; eglThread = new EglThread(); eglThread-&gt;callBackOnCreate(callBackOnCreate); eglThread-&gt;callBackOnChange(callBackOnChange); eglThread-&gt;callBackOnDraw(callBackOnDraw); eglThread-&gt;setRenderModule(RENDER_MODULE_MANUAL); ANativeWindow *nativeWindow = ANativeWindow_fromSurface(env, surface); eglThread-&gt;onSurfaceCreate(nativeWindow);&#125;extern "C"JNIEXPORT void JNICALLJava_com_zzw_nativeopnegldemo_opengl_NationOpenGL_nativeSurfaceChanged(JNIEnv *env, jobject instance, jint width, jint height) &#123; if (eglThread) &#123; eglThread-&gt;onSurfaceChange(width, height); &#125;&#125;extern "C"JNIEXPORT void JNICALLJava_com_zzw_nativeopnegldemo_opengl_NationOpenGL_nativeSurfaceDestroyed(JNIEnv *env, jobject instance) &#123; if (eglThread) &#123; eglThread-&gt;isExit = true; delete (eglThread); eglThread = NULL; &#125;&#125;]]></content>
      <categories>
        <category>OpenGLES</category>
      </categories>
      <tags>
        <tag>OpenGLES</tag>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android使用libRtmp直播推流]]></title>
    <url>%2FAndroid%E4%BD%BF%E7%94%A8libRtmp%E7%9B%B4%E6%92%AD%E6%8E%A8%E6%B5%81.html</url>
    <content type="text"><![CDATA[初始化rtmp 1234567891011121314151617181920212223242526//分配空间RTMP *rtmp = RTMP_Alloc();//初始化RTMP_Init(rtmp);//设置推流URLRTMP_SetupURL(rtmp, url);//设置可写状态RTMP_EnableWrite(rtmp);//链接服务器RTMP_Connect(rtmp, NULL);//链接流RTMP_ConnectStream(rtmp, 0);//循环推流（AAC、H264） //开始推流while(1)&#123; int result = RTMP_SendPacket(rtmp, packet, 1); RTMPPacket_Free(packet); free(packet); packet = NULL;&#125;//关闭链接RTMP_Close(rtmp);//释放资源RTMP_Free(rtmp);rtmp=NULL; H264包封装。在发送每一帧关键帧之前得先发送SPS、PPS帧信息，发送的每一帧（I、P、SPS、PPS）数据得添加头部信息。 获取摄像头预览数据并编码为H264,pcm数据编码AAC 2.1 SPS PPS数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566void RtmpPush::pushSPSPPS(char *sps, int spsLen, char *pps, int ppsLen) &#123; if (!this-&gt;queue) return; int bodySize = spsLen + ppsLen + 16; RTMPPacket *rtmpPacket = static_cast&lt;RTMPPacket *&gt;(malloc(sizeof(RTMPPacket))); RTMPPacket_Alloc(rtmpPacket, bodySize); RTMPPacket_Reset(rtmpPacket); char *body = rtmpPacket-&gt;m_body; int i = 0; //frame type(4bit)和CodecId(4bit)合成一个字节(byte) //frame type 关键帧1 非关键帧2 //CodecId 7表示avc body[i++] = 0x17; //fixed 4byte body[i++] = 0x00; body[i++] = 0x00; body[i++] = 0x00; body[i++] = 0x00; //configurationVersion： 版本 1byte body[i++] = 0x01; //AVCProfileIndication：Profile 1byte sps[1] body[i++] = sps[1]; //compatibility： 兼容性 1byte sps[2] body[i++] = sps[2]; //AVCLevelIndication： ProfileLevel 1byte sps[3] body[i++] = sps[3]; //lengthSizeMinusOne： 包长数据所使用的字节数 1byte body[i++] = 0xff; //sps个数 1byte body[i++] = 0xe1; //sps长度 2byte body[i++] = (spsLen &gt;&gt; 8) &amp; 0xff; body[i++] = spsLen &amp; 0xff; //sps data 内容 memcpy(&amp;body[i], sps, spsLen); i += spsLen; //pps个数 1byte body[i++] = 0x01; //pps长度 2byte body[i++] = (ppsLen &gt;&gt; 8) &amp; 0xff; body[i++] = ppsLen &amp; 0xff; //pps data 内容 memcpy(&amp;body[i], pps, ppsLen); rtmpPacket-&gt;m_packetType = RTMP_PACKET_TYPE_VIDEO; rtmpPacket-&gt;m_nBodySize = bodySize; rtmpPacket-&gt;m_nTimeStamp = 0; rtmpPacket-&gt;m_hasAbsTimestamp = 0; rtmpPacket-&gt;m_nChannel = 0x04;//音频或者视频 rtmpPacket-&gt;m_headerType = RTMP_PACKET_SIZE_MEDIUM; rtmpPacket-&gt;m_nInfoField2 = this-&gt;rtmp-&gt;m_stream_id; queue-&gt;putRtmpPacket(rtmpPacket);&#125; 2.2 H264数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748void RtmpPush::pushVideoData(char *data, int dataLen, bool keyFrame) &#123; if (!this-&gt;queue) return; int bodySize = dataLen + 9; RTMPPacket *rtmpPacket = static_cast&lt;RTMPPacket *&gt;(malloc(sizeof(RTMPPacket))); RTMPPacket_Alloc(rtmpPacket, bodySize); RTMPPacket_Reset(rtmpPacket); char *body = rtmpPacket-&gt;m_body; int i = 0; //frame type(4bit)和CodecId(4bit)合成一个字节(byte) //frame type 关键帧1 非关键帧2 //CodecId 7表示avc if (keyFrame) &#123; body[i++] = 0x17; &#125; else &#123; body[i++] = 0x27; &#125; //fixed 4byte 0x01表示NALU单元 body[i++] = 0x01; body[i++] = 0x00; body[i++] = 0x00; body[i++] = 0x00; //dataLen 4byte body[i++] = (dataLen &gt;&gt; 24) &amp; 0xff; body[i++] = (dataLen &gt;&gt; 16) &amp; 0xff; body[i++] = (dataLen &gt;&gt; 8) &amp; 0xff; body[i++] = dataLen &amp; 0xff; //data memcpy(&amp;body[i], data, dataLen); rtmpPacket-&gt;m_packetType = RTMP_PACKET_TYPE_VIDEO; rtmpPacket-&gt;m_nBodySize = bodySize; //持续播放时间 rtmpPacket-&gt;m_nTimeStamp = RTMP_GetTime() - this-&gt;startTime; //进入直播播放开始时间 rtmpPacket-&gt;m_hasAbsTimestamp = 0; rtmpPacket-&gt;m_nChannel = 0x04;//音频或者视频 rtmpPacket-&gt;m_headerType = RTMP_PACKET_SIZE_LARGE; rtmpPacket-&gt;m_nInfoField2 = this-&gt;rtmp-&gt;m_stream_id; queue-&gt;putRtmpPacket(rtmpPacket);&#125; AAC包封装 需要添加头部 1234567891011121314151617181920212223242526272829303132333435void RtmpPush::pushAudioData(char *data, int dataLen) &#123; if (!this-&gt;queue) return; int bodySize = dataLen + 2; RTMPPacket *rtmpPacket = static_cast&lt;RTMPPacket *&gt;(malloc(sizeof(RTMPPacket))); RTMPPacket_Alloc(rtmpPacket, bodySize); RTMPPacket_Reset(rtmpPacket); char *body = rtmpPacket-&gt;m_body; //前四位表示音频数据格式 10（十进制）表示AAC，16进制就是A //第5-6位的数值表示采样率，0 = 5.5 kHz，1 = 11 kHz，2 = 22 kHz，3(11) = 44 kHz。 //第7位表示采样精度，0 = 8bits，1 = 16bits。 //第8位表示音频类型，0 = mono，1 = stereo //这里是44100 立体声 16bit 二进制就是1111 16进制就是F body[0] = 0xAF; //0x00 aac头信息, 0x01 aac 原始数据 //这里都用0x01都可以 body[1] = 0x01; //data memcpy(&amp;body[2], data, dataLen); rtmpPacket-&gt;m_packetType = RTMP_PACKET_TYPE_AUDIO; rtmpPacket-&gt;m_nBodySize = bodySize; //持续播放时间 rtmpPacket-&gt;m_nTimeStamp = RTMP_GetTime() - this-&gt;startTime; //进入直播播放开始时间 rtmpPacket-&gt;m_hasAbsTimestamp = 0; rtmpPacket-&gt;m_nChannel = 0x04;//音频或者视频 rtmpPacket-&gt;m_headerType = RTMP_PACKET_SIZE_LARGE; rtmpPacket-&gt;m_nInfoField2 = this-&gt;rtmp-&gt;m_stream_id; queue-&gt;putRtmpPacket(rtmpPacket);&#125; Android MediaCodec获取PPS和SPS 12345678910111213int outputBufferIndex = videoEncodec.dequeueOutputBuffer(videoBufferinfo, 0);if (outputBufferIndex == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) &#123; ByteBuffer spsb = videoEncodec.getOutputFormat().getByteBuffer("csd-0"); byte[] sps = new byte[spsb.remaining()]; spsb.get(sps, 0,sps.length); Log.e("zzz", "sps: " + ByteUtil.bytesToHexSpaceString(sps)); ByteBuffer ppsb = videoEncodec.getOutputFormat().getByteBuffer("csd-1"); byte[] pps = new byte[ppsb.remaining()]; ppsb.get(pps, 0,pps.length); Log.e("zzz", "pps: " + ByteUtil.bytesToHexSpaceString(pps));&#125; 具体查看demo: https://github.com/ChinaZeng/RtmpLivePushDemo]]></content>
      <tags>
        <tag>音视频</tag>
        <tag>rtmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android集成libRtmp]]></title>
    <url>%2FAndroid%E9%9B%86%E6%88%90libRtmp.html</url>
    <content type="text"><![CDATA[librtmp下载: http://rtmpdump.mplayerhq.hu/download/ 拷贝相关文件到cpp里面 cmake配置123456789101112131415161718cmake_minimum_required(VERSION 3.4.1)#不配置sslset(CMAKE_C_FLAGS "$&#123;CMAKE_C_FLAGS&#125; -DNO_CRYPTO")add_library( lib-native SHARED src/main/cpp/librtmp/amf.c src/main/cpp/librtmp/hashswf.c src/main/cpp/librtmp/log.c src/main/cpp/librtmp/parseurl.c src/main/cpp/librtmp/rtmp.c )target_link_libraries( lib-native log) 具体的配置查看README]]></content>
      <tags>
        <tag>音视频</tag>
        <tag>rtmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MediaCodec录制音视频并将合成为一个文件]]></title>
    <url>%2FMediaCodec%E5%BD%95%E5%88%B6%E9%9F%B3%E8%A7%86%E9%A2%91%E5%B9%B6%E5%B0%86%E5%90%88%E6%88%90%E4%B8%BA%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6.html</url>
    <content type="text"><![CDATA[主要的步骤分为视频录制，音频录制，视频合成。 视频录制采用OpenGLES渲染预览摄像头画面，通过MediaCodec创建一个surface，然后通过创建一个新的egl环境共享预览的EglContext和这个surface绑定，渲染摄像头预览的fbo绑定的纹理，即可录制。音频录制采用MediaCodec即可，从外部传入pcm数据进行编码录制。音视频合成采用MediaMuxer合成。 视频录制OpenGLES渲染画面通过MediaCodec录制 音频录制相关参考 MediaCodec硬编码pcm2aac主要分为以下几步骤: 初始化 12345678910111213141516private void initAudioEncoder(String mineType, int sampleRate, int channel) &#123; try &#123; mAudioEncodec = MediaCodec.createEncoderByType(mineType); MediaFormat audioFormat = MediaFormat.createAudioFormat(mineType, sampleRate, channel); audioFormat.setInteger(MediaFormat.KEY_BIT_RATE, 96000); audioFormat.setInteger(MediaFormat.KEY_AAC_PROFILE, MediaCodecInfo.CodecProfileLevel.AACObjectLC); audioFormat.setInteger(MediaFormat.KEY_MAX_INPUT_SIZE, 4096); mAudioEncodec.configure(audioFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE); mAudioBuffInfo = new MediaCodec.BufferInfo(); &#125; catch (IOException e) &#123; e.printStackTrace(); mAudioEncodec = null; mAudioBuffInfo = null; &#125; &#125; 开始录制 1234567891011121314151617181920audioEncodec.start();int outputBufferIndex = audioEncodec.dequeueOutputBuffer(audioBufferinfo, 0);while (outputBufferIndex &gt;= 0) &#123; ByteBuffer outputBuffer = audioEncodec.getOutputBuffers()[outputBufferIndex]; outputBuffer.position(audioBufferinfo.offset); outputBuffer.limit(audioBufferinfo.offset + audioBufferinfo.size); //设置时间戳 if (pts == 0) &#123; pts = audioBufferinfo.presentationTimeUs; &#125; audioBufferinfo.presentationTimeUs = audioBufferinfo.presentationTimeUs - pts; //写入数据 mediaMuxer.writeSampleData(audioTrackIndex, outputBuffer, audioBufferinfo); audioEncodec.releaseOutputBuffer(outputBufferIndex, false); outputBufferIndex = audioEncodec.dequeueOutputBuffer(audioBufferinfo, 0);&#125; 传入数据 这里编码为aac不用添加adts是因为这里是写入到mp4,而不是单独的aac文件 12345678910111213141516171819202122private long audioPts;private long getAudioPts(int size, int sampleRate, int channel, int sampleBit) &#123; audioPts += (long) (1.0 * size / (sampleRate * channel * (sampleBit / 8)) * 1000000.0); return audioPts;&#125;public void putPcmData(byte[] buffer, int size) &#123; if (mAudioEncodecThread != null &amp;&amp; !mAudioEncodecThread.isExit &amp;&amp; buffer != null &amp;&amp; size &gt; 0) &#123; int inputBufferIndex = mAudioEncodec.dequeueInputBuffer(0); if (inputBufferIndex &gt;= 0) &#123; ByteBuffer byteBuffer = mAudioEncodec.getInputBuffers()[inputBufferIndex]; byteBuffer.clear(); byteBuffer.put(buffer); //获取时间戳 long pts = getAudioPts(size, sampleRate, channel, sampleBit); Log.e("zzz", "AudioTime = " + pts / 1000000.0f); mAudioEncodec.queueInputBuffer(inputBufferIndex, 0, size, pts, 0); &#125; &#125;&#125; 停止录制 123audioEncodec.stop();audioEncodec.release();audioEncodec = null; 音视频合成 有了音视频数据，通过MediaMuxer进行合并。 官方示例: 123456789101112131415161718192021222324252627//MediaMuxer facilitates muxing elementary streams. Currently MediaMuxer supports MP4, Webm //and 3GP file as the output. It also supports muxing B-frames in MP4 since Android Nougat. //MediaMuxer muxer = new MediaMuxer(&quot;temp.mp4&quot;, OutputFormat.MUXER_OUTPUT_MPEG_4); // More often, the MediaFormat will be retrieved from MediaCodec.getOutputFormat() // or MediaExtractor.getTrackFormat(). MediaFormat audioFormat = new MediaFormat(...); MediaFormat videoFormat = new MediaFormat(...); int audioTrackIndex = muxer.addTrack(audioFormat); int videoTrackIndex = muxer.addTrack(videoFormat); ByteBuffer inputBuffer = ByteBuffer.allocate(bufferSize); boolean finished = false; BufferInfo bufferInfo = new BufferInfo(); muxer.start(); while(!finished) &#123; // getInputBuffer() will fill the inputBuffer with one frame of encoded // sample from either MediaCodec or MediaExtractor, set isAudioSample to // true when the sample is audio data, set up all the fields of bufferInfo, // and return true if there are no more samples. finished = getInputBuffer(inputBuffer, isAudioSample, bufferInfo); if (!finished) &#123; int currentTrackIndex = isAudioSample ? audioTrackIndex : videoTrackIndex; muxer.writeSampleData(currentTrackIndex, inputBuffer, bufferInfo); &#125; &#125;; muxer.stop(); muxer.release(); 主要步骤如下: 初始化 1mMediaMuxer = new MediaMuxer(savePath, MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4); 获取录制音视频的TrackIndex 12345678910int outputBufferIndex = videoEncodec.dequeueOutputBuffer(videoBufferinfo, 0);if (outputBufferIndex == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) &#123; videoTrackIndex = mediaMuxer.addTrack(videoEncodec.getOutputFormat());&#125;int outputBufferIndex = audioEncodec.dequeueOutputBuffer(audioBufferinfo, 0);if (outputBufferIndex == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) &#123; audioTrackIndex = mediaMuxer.addTrack(audioEncodec.getOutputFormat());&#125; 开始合成 1234567mediaMuxer.start(); //写入视频数据mediaMuxer.writeSampleData(videoTrackIndex, outputBuffer, videoBufferinfo); //写入音频数据mediaMuxer.writeSampleData(audioTrackIndex, outputBuffer, audioBufferinfo); 合成结束，写入头信息 123mediaMuxer.stop();mediaMuxer.release();mediaMuxer = null; 具体查看demo：https://github.com/ChinaZeng/SurfaceRecodeDemo]]></content>
      <categories>
        <category>MediaCodec</category>
      </categories>
      <tags>
        <tag>OpenGLES</tag>
        <tag>音视频</tag>
        <tag>MediaCodec</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGLES添加水印]]></title>
    <url>%2FOpenGLES%E6%B7%BB%E5%8A%A0%E6%B0%B4%E5%8D%B0.html</url>
    <content type="text"><![CDATA[原理 多个纹理绘制在一个surface上 理解了添加水印的原理，不管是视频水印还是图片水印都是很简单的了，只是使用的纹理不一样而已。如果是绘制文字水印的话，则需要将文字生成图片，然后将图片使用纹理绘制即可。 Android OpenGLES 绘制图片纹理 那么怎样将多个纹理添加到同一个surface上？ 简单示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261import android.content.Context;import android.graphics.Bitmap;import android.opengl.GLES20;import android.util.Log;import com.zzw.live.R;import com.zzw.live.egl.EglSurfaceView;import com.zzw.live.util.ShaderUtil;import java.nio.ByteBuffer;import java.nio.ByteOrder;import java.nio.FloatBuffer;public class CameraRender implements EglSurfaceView.Render &#123; //顶点坐标 static float vertexData[] = &#123; // in counterclockwise order: -1f, -1f, 0.0f, // bottom left 1f, -1f, 0.0f, // bottom right -1f, 1f, 0.0f, // top left 1f, 1f, 0.0f, // top right 0f, 0f, 0f,//水印预留位置 0f, 0f, 0f, 0f, 0f, 0f, 0f, 0f, 0f &#125;; //纹理坐标 对应顶点坐标 与之映射 static float textureData[] = &#123; // in counterclockwise order: 0f, 1f, 0.0f, // bottom left 1f, 1f, 0.0f, // bottom right 0f, 0f, 0.0f, // top left 1f, 0f, 0.0f, // top right &#125;; //每一次取点的时候取几个点 static final int COORDS_PER_VERTEX = 3; final int vertexCount = vertexData.length / COORDS_PER_VERTEX; //每一次取的总的点 大小 static final int vertexStride = COORDS_PER_VERTEX * 4; // 4 bytes per vertex //位置 protected FloatBuffer vertexBuffer; //纹理 protected FloatBuffer textureBuffer; private int program; private int avPosition; //纹理位置 private int afPosition; //纹理 默认第0个位置 可以不获取 private int texture; //vbo id private int vboId; private int fboTextureId; private Context context; private Bitmap bitmap; private int waterTextureId; public CameraRender(Context context) &#123; this.context = context; initWater(); vertexBuffer = ByteBuffer.allocateDirect(vertexData.length * 4) .order(ByteOrder.nativeOrder()) .asFloatBuffer() .put(vertexData); vertexBuffer.position(0); textureBuffer = ByteBuffer.allocateDirect(textureData.length * 4) .order(ByteOrder.nativeOrder()) .asFloatBuffer() .put(textureData); textureBuffer.position(0); &#125; @Override public void onSurfaceCreated() &#123; //启用透明 GLES20.glEnable(GLES20.GL_BLEND); GLES20.glBlendFunc(GLES20.GL_SRC_ALPHA, GLES20.GL_ONE_MINUS_SRC_ALPHA); program = ShaderUtil.createProgram(ShaderUtil.readRawTxt(context, R.raw.vertex_shader_screen), ShaderUtil.readRawTxt(context, R.raw.fragment_shader_screen)); if (program &gt; 0) &#123; //获取顶点坐标字段 avPosition = GLES20.glGetAttribLocation(program, "av_Position"); //获取纹理坐标字段 afPosition = GLES20.glGetAttribLocation(program, "af_Position"); //获取纹理字段 texture = GLES20.glGetUniformLocation(program, "sTexture"); //创建vbo createVBO(); //创建水印纹理 createWaterTextureId(); &#125; &#125; @Override public void onSurfaceChanged(int width, int height) &#123; //宽高 GLES20.glViewport(0, 0, width, height); &#125; @Override public void onDrawFrame() &#123; //清空颜色 GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT); //设置背景颜色 GLES20.glClearColor(1.0f, 1.0f, 1.0f, 1.0f); //使用程序 GLES20.glUseProgram(program); //设置纹理 //绑定渲染纹理 默认是第0个位置 GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, fboTextureId); GLES20.glEnableVertexAttribArray(avPosition); GLES20.glEnableVertexAttribArray(afPosition); //使用VBO设置纹理和顶点值 useVboSetVertext();// //设置顶点位置值// GLES20.glVertexAttribPointer(avPosition, COORDS_PER_VERTEX, GLES20.GL_FLOAT, false, vertexStride, vertexBuffer);// //设置纹理位置值// GLES20.glVertexAttribPointer(afPosition, COORDS_PER_VERTEX, GLES20.GL_FLOAT, false, vertexStride, textureBuffer); //绘制 GLES20.GL_TRIANGLE_STRIP:复用坐标 GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, 4); GLES20.glDisableVertexAttribArray(avPosition); GLES20.glDisableVertexAttribArray(afPosition); //解绑纹理 GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, 0); drawWater(); &#125; public void onDraw(int fboTextureId) &#123; this.fboTextureId = fboTextureId; onDrawFrame(); &#125; /** * 创建vbo */ private void createVBO() &#123; //1. 创建VBO int[] vbos = new int[1]; GLES20.glGenBuffers(vbos.length, vbos, 0); vboId = vbos[0]; //2. 绑定VBO GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, vboId); //3. 分配VBO需要的缓存大小 GLES20.glBufferData(GLES20.GL_ARRAY_BUFFER, vertexData.length * 4 + textureData.length * 4, null, GLES20.GL_STATIC_DRAW); //4. 为VBO设置顶点数据的值 GLES20.glBufferSubData(GLES20.GL_ARRAY_BUFFER, 0, vertexData.length * 4, vertexBuffer); GLES20.glBufferSubData(GLES20.GL_ARRAY_BUFFER, vertexData.length * 4, textureData.length * 4, textureBuffer); //5. 解绑VBO GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, 0); &#125; /** * 使用vbo设置顶点位置 */ private void useVboSetVertext() &#123; //1. 绑定VBO GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, vboId); //2. 设置顶点数据 GLES20.glVertexAttribPointer(avPosition, COORDS_PER_VERTEX, GLES20.GL_FLOAT, false, vertexStride, 0); GLES20.glVertexAttribPointer(afPosition, COORDS_PER_VERTEX, GLES20.GL_FLOAT, false, vertexStride, vertexData.length * 4); //3. 解绑VBO GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, 0); &#125; private void initWater() &#123; bitmap = ShaderUtil.createTextImage("我是水印", 40, "#fff000", "#00000000", 0); //设置位置 根据需求自己配置 float r = 1.0f * bitmap.getWidth() / bitmap.getHeight(); float w = r * 0.1f; vertexData[12] = 0.8f - w; vertexData[13] = -0.8f; vertexData[14] = 0; vertexData[15] = 0.8f; vertexData[16] = -0.8f; vertexData[17] = 0; vertexData[18] = 0.8f - w; vertexData[19] = -0.7f; vertexData[20] = 0; vertexData[21] = 0.8f; vertexData[22] = -0.7f; vertexData[23] = 0; &#125; private void createWaterTextureId() &#123; int[] textureIds = new int[1]; //创建纹理 GLES20.glGenTextures(1, textureIds, 0); waterTextureId = textureIds[0]; //绑定纹理 GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, waterTextureId); //环绕（超出纹理坐标范围） （s==x t==y GL_REPEAT 重复） GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_REPEAT); GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_REPEAT); //过滤（纹理像素映射到坐标点） （缩小、放大：GL_LINEAR线性） GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR); GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR); ByteBuffer bitmapBuffer = ByteBuffer.allocate(bitmap.getHeight() * bitmap.getWidth() * 4);//RGBA bitmap.copyPixelsToBuffer(bitmapBuffer); //将bitmapBuffer位置移动到初始位置 bitmapBuffer.flip(); //设置内存大小绑定内存地址 GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, 0, GLES20.GL_RGBA, bitmap.getWidth(), bitmap.getHeight(), 0, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, bitmapBuffer); //解绑纹理 GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, 0); &#125; public void drawWater() &#123; GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, vboId); GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, waterTextureId); GLES20.glEnableVertexAttribArray(avPosition); GLES20.glEnableVertexAttribArray(afPosition); GLES20.glVertexAttribPointer(avPosition, COORDS_PER_VERTEX, GLES20.GL_FLOAT, false, vertexStride, vertexStride * 4);//四个坐标之后的是水印的坐标 GLES20.glVertexAttribPointer(afPosition, COORDS_PER_VERTEX, GLES20.GL_FLOAT, false, vertexStride, vertexData.length * 4); GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, 4); GLES20.glDisableVertexAttribArray(avPosition); GLES20.glDisableVertexAttribArray(afPosition); GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, 0); GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, 0); &#125;&#125; ShaderUtil.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129import android.content.Context;import android.graphics.Bitmap;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.opengl.GLES20;import android.util.Log;import java.io.BufferedReader;import java.io.InputStream;import java.io.InputStreamReader;import java.nio.ByteBuffer;public class ShaderUtil &#123; private static final String TAG = "ShaderUtil"; public static String readRawTxt(Context context, int rawId) &#123; InputStream inputStream = context.getResources().openRawResource(rawId); BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)); StringBuffer sb = new StringBuffer(); String line; try &#123; while ((line = reader.readLine()) != null) &#123; sb.append(line).append("\n"); &#125; reader.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return sb.toString(); &#125; public static int loadShader(int shaderType, String source) &#123; // create a vertex shader type (GLES20.GL_VERTEX_SHADER) // or a fragment shader type (GLES20.GL_FRAGMENT_SHADER) int shader = GLES20.glCreateShader(shaderType); if (shader != 0) &#123; //添加代码到shader GLES20.glShaderSource(shader, source); //编译shader GLES20.glCompileShader(shader); int[] compile = new int[1]; //检测是否编译成功 GLES20.glGetShaderiv(shader, GLES20.GL_COMPILE_STATUS, compile, 0); if (compile[0] != GLES20.GL_TRUE) &#123; Log.d(TAG, "shader compile error"); GLES20.glDeleteShader(shader); shader = 0; &#125; &#125; return shader; &#125; public static int createProgram(String vertexSource, String fragmentSource) &#123; //获取vertex shader int vertexShader = loadShader(GLES20.GL_VERTEX_SHADER, vertexSource); if (vertexShader == 0) &#123; return 0; &#125; //获取fragment shader int fragmentShader = loadShader(GLES20.GL_FRAGMENT_SHADER, fragmentSource); if (fragmentShader == 0) &#123; return 0; &#125; //创建一个空的渲染程序 int program = GLES20.glCreateProgram(); if (program != 0) &#123; //添加vertexShader到渲染程序 GLES20.glAttachShader(program, vertexShader); //添加fragmentShader到渲染程序 GLES20.glAttachShader(program, fragmentShader); //关联为可执行渲染程序 GLES20.glLinkProgram(program); int[] linsStatus = new int[1]; //检测是否关联成功 GLES20.glGetProgramiv(program, GLES20.GL_LINK_STATUS, linsStatus, 0); if (linsStatus[0] != GLES20.GL_TRUE) &#123; Log.d(TAG, "link program error"); GLES20.glDeleteProgram(program); program = 0; &#125; &#125; return program; &#125; public static Bitmap createTextImage(String text, int textSize, String textColor, String bgColor, int padding) &#123; Paint paint = new Paint(); paint.setColor(Color.parseColor(textColor)); paint.setTextSize(textSize); paint.setStyle(Paint.Style.FILL); paint.setAntiAlias(true); float width = paint.measureText(text, 0, text.length()); float top = paint.getFontMetrics().top; float bottom = paint.getFontMetrics().bottom; Bitmap bm = Bitmap.createBitmap((int) (width + padding * 2), (int) ((bottom - top) + padding * 2), Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(bm); canvas.drawColor(Color.parseColor(bgColor)); canvas.drawText(text, padding, -top + padding, paint); return bm; &#125; public static int loadBitmapTexture(Bitmap bitmap) &#123; int[] textureIds = new int[1]; GLES20.glGenTextures(1, textureIds, 0); GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureIds[0]); GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_REPEAT); GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_REPEAT); GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR); GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR); ByteBuffer bitmapBuffer = ByteBuffer.allocate(bitmap.getHeight() * bitmap.getWidth() * 4);//ARGB bitmap.copyPixelsToBuffer(bitmapBuffer); bitmapBuffer.flip(); GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, 0, GLES20.GL_RGBA, bitmap.getWidth(), bitmap.getHeight(), 0, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, bitmapBuffer); return textureIds[0]; &#125;&#125; 我们只需要在当前GL_TEXTURE_2D纹理绘制之后在glBindTexture绑定水印的纹理绘制即可。这里需要注意的几个点: 需要开启透明,不然没有透明效果。 123//启用透明GLES20.glEnable(GLES20.GL_BLEND);GLES20.glBlendFunc(GLES20.GL_SRC_ALPHA, GLES20.GL_ONE_MINUS_SRC_ALPHA); 如果是OES纹理上添加水印，需要开个fbo来绘制OES的纹理，然后另外用一个Render来绘制OES的fbo纹理和添加水印，也就是说:OES和2D不能混用，不然不会起作用。如果可以混用（我试了混用绘制不出来），可以留言告诉我一下，谢谢。 使用VBO需要注意点的位置。]]></content>
      <categories>
        <category>OpenGLES</category>
      </categories>
      <tags>
        <tag>OpenGLES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGLES渲染画面通过MediaCodec录制]]></title>
    <url>%2FOpenGLES%E6%B8%B2%E6%9F%93%E7%94%BB%E9%9D%A2%E9%80%9A%E8%BF%87MediaCodec%E5%BD%95%E5%88%B6.html</url>
    <content type="text"><![CDATA[录制原理 预览 通过fbo处理视频数据,通过samplerExternalOES纹理来创建SurfaceTexture,这样的话摄像头数据就和fbo相关联，具体可以看OpenGLES通过SurfaceTexture预览摄像头画面 录制 通过MediaCodec创建一个surface，然后通过创建一个新的egl环境共享预览的EglContext和这个surface绑定，渲染fbo绑定的纹理，即可录制。egl环境配置：Android配置EGL环境Android自定义GLSurfaceView 流程如下图所示: MediaCodec录制主要代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293 private MediaMuxer mMediaMuxer; private MediaCodec.BufferInfo mBuffInfo; private MediaCodec mVideoEncodec; private int width, height; //初始化 public void initEncoder(EGLContext eglContext,String savePath,String mineType,int width,int height)&#123; this.width = width; this.height = height; this.mEGLContext = eglContext; initMediaEncoder(savePath,mineType,width,height); &#125; private void initMediaEncoder(String savePath, String mineType, int width, int height) &#123; try &#123; mMediaMuxer = new MediaMuxer(savePath,MediaMuxer.OutputFormat.MUXER_OUTPUT_MPEG_4); initVideoEncoder(mineType,width,height); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; private void initVideoEncoder(String mineType, int width, int height) &#123; try &#123; mVideoEncodec= MediaCodec.createEncoderByType(mineType); MediaFormat videoFormat = MediaFormat.createVideoFormat(mineType,width,height); videoFormat.setInteger(MediaFormat.KEY_COLOR_FORMAT, MediaCodecInfo.CodecCapabilities.COLOR_FormatSurface); videoFormat.setInteger(MediaFormat.KEY_FRAME_RATE,30);//30帧 videoFormat.setInteger(MediaFormat.KEY_BIT_RATE,width*height*4);//RGBA videoFormat.setInteger(MediaFormat.KEY_BIT_RATE,width*height*4);//RGBA //设置压缩等级 默认是baseline if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; videoFormat.setInteger(MediaFormat.KEY_PROFILE,MediaCodecInfo.CodecProfileLevel.AVCProfileMain); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; videoFormat.setInteger(MediaFormat.KEY_LEVEL, MediaCodecInfo.CodecProfileLevel.AVCLevel3); &#125; &#125; mVideoEncodec.configure(videoFormat,null,null,MediaCodec.CONFIGURE_FLAG_ENCODE); mBuffInfo = new MediaCodec.BufferInfo(); mSurface = mVideoEncodec.createInputSurface(); &#125; catch (IOException e) &#123; e.printStackTrace(); mVideoEncodec=null; mBuffInfo=null; mSurface=null; &#125; &#125;//开始录制 public void startRecode()&#123; videoEncodec.start(); int outputBufferIndex = videoEncodec.dequeueOutputBuffer(videoBufferinfo, 0); if (outputBufferIndex == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) &#123; videoTrackIndex = mediaMuxer.addTrack(videoEncodec.getOutputFormat()); mediaMuxer.start(); &#125;else &#123; while (outputBufferIndex&gt;=0)&#123; ByteBuffer outputBuffer= videoEncodec.getOutputBuffers()[outputBufferIndex]; outputBuffer.position(videoBufferinfo.offset); outputBuffer.limit(videoBufferinfo.offset + videoBufferinfo.size); //设置时间戳 if(pts==0)&#123; pts = videoBufferinfo.presentationTimeUs; &#125; videoBufferinfo.presentationTimeUs = videoBufferinfo.presentationTimeUs - pts; //写入数据 mediaMuxer.writeSampleData(videoTrackIndex,outputBuffer,videoBufferinfo); if(encoderWeakReference.get().onMediaInfoListener!=null)&#123; encoderWeakReference.get().onMediaInfoListener.onMediaTime((int) (videoBufferinfo.presentationTimeUs/1000000)); &#125; videoEncodec.releaseOutputBuffer(outputBufferIndex,false); outputBufferIndex = videoEncodec.dequeueOutputBuffer(videoBufferinfo, 0); &#125; &#125; &#125; //停止录制public void stopRecode()&#123; videoEncodec.stop(); videoEncodec.release(); videoEncodec =null; mediaMuxer.stop(); mediaMuxer.release(); mediaMuxer = null;&#125; 具体示例请看:https://github.com/ChinaZeng/SurfaceRecodeDemo]]></content>
      <categories>
        <category>OpenGLES</category>
      </categories>
      <tags>
        <tag>OpenGLES</tag>
        <tag>MediaCodec</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGLES通过SurfaceTexture预览摄像头画面]]></title>
    <url>%2FOpenGLES%E9%80%9A%E8%BF%87SurfaceTexture%E9%A2%84%E8%A7%88%E6%91%84%E5%83%8F%E5%A4%B4%E7%94%BB%E9%9D%A2.html</url>
    <content type="text"><![CDATA[在这篇文章主要用到的知识点有如下，建议先看一下: OpenGLES绘制图片纹理 OpenGLES顶点缓冲VBO OpenGLES帧缓冲FBO 有一个渲染流数据的相关的示例，也可以看一下，这样对本篇理解就会很简单 : Android OpenGLES渲染MediaCodec解码数据 原理 利用OpenGL生成纹理并绑定到SurfaceTexture,然后把camera的预览数据设置显示到SurfaceTexture中，这样就可以在OpenGL中拿到摄像头数据并显示了。 主要步骤 1.OpenGL ES生成纹理2.OpenGL ES创建SurfaceTexture并绑定3.OpenGL ES摄像头预览 比如美颜相机那些，处理摄像头数据展示出来，为了提高预览的效率，所以这里使用了VBO和FBO,如果不知道这个，请看上面的文章。 FBO所需的glsl:vertex_shader.glsl 123456789attribute vec4 av_Position;//顶点位置attribute vec2 af_Position;//纹理位置varying vec2 v_texPo;//纹理位置 与fragment_shader交互uniform mat4 u_Matrix;//矩阵变换void main() &#123; v_texPo = af_Position; gl_Position = av_Position * u_Matrix;&#125; fragment_shader.glsl1234567#extension GL_OES_EGL_image_external : require //申明使用扩展纹理precision mediump float;//精度 为floatvarying vec2 v_texPo;//纹理位置 接收于vertex_shaderuniform samplerExternalOES sTexture;//加载流数据(摄像头数据)void main() &#123; gl_FragColor=texture2D(sTexture, v_texPo);&#125; 这里使用FBO里面使用samplerExternalOES是为了加载流数据，摄像头数据属于流数据，所以这里需要用这个。 创建相机预览扩展纹理:123456789101112131415161718192021222324252627/** * 创建摄像头预览扩展纹理 */ private void createCameraRenderTexture() &#123; int[] textureIds = new int[1]; GLES20.glGenTextures(1, textureIds, 0); cameraRenderTextureId = textureIds[0]; GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, cameraRenderTextureId); //环绕（超出纹理坐标范围） （s==x t==y GL_REPEAT 重复） GLES20.glTexParameteri(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_REPEAT); GLES20.glTexParameteri(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_REPEAT); //过滤（纹理像素映射到坐标点） （缩小、放大：GL_LINEAR线性） GLES20.glTexParameteri(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR); GLES20.glTexParameteri(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR); surfaceTexture = new SurfaceTexture(cameraRenderTextureId); surfaceTexture.setOnFrameAvailableListener(this); if (onSurfaceListener != null) &#123; //这里相机拿到surfaceTexture绑定 onSurfaceListener.onSurfaceCreate(surfaceTexture); &#125; // 解绑扩展纹理 GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, 0); &#125; camera绑定SurfaceTexture:1camera.setPreviewTexture(surfaceTexture); 预览画面，先通过fbo处理，然后拿到fbo的纹理id渲染即可： 12345678910111213141516171819202122232425262728293031323334353637383940@Override public void onDrawFrame() &#123; //调用触发onFrameAvailable surfaceTexture.updateTexImage(); //清空颜色 GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT); //设置背景颜色 GLES20.glClearColor(1.0f, 1.0f, 1.0f, 1.0f); //使用程序 GLES20.glUseProgram(program); //绑定fbo GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, fboId); //摄像头预览扩展纹理赋值 GLES20.glActiveTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES); GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, cameraRenderTextureId); GLES20.glUniform1i(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, 0); //给变换矩阵赋值 GLES20.glUniformMatrix4fv(uMatrix, 1, false, matrix, 0); GLES20.glEnableVertexAttribArray(avPosition); GLES20.glEnableVertexAttribArray(afPosition); //使用VBO设置纹理和顶点值 useVboSetVertext(); //绘制 GLES20.GL_TRIANGLE_STRIP:复用坐标 GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, vertexCount); GLES20.glDisableVertexAttribArray(avPosition); GLES20.glDisableVertexAttribArray(afPosition); GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0); //渲染显示 cameraRender.onDraw(fboTextureId); &#125; 摄像头方向调整 默认的摄像头预览不同的角度预览出来效果是不同的，我们需要把它给矫正，一般通常是在camera里面设置parms，这里通过OpenGLES自己矫正，通过变换矩阵实现即可: 12345678910111213141516171819202122232425262728293031323334353637383940 //变换矩阵 locationprivate int uMatrix; //变换矩阵private float[] matrix = new float[16];public void onSurfaceCreated() &#123; //...uMatrix = GLES20.glGetUniformLocation(program, "u_Matrix");&#125; @Override public void onDrawFrame() &#123; //... //给变换矩阵赋值GLES20.glUniformMatrix4fv(uMatrix, 1, false, matrix, 0); &#125;/** * 初始化矩阵 */public void resetMatirx() &#123; //初始化 Matrix.setIdentityM(matrix, 0);&#125;/** * 旋转 * * @param angle * @param x * @param y * @param z */public void setAngle(float angle, float x, float y, float z) &#123; //旋转 Matrix.rotateM(matrix, 0, angle, x, y, z);&#125; 在外层调用：1234567891011121314151617181920212223242526272829303132333435363738public void previewAngle(Context context) &#123; int angle = ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getRotation(); render.resetMatirx(); switch (angle) &#123; case Surface.ROTATION_0: if (cameraId == Camera.CameraInfo.CAMERA_FACING_BACK) &#123; render.setAngle(90, 0, 0, 1); render.setAngle(180, 1, 0, 0); &#125; else &#123; render.setAngle(90f, 0f, 0f, 1f); &#125; break; case Surface.ROTATION_90: if (cameraId == Camera.CameraInfo.CAMERA_FACING_BACK) &#123; render.setAngle(180, 0, 0, 1); render.setAngle(180, 0, 1, 0); &#125; else &#123; render.setAngle(90f, 0f, 0f, 1f); &#125; break; case Surface.ROTATION_180: if (cameraId == Camera.CameraInfo.CAMERA_FACING_BACK) &#123; render.setAngle(90f, 0.0f, 0f, 1f); render.setAngle(180f, 0.0f, 1f, 0f); &#125; else &#123; render.setAngle(-90, 0f, 0f, 1f); &#125; break; case Surface.ROTATION_270: if (cameraId == Camera.CameraInfo.CAMERA_FACING_BACK) &#123; render.setAngle(180f, 0.0f, 1f, 0f); &#125; else &#123; render.setAngle(0f, 0f, 0f, 1f); &#125; break; &#125; &#125; 具体代码下载地址: https://github.com/ChinaZeng/OpenGLESCameraDemo]]></content>
      <categories>
        <category>OpenGLES</category>
      </categories>
      <tags>
        <tag>OpenGLES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGLES正交投影]]></title>
    <url>%2FOpenGLES%E6%AD%A3%E4%BA%A4%E6%8A%95%E5%BD%B1.html</url>
    <content type="text"><![CDATA[在图片渲染的时候，之前使用的顶点坐标是占满整个屏幕的归一化坐标12345678//顶点坐标 static float vertexData[] = &#123; // in counterclockwise order: -1f, -1f, 0.0f, // bottom left 1f, -1f, 0.0f, // bottom right -1f, 1f, 0.0f, // top left 1f, 1f, 0.0f, // top right &#125;; 这样就导致了如下图所示的的问题 所以我们应该根据屏幕宽高和图片宽高对应的比例算出正确的位置: 上面我们得到的（ ？）是不在归一化坐标范围内的，为了能使OpenGL正确的渲染，我们就需要把（？）以及其他边统一转换到归一化坐标内，这个操作就是正交投影 使用正交投影，不管物体多远多近，物体看起来总是形状、大小比例相同的。 在OpenGLES里面使用投影矩阵: vertex_shader_m.glsl 12345678910attribute vec4 av_Position;//顶点位置attribute vec2 af_Position;//纹理位置varying vec2 v_texPo;//纹理位置 与fragment_shader交互uniform mat4 u_Matrix; //投影矩阵void main() &#123; v_texPo = af_Position; gl_Position = av_Position * u_Matrix;&#125; 在使用的时候: 123456789101112131415161718192021222324//投影矩阵private int uMatrix;private float[] matrix = new float[4 * 4];//1. 获取投影矩阵uMatrix = GLES20.glGetUniformLocation(program, "u_Matrix");//2. 计算值public void onSurfaceChanged(int width, int height) &#123; if (width &gt; height) &#123; float x = width / ((float) height / bitmap.getHeight() * bitmap.getWidth()); Matrix.orthoM(matrix, 0, -x, x, -1, 1, -1, 1); &#125; else &#123; float y = height / ((float) width / bitmap.getWidth() * bitmap.getHeight()); Matrix.orthoM(matrix, 0, -1, 1, -y, y, -1, 1); &#125;&#125;//3. 赋值GLES20.glUniformMatrix4fv(uMatrix, 1, false, matrix, 0); 主要代码如下：BitmapTexture.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161import android.content.Context;import android.graphics.Bitmap;import android.opengl.GLES20;import android.opengl.GLUtils;import android.opengl.Matrix;import java.nio.ByteBuffer;import java.nio.ByteOrder;import java.nio.FloatBuffer;//纹理 根据坐标系映射public class BitmapTexture &#123; //顶点坐标 static float vertexData[] = &#123; // in counterclockwise order: -1f, -1f, 0.0f, // bottom left 1f, -1f, 0.0f, // bottom right -1f, 1f, 0.0f, // top left 1f, 1f, 0.0f, // top right &#125;; //纹理坐标 对应顶点坐标 与之映射 static float textureData[] = &#123; // in counterclockwise order: 0f, 1f, 0.0f, // bottom left 1f, 1f, 0.0f, // bottom right 0f, 0f, 0.0f, // top left 1f, 0f, 0.0f, // top right &#125;; //每一次取点的时候取几个点 static final int COORDS_PER_VERTEX = 3; private final int vertexCount = vertexData.length / COORDS_PER_VERTEX; //每一次取的总的点 大小 private final int vertexStride = COORDS_PER_VERTEX * 4; // 4 bytes per vertex private Context context; //位置 private FloatBuffer vertexBuffer; //纹理 private FloatBuffer textureBuffer; private int program; private int avPosition; //纹理位置 private int afPosition; //正交投影 private int uMatrix; private float[] matrix = new float[4 * 4]; //需要渲染的纹理id private int imageTextureId; private Bitmap bitmap; public void setBitmap(Bitmap bitmap) &#123; this.bitmap = bitmap; &#125; public BitmapTexture(Context context) &#123; this.context = context; vertexBuffer = ByteBuffer.allocateDirect(vertexData.length * 4) .order(ByteOrder.nativeOrder()) .asFloatBuffer() .put(vertexData); vertexBuffer.position(0); textureBuffer = ByteBuffer.allocateDirect(textureData.length * 4) .order(ByteOrder.nativeOrder()) .asFloatBuffer() .put(textureData); textureBuffer.position(0); &#125; public void onSurfaceCreated() &#123; String vertexSource = ShaderUtil.readRawTxt(context, R.raw.vertex_shader_m); String fragmentSource = ShaderUtil.readRawTxt(context, R.raw.fragment_shader); program = ShaderUtil.createProgram(vertexSource, fragmentSource); if (program &gt; 0) &#123; //获取顶点坐标字段 avPosition = GLES20.glGetAttribLocation(program, "av_Position"); //获取纹理坐标字段 afPosition = GLES20.glGetAttribLocation(program, "af_Position"); uMatrix = GLES20.glGetUniformLocation(program, "u_Matrix"); imageTextureId = createImageTexture(); &#125; &#125; public void onSurfaceChanged(int width, int height) &#123; if (width &gt; height) &#123; float x = width / ((float) height / bitmap.getHeight() * bitmap.getWidth()); Matrix.orthoM(matrix, 0, -x, x, -1, 1, -1, 1); &#125; else &#123; float y = height / ((float) width / bitmap.getWidth() * bitmap.getHeight()); Matrix.orthoM(matrix, 0, -1, 1, -y, y, -1, 1); &#125; &#125; public void draw() &#123; //使用程序 GLES20.glUseProgram(program); GLES20.glUniformMatrix4fv(uMatrix, 1, false, matrix, 0); //绑定渲染纹理 GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, imageTextureId); GLES20.glEnableVertexAttribArray(avPosition); GLES20.glEnableVertexAttribArray(afPosition); //设置顶点位置值 GLES20.glVertexAttribPointer(avPosition, COORDS_PER_VERTEX, GLES20.GL_FLOAT, false, vertexStride, vertexBuffer); //设置纹理位置值 GLES20.glVertexAttribPointer(afPosition, COORDS_PER_VERTEX, GLES20.GL_FLOAT, false, vertexStride, textureBuffer); //绘制 GLES20.GL_TRIANGLE_STRIP:复用坐标 GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, vertexCount); GLES20.glDisableVertexAttribArray(avPosition); GLES20.glDisableVertexAttribArray(afPosition); //解绑纹理 GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, 0); &#125; private int createImageTexture() &#123; int[] textureIds = new int[1]; //创建纹理 GLES20.glGenTextures(1, textureIds, 0); if (textureIds[0] == 0) &#123; return 0; &#125; //绑定纹理 GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureIds[0]); //环绕（超出纹理坐标范围） （s==x t==y GL_REPEAT 重复） GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_REPEAT); GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_REPEAT); //过滤（纹理像素映射到坐标点） （缩小、放大：GL_LINEAR线性） GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR); GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR); //测试图片 GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, bitmap, 0); //解绑纹理 GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, 0); return textureIds[0]; &#125;&#125; 注意: 在使用FBO GLES20.glTexImage2D分配内存大小的时候，需要根据横竖屏来设置值。不然计算出来的值和渲染的宽高不一样，渲染就会出现变形。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public void onSurfaceChanged(int width, int height) &#123; if (width &gt; height) &#123; float x = width / ((float) height / bitmap.getHeight() * bitmap.getWidth()); Matrix.orthoM(matrix, 0, -x, x, -1, 1, -1, 1); &#125; else &#123; float y = height / ((float) width / bitmap.getWidth() * bitmap.getHeight()); Matrix.orthoM(matrix, 0, -1, 1, -y, y, -1, 1); &#125; if (fboId != 0) &#123; GLES20.glDeleteFramebuffers(1, new int[]&#123;fboId&#125;, 0); GLES20.glDeleteTextures(1, new int[]&#123;imageTextureId&#125;, 0); &#125; createFBO(width, height); &#125;private void createFBO(int w, int h) &#123; if (bitmap == null) &#123; throw new IllegalArgumentException("bitmap is null"); &#125; //1. 创建FBO int[] fbos = new int[1]; GLES20.glGenFramebuffers(1, fbos, 0); fboId = fbos[0]; //2. 绑定FBO GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, fboId); //3. 创建FBO纹理 fboTextureId = createTexture(); //4. 把纹理绑定到FBO GLES20.glFramebufferTexture2D(GLES20.GL_FRAMEBUFFER, GLES20.GL_COLOR_ATTACHMENT0, GLES20.GL_TEXTURE_2D, fboTextureId, 0); //5. 设置FBO分配内存大小 GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, 0, GLES20.GL_RGBA, w, h, 0, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, null); //6. 检测是否绑定从成功 if (GLES20.glCheckFramebufferStatus(GLES20.GL_FRAMEBUFFER) != GLES20.GL_FRAMEBUFFER_COMPLETE) &#123; Log.e("zzz", "glFramebufferTexture2D error"); &#125; //7. 解绑纹理和FBO GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, 0); GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0); &#125;]]></content>
      <categories>
        <category>OpenGLES</category>
      </categories>
      <tags>
        <tag>OpenGLES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGLES帧缓冲FBO]]></title>
    <url>%2FOpenGLES%E5%B8%A7%E7%BC%93%E5%86%B2FBO.html</url>
    <content type="text"><![CDATA[FBO Frame Buffer object 为什么要用FBO 我们需要对纹理进行多次渲染采样时，而这些渲染采样是不需要展示给用户看的，所以我们就可以用一个单独的缓冲对象（离屏渲染）来存储我们的这几次渲染采样的结果，等处理完后才显示到窗口上 优势 提高渲染效率，避免闪屏，可以很方便的实现纹理共享等。 渲染方式 渲染到纹理（Texture）- 图像渲染 渲染到缓冲区（Render）- 深度测试和模板测试 FBO纹理的坐标系 渲染到纹理 创建FBO的步骤: 1234567891011121314151617181920212223242526//1. 创建FBOint[] fbos = new int[1];GLES20.glGenFramebuffers(1, fbos, 0);fboId = fbos[0];//2. 绑定FBOGLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, fboId);//3. 创建FBO纹理fboTextureId = createTexture(); //4. 把纹理绑定到FBOGLES20.glFramebufferTexture2D(GLES20.GL_FRAMEBUFFER, GLES20.GL_COLOR_ATTACHMENT0,GLES20.GL_TEXTURE_2D, fboTextureId, 0);//5. 设置FBO分配内存大小GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, 0, GLES20.GL_RGBA,bitmap.getWidth(), bitmap.getHeight(),0, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, null);//6. 检测是否绑定从成功if (GLES20.glCheckFramebufferStatus(GLES20.GL_FRAMEBUFFER)!= GLES20.GL_FRAMEBUFFER_COMPLETE) &#123; Log.e("zzz", "glFramebufferTexture2D error");&#125;//7. 解绑纹理和FBOGLES20.glBindTexture(GLES20.GL_TEXTURE_2D, 0);GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0); 使用FBO的步骤: 123456789101112131415161718//1. 绑定fboGLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, fboId);//2. FBO绘制GLES20.glUseProgram(program);//绑定渲染纹理GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, imageTextureId);//...//解绑纹理GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, 0);//解绑fboGLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0);//3. 根据绑定到fbo上的纹理id，渲染 GLES20.glUseProgram(program);//绑定渲染纹理GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureId); //... 示例代码如下: TexureRender.java 12345678910111213141516171819202122232425262728293031323334353637383940414243import android.content.Context;import android.graphics.BitmapFactory;import android.opengl.GLES20;public class TexureRender implements EglSurfaceView.Renderer &#123; private BitmapFboTexture bitmapFboTexture; private BitmapRenderTexture bitmapRenderTexture; public TexureRender(Context context) &#123; bitmapFboTexture = new BitmapFboTexture(context); bitmapFboTexture.setBitmap(BitmapFactory.decodeResource(context.getResources(),R.mipmap.bg)); bitmapRenderTexture = new BitmapRenderTexture(context); &#125; @Override public void onSurfaceCreated() &#123; bitmapFboTexture.onSurfaceCreated(); bitmapRenderTexture.onSurfaceCreated(); &#125; @Override public void onSurfaceChanged(int width, int height) &#123; //宽高 GLES20.glViewport(0, 0, width, height); bitmapFboTexture.onSurfaceChanged(width, height); bitmapRenderTexture.onSurfaceChanged(width, height); &#125; @Override public void onDrawFrame() &#123; //清空颜色 GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT); //设置背景颜色 GLES20.glClearColor(1.0f, 1.0f, 1.0f, 1.0f); //FBO处理 bitmapFboTexture.draw(); //通过FBO处理之后，拿到纹理id，然后渲染 bitmapRenderTexture.draw(bitmapFboTexture.getFboTextureId()); &#125;&#125; FBO处理类： BitmapFboTexture.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217import android.content.Context;import android.graphics.Bitmap;import android.opengl.GLES20;import android.opengl.GLUtils;import android.util.Log;import java.nio.ByteBuffer;import java.nio.ByteOrder;import java.nio.FloatBuffer;//纹理 根据坐标系映射public class BitmapFboTexture &#123; //顶点坐标 static float vertexData[] = &#123; // in counterclockwise order: -1f, -1f, 0.0f, // bottom left 1f, -1f, 0.0f, // bottom right -1f, 1f, 0.0f, // top left 1f, 1f, 0.0f, // top right &#125;; //正常纹理坐标 对应顶点坐标 与之映射// static float textureData[] = &#123; // in counterclockwise order:// 0f, 1f, 0.0f, // bottom left// 1f, 1f, 0.0f, // bottom right// 0f, 0f, 0.0f, // top left// 1f, 0f, 0.0f, // top right// &#125;; //fbo 纹理坐标 static float textureData[] = &#123; // in counterclockwise order: 0f, 0f, 0.0f, // bottom left 1f, 0f, 0.0f, // bottom right 0f, 1f, 0.0f, // top left 1f, 1f, 0.0f, // top right &#125;; //每一次取点的时候取几个点 static final int COORDS_PER_VERTEX = 3; private final int vertexCount = vertexData.length / COORDS_PER_VERTEX; //每一次取的总的点 大小 private final int vertexStride = COORDS_PER_VERTEX * 4; // 4 bytes per vertex private Context context; //位置 private FloatBuffer vertexBuffer; //纹理 private FloatBuffer textureBuffer; private int program; private int avPosition; //纹理位置 private int afPosition; //需要渲染的纹理id private int imageTextureId; //fbo纹理id private int fboTextureId; //fbo Id private int fboId; private Bitmap bitmap; public void setBitmap(Bitmap bitmap) &#123; this.bitmap = bitmap; &#125; public BitmapFboTexture(Context context) &#123; this.context = context; vertexBuffer = ByteBuffer.allocateDirect(vertexData.length * 4) .order(ByteOrder.nativeOrder()) .asFloatBuffer() .put(vertexData); vertexBuffer.position(0); textureBuffer = ByteBuffer.allocateDirect(textureData.length * 4) .order(ByteOrder.nativeOrder()) .asFloatBuffer() .put(textureData); textureBuffer.position(0); &#125; public void onSurfaceCreated() &#123; String vertexSource = ShaderUtil.readRawTxt(context, R.raw.vertex_shader); String fragmentSource = ShaderUtil.readRawTxt(context, R.raw.fragment_shader); program = ShaderUtil.createProgram(vertexSource, fragmentSource); if (program &gt; 0) &#123; //获取顶点坐标字段 avPosition = GLES20.glGetAttribLocation(program, "av_Position"); //获取纹理坐标字段 afPosition = GLES20.glGetAttribLocation(program, "af_Position"); createFBO(); imageTextureId = createImageTexture(); &#125; &#125; public void draw() &#123; //绑定fbo GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, fboId); //使用程序 GLES20.glUseProgram(program); //绑定渲染纹理 GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, imageTextureId); GLES20.glEnableVertexAttribArray(avPosition); GLES20.glEnableVertexAttribArray(afPosition); //设置顶点位置值 GLES20.glVertexAttribPointer(avPosition, COORDS_PER_VERTEX, GLES20.GL_FLOAT, false, vertexStride, vertexBuffer); //设置纹理位置值 GLES20.glVertexAttribPointer(afPosition, COORDS_PER_VERTEX, GLES20.GL_FLOAT, false, vertexStride, textureBuffer); //绘制 GLES20.GL_TRIANGLE_STRIP:复用坐标 GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, vertexCount); GLES20.glDisableVertexAttribArray(avPosition); GLES20.glDisableVertexAttribArray(afPosition); //解绑纹理 GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, 0); //解绑fbo GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0); &#125; private void createFBO() &#123; if (bitmap == null) &#123; throw new IllegalArgumentException("bitmap is null"); &#125; //1. 创建FBO int[] fbos = new int[1]; GLES20.glGenFramebuffers(1, fbos, 0); fboId = fbos[0]; //2. 绑定FBO GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, fboId); //3. 创建FBO纹理 fboTextureId = createTexture(); //4. 把纹理绑定到FBO GLES20.glFramebufferTexture2D(GLES20.GL_FRAMEBUFFER, GLES20.GL_COLOR_ATTACHMENT0, GLES20.GL_TEXTURE_2D, fboTextureId, 0); //5. 设置FBO分配内存大小 GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, 0, GLES20.GL_RGBA, bitmap.getWidth(), bitmap.getHeight(), 0, GLES20.GL_RGBA, GLES20.GL_UNSIGNED_BYTE, null); //6. 检测是否绑定从成功 if (GLES20.glCheckFramebufferStatus(GLES20.GL_FRAMEBUFFER) != GLES20.GL_FRAMEBUFFER_COMPLETE) &#123; Log.e("zzz", "glFramebufferTexture2D error"); &#125; //7. 解绑纹理和FBO GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, 0); GLES20.glBindFramebuffer(GLES20.GL_FRAMEBUFFER, 0); &#125; private int createImageTexture() &#123; int[] textureIds = new int[1]; //创建纹理 GLES20.glGenTextures(1, textureIds, 0); if (textureIds[0] == 0) &#123; return 0; &#125; //绑定纹理 GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureIds[0]); //环绕（超出纹理坐标范围） （s==x t==y GL_REPEAT 重复） GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_REPEAT); GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_REPEAT); //过滤（纹理像素映射到坐标点） （缩小、放大：GL_LINEAR线性） GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR); GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR); //测试图片 GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, bitmap, 0); //解绑纹理 GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, 0); return textureIds[0]; &#125; private int createTexture() &#123; int[] textureIds = new int[1]; //创建纹理 GLES20.glGenTextures(1, textureIds, 0); if (textureIds[0] == 0) &#123; return 0; &#125; //绑定纹理 GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureIds[0]); //环绕（超出纹理坐标范围） （s==x t==y GL_REPEAT 重复） GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_REPEAT); GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_REPEAT); //过滤（纹理像素映射到坐标点） （缩小、放大：GL_LINEAR线性） GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR); GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR); return textureIds[0]; &#125; public int getFboTextureId() &#123; return fboTextureId; &#125; public void onSurfaceChanged(int width, int height) &#123; &#125;&#125; 渲染类：BitmapRenderTexture.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104import android.content.Context;import android.opengl.GLES20;import java.nio.ByteBuffer;import java.nio.ByteOrder;import java.nio.FloatBuffer;//纹理 根据坐标系映射public class BitmapRenderTexture &#123; //顶点坐标 static float vertexData[] = &#123; // in counterclockwise order: -1f, -1f, 0.0f, // bottom left 1f, -1f, 0.0f, // bottom right -1f, 1f, 0.0f, // top left 1f, 1f, 0.0f, // top right &#125;; //纹理坐标 对应顶点坐标 与之映射 static float textureData[] = &#123; // in counterclockwise order: 0f, 1f, 0.0f, // bottom left 1f, 1f, 0.0f, // bottom right 0f, 0f, 0.0f, // top left 1f, 0f, 0.0f, // top right &#125;; //每一次取点的时候取几个点 static final int COORDS_PER_VERTEX = 3; private final int vertexCount = vertexData.length / COORDS_PER_VERTEX; //每一次取的总的点 大小 private final int vertexStride = COORDS_PER_VERTEX * 4; // 4 bytes per vertex private Context context; //位置 private FloatBuffer vertexBuffer; //纹理 private FloatBuffer textureBuffer; private int program; private int avPosition; //纹理位置 private int afPosition; public BitmapRenderTexture(Context context) &#123; this.context = context; vertexBuffer = ByteBuffer.allocateDirect(vertexData.length * 4) .order(ByteOrder.nativeOrder()) .asFloatBuffer() .put(vertexData); vertexBuffer.position(0); textureBuffer = ByteBuffer.allocateDirect(textureData.length * 4) .order(ByteOrder.nativeOrder()) .asFloatBuffer() .put(textureData); textureBuffer.position(0); &#125; public void onSurfaceCreated() &#123; String vertexSource = ShaderUtil.readRawTxt(context, R.raw.vertex_shader); String fragmentSource = ShaderUtil.readRawTxt(context, R.raw.fragment_shader); program = ShaderUtil.createProgram(vertexSource, fragmentSource); if (program &gt; 0) &#123; //获取顶点坐标字段 avPosition = GLES20.glGetAttribLocation(program, "av_Position"); //获取纹理坐标字段 afPosition = GLES20.glGetAttribLocation(program, "af_Position"); &#125; &#125; public void draw(int textureId) &#123; //使用程序 GLES20.glUseProgram(program); //绑定渲染纹理 GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureId); GLES20.glEnableVertexAttribArray(avPosition); GLES20.glEnableVertexAttribArray(afPosition); //设置顶点位置值 GLES20.glVertexAttribPointer(avPosition, COORDS_PER_VERTEX, GLES20.GL_FLOAT, false, vertexStride, vertexBuffer); //设置纹理位置值 GLES20.glVertexAttribPointer(afPosition, COORDS_PER_VERTEX, GLES20.GL_FLOAT, false, vertexStride, textureBuffer); //绘制 GLES20.GL_TRIANGLE_STRIP:复用坐标 GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, vertexCount); GLES20.glDisableVertexAttribArray(avPosition); GLES20.glDisableVertexAttribArray(afPosition); //解绑纹理 GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, 0); &#125; public void onSurfaceChanged(int width, int height) &#123; GLES20.glViewport(0, 0, width, height); &#125;&#125;]]></content>
      <categories>
        <category>OpenGLES</category>
      </categories>
      <tags>
        <tag>OpenGLES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenGLES顶点缓冲VBO]]></title>
    <url>%2FOpenGLES%E9%A1%B6%E7%82%B9%E7%BC%93%E5%86%B2VBO.html</url>
    <content type="text"><![CDATA[VBO Vertex Buffer object 为什么要用VBO 不使用VBO时，我们每次绘制（ glDrawArrays ）图形时都是从本地内存处获取顶点数据然后传输给OpenGL来绘制，这样就会频繁的操作CPU-&gt;GPU增大开销，从而降低效率。使用VBO，我们就能把顶点数据缓存到GPU开辟的一段内存中，然后使用时不必再从本地获取，而是直接从显存中获取，这样就能提升绘制的效率。 创建VBO的主要步骤: 12345678910111213141516//1. 创建VBO得到vboIdint[] vbos = new int[1];GLES20.glGenBuffers(1, vbos, 0);vboId = vbos[0];//2. 根据id绑定VBOGLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, vboId);//3. 分配VBO需要的缓存大小GLES20.glBufferData(GLES20.GL_ARRAY_BUFFER, vertex.length * 4,null, GLES20. GL_STATIC_DRAW);//4. 为VBO设置顶点数据的值GLES20.glBufferSubData(GLES20.GL_ARRAY_BUFFER, 0, vertexData.length * 4, vertexBuffer);//5. 解绑VBOGLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, 0); 使用VBO的主要步骤: 12345678//1. 根据id绑定VBOGLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, vboId);//2. 设置顶点数据GLES20.glVertexAttribPointer(vPosition, 2, GLES20.GL_FLOAT, false, 8, 0);//3. 解绑VBOGLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, 0); 我使用绘制图片纹理的代码来进行改造为VBO，OpenGLES 绘制图片纹理 改造的只有BitmapTexture这个类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162import android.content.Context;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.opengl.GLES20;import android.opengl.GLUtils;import java.nio.ByteBuffer;import java.nio.ByteOrder;import java.nio.FloatBuffer;//纹理 根据坐标系映射public class BitmapTexture &#123; //顶点坐标 static float vertexData[] = &#123; // in counterclockwise order: -1f, -1f, 0.0f, // bottom left 1f, -1f, 0.0f, // bottom right -1f, 1f, 0.0f, // top left 1f, 1f, 0.0f, // top right &#125;; //纹理坐标 对应顶点坐标 与之映射 static float textureData[] = &#123; // in counterclockwise order: 0f, 1f, 0.0f, // bottom left 1f, 1f, 0.0f, // bottom right 0f, 0f, 0.0f, // top left 1f, 0f, 0.0f, // top right &#125;; //每一次取点的时候取几个点 static final int COORDS_PER_VERTEX = 3; private final int vertexCount = vertexData.length / COORDS_PER_VERTEX; //每一次取的总的点 大小 private final int vertexStride = COORDS_PER_VERTEX * 4; // 4 bytes per vertex private Context context; //位置 private FloatBuffer vertexBuffer; //纹理 private FloatBuffer textureBuffer; private int program; private int avPosition; //纹理位置 private int afPosition; //纹理id private int textureId; //vbo id private int vboId; public BitmapTexture(Context context) &#123; this.context = context; vertexBuffer = ByteBuffer.allocateDirect(vertexData.length * 4) .order(ByteOrder.nativeOrder()) .asFloatBuffer() .put(vertexData); vertexBuffer.position(0); textureBuffer = ByteBuffer.allocateDirect(textureData.length * 4) .order(ByteOrder.nativeOrder()) .asFloatBuffer() .put(textureData); textureBuffer.position(0); &#125; public void onSurfaceCreated() &#123; String vertexSource = ShaderUtil.readRawTxt(context, R.raw.vertex_shader); String fragmentSource = ShaderUtil.readRawTxt(context, R.raw.fragment_shader); program = ShaderUtil.createProgram(vertexSource, fragmentSource); if (program &gt; 0) &#123; //获取顶点坐标字段 avPosition = GLES20.glGetAttribLocation(program, "av_Position"); //获取纹理坐标字段 afPosition = GLES20.glGetAttribLocation(program, "af_Position"); //创建vbo createVBO(); int[] textureIds = new int[1]; //创建纹理 GLES20.glGenTextures(1, textureIds, 0); if (textureIds[0] == 0) &#123; return; &#125; textureId = textureIds[0]; //绑定纹理 GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureId); //环绕（超出纹理坐标范围） （s==x t==y GL_REPEAT 重复） GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_REPEAT); GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_REPEAT); //过滤（纹理像素映射到坐标点） （缩小、放大：GL_LINEAR线性） GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR); GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR); Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), R.mipmap.bg); if (bitmap == null) &#123; return; &#125; //设置纹理为2d图片 GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, bitmap, 0); &#125; &#125; public void draw() &#123; //使用程序 GLES20.glUseProgram(program); GLES20.glEnableVertexAttribArray(avPosition); GLES20.glEnableVertexAttribArray(afPosition); //直接设置 // 设置顶点位置值// GLES20.glVertexAttribPointer(avPosition, COORDS_PER_VERTEX, GLES20.GL_FLOAT, false, vertexStride, vertexBuffer); //设置纹理值// GLES20.glVertexAttribPointer(afPosition, COORDS_PER_VERTEX, GLES20.GL_FLOAT, false, vertexStride, textureBuffer); //使用vbo设置 useVboDraw(); //绘制 GLES20.GL_TRIANGLE_STRIP:复用坐标 GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, vertexCount); GLES20.glDisableVertexAttribArray(avPosition); GLES20.glDisableVertexAttribArray(afPosition); &#125; private void createVBO() &#123; //1. 创建VBO int[] vbos = new int[1]; GLES20.glGenBuffers(vbos.length, vbos, 0); vboId = vbos[0]; //2. 绑定VBO GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, vboId); //3. 分配VBO需要的缓存大小 GLES20.glBufferData(GLES20.GL_ARRAY_BUFFER, vertexData.length * 4 + textureData.length * 4, null, GLES20.GL_STATIC_DRAW); //4. 为VBO设置顶点数据的值 GLES20.glBufferSubData(GLES20.GL_ARRAY_BUFFER, 0, vertexData.length * 4, vertexBuffer); GLES20.glBufferSubData(GLES20.GL_ARRAY_BUFFER, vertexData.length * 4, textureData.length * 4, textureBuffer); //5. 解绑VBO GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, 0); &#125; private void useVboDraw() &#123; //1. 绑定VBO GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, vboId); //2. 设置顶点数据 GLES20.glVertexAttribPointer(avPosition, COORDS_PER_VERTEX, GLES20.GL_FLOAT, false, vertexStride, 0); GLES20.glVertexAttribPointer(afPosition, COORDS_PER_VERTEX, GLES20.GL_FLOAT, false, vertexStride, vertexData.length * 4); //3. 解绑VBO GLES20.glBindBuffer(GLES20.GL_ARRAY_BUFFER, 0); &#125;&#125;]]></content>
      <categories>
        <category>OpenGLES</category>
      </categories>
      <tags>
        <tag>OpenGLES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android自定义GLSurfaceView]]></title>
    <url>%2FAndroid%E8%87%AA%E5%AE%9A%E4%B9%89GLSurfaceView.html</url>
    <content type="text"><![CDATA[当我们需要把同一个场景渲染到不同的Surface上时，此时系统GLSurfaceView 就不能满足需求了，所以我们需要自己创建EGL环境来实现渲染操作。注意: OpenGL整体是一个状态机，通过改变状态就能改变后续的渲染方式，而 EGLContext（EgL上下文）就保存有所有状态，因此可以通过共享EGLContext 来实现同一场景渲染到不同的Surface上。 我们通过分析GLSurfaceView来实现自己的代码 首先需要配置EGL环境(EGLHelper)：Android配置EGL环境 EGL环境配置成功后，定义GLSurfaceView主要为以下步骤： 1、继成SurfaceView，并实现其CallBack回调2、自定义GLThread线程类，主要用于OpenGL的绘制操作3、添加设置Surface和EglContext的方法4、提供和系统GLSurfaceView相同的调用方法 EglSurfaceView.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234package com.zzw.glsurfaceviewdemo;import android.content.Context;import android.util.AttributeSet;import android.view.Surface;import android.view.SurfaceHolder;import android.view.SurfaceView;import java.lang.ref.WeakReference;import javax.microedition.khronos.egl.EGLContext;public class EglSurfaceView extends SurfaceView implements SurfaceHolder.Callback &#123; private Renderer mRenderer; private EGLThread mEGLThread; private Surface mSurface; private EGLContext mEglContext; public final static int RENDERMODE_WHEN_DIRTY = 0; public final static int RENDERMODE_CONTINUOUSLY = 1; private int mRenderMode = RENDERMODE_CONTINUOUSLY; public EglSurfaceView(Context context) &#123; this(context, null); &#125; public EglSurfaceView(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public EglSurfaceView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; private void init() &#123; SurfaceHolder holder = getHolder(); holder.addCallback(this); &#125; @Override public void surfaceCreated(SurfaceHolder holder) &#123; if (mSurface == null) &#123; mSurface = holder.getSurface(); &#125; mEGLThread = new EGLThread(new WeakReference&lt;&gt;(this)); mEGLThread.isCreate = true; mEGLThread.start(); &#125; @Override public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) &#123; mEGLThread.width = width; mEGLThread.height = height; mEGLThread.isChange = true; &#125; @Override public void surfaceDestroyed(SurfaceHolder holder) &#123; mEGLThread.onDestroy(); mEGLThread = null; mSurface = null; mEglContext = null; &#125; public void setRenderer(Renderer mRenderer) &#123; this.mRenderer = mRenderer; &#125; public void setRenderMode(int renderMode) &#123; if (mRenderer == null) &#123; throw new RuntimeException("must set render before"); &#125; this.mRenderMode =renderMode; &#125; public void requestRender() &#123; if (mEGLThread != null) &#123; mEGLThread.requestRender(); &#125; &#125; public void setSurfaceAndEglContext(Surface surface, EGLContext eglContext) &#123; this.mSurface = surface; this.mEglContext = eglContext; &#125; public EGLContext getEglContext() &#123; if (mEGLThread != null) &#123; return mEGLThread.getEglContext(); &#125; return null; &#125; private static class EGLThread extends Thread &#123; EGLThread(WeakReference&lt;EglSurfaceView&gt; eGLSurfaceViewWeakRef) &#123; this.mEGLSurfaceViewWeakRef = eGLSurfaceViewWeakRef; &#125; @Override public void run() &#123; super.run(); try &#123; guardedRun(); &#125; catch (Exception e) &#123; // fall thru and exit normally &#125; &#125; private void guardedRun() throws InterruptedException &#123; isExit = false; isStart = false; object = new Object(); mEglHelper = new EglHelper(); mEglHelper.initEgl(mEGLSurfaceViewWeakRef.get().mSurface, mEGLSurfaceViewWeakRef.get().mEglContext); while (true) &#123; if (isExit) &#123; //释放资源 release(); break; &#125; if (isStart) &#123; if (mEGLSurfaceViewWeakRef.get().mRenderMode == RENDERMODE_WHEN_DIRTY) &#123; synchronized (object) &#123; object.wait(); &#125; &#125; else if (mEGLSurfaceViewWeakRef.get().mRenderMode == RENDERMODE_CONTINUOUSLY) &#123; Thread.sleep(1000 / 60); &#125; else &#123; throw new IllegalArgumentException("renderMode"); &#125; &#125; onCreate(); onChange(width, height); onDraw(); isStart = true; &#125; &#125; private void onCreate() &#123; if (!isCreate || mEGLSurfaceViewWeakRef.get().mRenderer == null) return; isCreate = false; mEGLSurfaceViewWeakRef.get().mRenderer.onSurfaceCreated(); &#125; private void onChange(int width, int height) &#123; if (!isChange || mEGLSurfaceViewWeakRef.get().mRenderer == null) return; isChange = false; mEGLSurfaceViewWeakRef.get().mRenderer.onSurfaceChanged(width, height); &#125; private void onDraw() &#123; if (mEGLSurfaceViewWeakRef.get().mRenderer == null) return; mEGLSurfaceViewWeakRef.get().mRenderer.onDrawFrame(); //第一次的时候手动调用一次 不然不会显示ui if (!isStart) &#123; mEGLSurfaceViewWeakRef.get().mRenderer.onDrawFrame(); &#125; mEglHelper.swapBuffers(); &#125; void requestRender() &#123; if (object != null) &#123; synchronized (object) &#123; object.notifyAll(); &#125; &#125; &#125; void onDestroy() &#123; isExit = true; //释放锁 requestRender(); &#125; void release() &#123; if (mEglHelper != null) &#123; mEglHelper.destoryEgl(); mEglHelper = null; object = null; mEGLSurfaceViewWeakRef = null; &#125; &#125; EGLContext getEglContext() &#123; if (mEglHelper != null) &#123; return mEglHelper.getEglContext(); &#125; return null; &#125; private WeakReference&lt;EglSurfaceView&gt; mEGLSurfaceViewWeakRef; private EglHelper mEglHelper; private int width; private int height; private boolean isCreate; private boolean isChange; private boolean isStart; private boolean isExit; private Object object; &#125; interface Renderer &#123; void onSurfaceCreated(); void onSurfaceChanged(int width, int height); void onDrawFrame(); &#125;&#125; 使用和正常的GLSurfaceView一样: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.zzw.glsurfaceviewdemo;import android.opengl.GLES20;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.util.Log;import android.view.View;public class MainActivity extends AppCompatActivity implements EglSurfaceView.Renderer &#123; private EglSurfaceView eglSurfaceView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); eglSurfaceView = findViewById(R.id.egl_surface_view); eglSurfaceView = new EglSurfaceView(this); eglSurfaceView.setRenderer(this);// eglSurfaceView.setRenderMode(EglSurfaceView.RENDERMODE_CONTINUOUSLY); eglSurfaceView.setRenderMode(EglSurfaceView.RENDERMODE_WHEN_DIRTY); eglSurfaceView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; eglSurfaceView.requestRender(); &#125; &#125;); setContentView(eglSurfaceView); &#125; @Override public void onSurfaceCreated() &#123; Log.e("zzz", "onSurfaceCreated"); &#125; @Override public void onSurfaceChanged(int width, int height) &#123; Log.e("zzz", "onSurfaceChanged"); GLES20.glViewport(0, 0, width, height); &#125; @Override public void onDrawFrame() &#123; Log.e("zzz", "onDrawFrame"); GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT); GLES20.glClearColor(1.0f, 0.0f, 1.0f, 1.0f); &#125;&#125;]]></content>
      <categories>
        <category>OpenGLES</category>
      </categories>
      <tags>
        <tag>OpenGLES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android配置EGL环境]]></title>
    <url>%2FAndroid%E9%85%8D%E7%BD%AEEGL%E7%8E%AF%E5%A2%83.html</url>
    <content type="text"><![CDATA[EGL 是OpenGL ES和本地窗口系统的接口，不同平台上EGL配置是不一样的，而OpenGL的调用方式是一致的，就是说：OpenGL跨平台就是依赖于EGL接口。我的得理解是：在一个平台上搭建OpenGL的环境。 为什么要自己创建EGL环境？ 有的人会想，在android里面系统已经提供了GLSurfaceView，已经有了EGL环境，我们为什么还要自己搭建这个环境呢？当我们需要把同一个场景渲染到不同的Surface上时，此时系统GLSurfaceView就不能满足需求了，所以我们需要自己创建EGL环境来实现渲染操作。注意: OpenGL整体是一个状态机，通过改变状态就能改变后续的渲染方式，而EGLContext（EgL上下文）就保存有所有状态，因此可以通过共享EGLContext来实现同一场景渲染到不同的Surface上。 Android配置egl环境我们根据GLSurfaceView源码来实现。在GLSurfaceView源码里面，当调用setRenderer的时候会开启一个线程GLThread,GLThread调用start的时候会初始化EglHelper来配置egl环境，然后一个while(true)执行，根据不同的标识判断执行egl的环境配置，Renderer的onSurfaceCreated,onSurfaceChanged,onDrawFrame等函数。 从源码得知我们配置egl环境主要根据GLSurfaceView.EglHelper来写，主要分为已下几步： 1、得到Egl实例2、得到默认的显示设备（就是窗口）3、初始化默认显示设备4、设置显示设备的属性5、从系统中获取对应属性的配置6、创建EglContext7、创建渲染的Surface8、绑定EglContext和Surface到显示设备中9、刷新数据，显示渲染场景 最终代码如下:EglHelper.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175package com.zzw.glsurfaceviewdemo;import android.view.Surface;import javax.microedition.khronos.egl.EGL10;import javax.microedition.khronos.egl.EGLConfig;import javax.microedition.khronos.egl.EGLContext;import javax.microedition.khronos.egl.EGLDisplay;import javax.microedition.khronos.egl.EGLSurface;public class EglHelper &#123; private static final String TAG = "EglHelper"; private EGL10 mEgl; private EGLDisplay mEglDisplay; private EGLContext mEglContext; private EGLSurface mEglSurface; public void initEgl(Surface surface, EGLContext eglContext) &#123; //1. 得到Egl实例 mEgl = (EGL10) EGLContext.getEGL(); //2. 得到默认的显示设备（就是窗口） mEglDisplay = mEgl.eglGetDisplay(EGL10.EGL_DEFAULT_DISPLAY); if (mEglDisplay == EGL10.EGL_NO_DISPLAY) &#123; throw new RuntimeException("eglGetDisplay failed"); &#125; //3. 初始化默认显示设备 int[] version = new int[2]; if (!mEgl.eglInitialize(mEglDisplay, version)) &#123; throw new RuntimeException("eglInitialize failed"); &#125; //4. 设置显示设备的属性 int[] attrib_list = new int[]&#123; EGL10.EGL_RED_SIZE, mRedSize, EGL10.EGL_GREEN_SIZE, mGreenSize, EGL10.EGL_BLUE_SIZE, mBlueSize, EGL10.EGL_ALPHA_SIZE, mAlphaSize, EGL10.EGL_DEPTH_SIZE, mDepthSize, EGL10.EGL_STENCIL_SIZE, mStencilSize, EGL10.EGL_RENDERABLE_TYPE, mRenderType,//egl版本 2.0 EGL10.EGL_NONE&#125;; int[] num_config = new int[1]; if (!mEgl.eglChooseConfig(mEglDisplay, attrib_list, null, 1, num_config)) &#123; throw new IllegalArgumentException("eglChooseConfig failed"); &#125; int numConfigs = num_config[0]; if (numConfigs &lt;= 0) &#123; throw new IllegalArgumentException( "No configs match configSpec"); &#125; //5. 从系统中获取对应属性的配置 EGLConfig[] configs = new EGLConfig[numConfigs]; if (!mEgl.eglChooseConfig(mEglDisplay, attrib_list, configs, numConfigs, num_config)) &#123; throw new IllegalArgumentException("eglChooseConfig#2 failed"); &#125; EGLConfig eglConfig = chooseConfig(mEgl, mEglDisplay, configs); if (eglConfig == null) &#123; eglConfig = configs[0]; &#125; //6. 创建EglContext int[] contextAttr = new int[]&#123; EGL14.EGL_CONTEXT_CLIENT_VERSION, 2, EGL10.EGL_NONE &#125;; if (eglContext == null) &#123; mEglContext = mEgl.eglCreateContext(mEglDisplay, eglConfig, EGL10.EGL_NO_CONTEXT, contextAttr); &#125; else &#123; mEglContext = mEgl.eglCreateContext(mEglDisplay, eglConfig, eglContext, contextAttr); &#125; //7. 创建渲染的Surface mEglSurface = mEgl.eglCreateWindowSurface(mEglDisplay, eglConfig, surface, null); //8. 绑定EglContext和Surface到显示设备中 if (!mEgl.eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface, mEglContext)) &#123; throw new RuntimeException("eglMakeCurrent fail"); &#125; &#125; //9. 刷新数据，显示渲染场景 public boolean swapBuffers() &#123; if (mEgl != null) &#123; return mEgl.eglSwapBuffers(mEglDisplay, mEglSurface); &#125; else &#123; throw new RuntimeException("egl is null"); &#125; &#125; public void destoryEgl() &#123; if (mEgl != null) &#123; if (mEglSurface != null &amp;&amp; mEglSurface != EGL10.EGL_NO_SURFACE) &#123; mEgl.eglMakeCurrent(mEglDisplay, EGL10.EGL_NO_SURFACE, EGL10.EGL_NO_SURFACE, EGL10.EGL_NO_CONTEXT); mEgl.eglDestroySurface(mEglDisplay, mEglSurface); mEglSurface = null; &#125; if (mEglContext != null) &#123; mEgl.eglDestroyContext(mEglDisplay, mEglContext); mEglContext = null; &#125; if (mEglDisplay != null) &#123; mEgl.eglTerminate(mEglDisplay); mEglDisplay = null; &#125; mEgl = null; &#125; &#125; public EGLContext getEglContext() &#123; return mEglContext; &#125; private final int mRedSize = 8; private final int mGreenSize = 8; private final int mBlueSize = 8; private final int mAlphaSize = 8; private final int mDepthSize = 8; private final int mStencilSize = 8; private final int mRenderType = 4; private EGLConfig chooseConfig(EGL10 egl, EGLDisplay display, EGLConfig[] configs) &#123; for (EGLConfig config : configs) &#123; int d = findConfigAttrib(egl, display, config, EGL10.EGL_DEPTH_SIZE, 0); int s = findConfigAttrib(egl, display, config, EGL10.EGL_STENCIL_SIZE, 0); if ((d &gt;= mDepthSize) &amp;&amp; (s &gt;= mStencilSize)) &#123; int r = findConfigAttrib(egl, display, config, EGL10.EGL_RED_SIZE, 0); int g = findConfigAttrib(egl, display, config, EGL10.EGL_GREEN_SIZE, 0); int b = findConfigAttrib(egl, display, config, EGL10.EGL_BLUE_SIZE, 0); int a = findConfigAttrib(egl, display, config, EGL10.EGL_ALPHA_SIZE, 0); if ((r == mRedSize) &amp;&amp; (g == mGreenSize) &amp;&amp; (b == mBlueSize) &amp;&amp; (a == mAlphaSize)) &#123; return config; &#125; &#125; &#125; return null; &#125; private int findConfigAttrib(EGL10 egl, EGLDisplay display, EGLConfig config, int attribute, int defaultValue) &#123; int[] value = new int[1]; if (egl.eglGetConfigAttrib(display, config, attribute, value)) &#123; return value[0]; &#125; return defaultValue; &#125;&#125;]]></content>
      <categories>
        <category>OpenGLES</category>
      </categories>
      <tags>
        <tag>OpenGLES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ffmpeg音视频合成]]></title>
    <url>%2Fffmpeg%E9%9F%B3%E8%A7%86%E9%A2%91%E5%90%88%E6%88%90.html</url>
    <content type="text"><![CDATA[原理 : 主要是拿到视频文件得视频流，然后拿到音频文件的音频流，根据时间戳一帧一帧的封装成一个新的视频文件 效果：音频文件和视频文件合成一个文件，合成的文件时间就是两个文件中短的时间。源代码如下:具体看注释 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294#include &lt;jni.h&gt;#include &lt;android/log.h&gt;extern "C" &#123;#include "libavcodec/avcodec.h"#include "libavformat/avformat.h"&#125;;#define LOG_TAG "JNI_TAG"#define LOGD(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)extern "C"JNIEXPORT void JNICALLJava_com_zzw_ffmpegdemo_FFmpegHelper_megre(JNIEnv *env, jobject instance, jstring musicPath_, jstring videoPath_,jstring outPath_) &#123; AVOutputFormat *ofmt = NULL; //Input AVFormatContext and Output AVFormatContext AVFormatContext *ifmt_ctx_v = NULL, *ifmt_ctx_a = NULL,*ofmt_ctx = NULL; int ret, i; int videoindex_v=-1,videoindex_out=-1; int audioindex_a=-1,audioindex_out=-1; int frame_index=0; int64_t cur_pts_v=0,cur_pts_a=0; const char *musicPath = env-&gt;GetStringUTFChars(musicPath_, 0); const char *videoPath = env-&gt;GetStringUTFChars(videoPath_, 0); const char *outPath = env-&gt;GetStringUTFChars(outPath_, 0); av_register_all(); //--------------------------------input init start--------------------------------------------- if ((ret = avformat_open_input(&amp;ifmt_ctx_v, videoPath, 0, 0)) &lt; 0) &#123;//打开输入的视频文件 LOGD( "Could not open input video file."); goto end; &#125; if ((ret = avformat_find_stream_info(ifmt_ctx_v, 0)) &lt; 0) &#123;//获取视频文件信息 LOGD( "Failed to retrieve input video stream information"); goto end; &#125; if ((ret = avformat_open_input(&amp;ifmt_ctx_a, musicPath, 0, 0)) &lt; 0) &#123;//打开输入的音频文件 LOGD( "Could not open input audio file."); goto end; &#125; if ((ret = avformat_find_stream_info(ifmt_ctx_a, 0)) &lt; 0) &#123;//获取音频文件信息 LOGD( "Failed to retrieve input audio stream information"); goto end; &#125;// LOGD("===========Input Information==========\n");// av_dump_format(ifmt_ctx_v, 0, videoPath, 0);// av_dump_format(ifmt_ctx_a, 0, musicPath, 0);// LOGD("======================================\n"); //--------------------------------input init end--------------------------------------------- //--------------------------------out init start--------------------------------------------- //初始化输出码流的AVFormatContext avformat_alloc_output_context2(&amp;ofmt_ctx,NULL,NULL, outPath); if(!ofmt_ctx)&#123; LOGD( "Could not create output context\n"); ret = AVERROR_UNKNOWN; goto end; &#125; ofmt = ofmt_ctx-&gt;oformat; //--------------------------------out init end----------------------------------------------- //--------------------------------相关值获取----------------------------------------------- //从输入video的AVStream中获取一个video输出的out_stream for (i = 0; i &lt; ifmt_ctx_v-&gt;nb_streams; i++) &#123; if(ifmt_ctx_v-&gt;streams[i]-&gt;codecpar-&gt;codec_type==AVMEDIA_TYPE_VIDEO)&#123; AVStream* in_stream = ifmt_ctx_v-&gt;streams[i]; AVCodec *dec = avcodec_find_decoder(in_stream-&gt;codecpar-&gt;codec_id); if(!dec)&#123; LOGD( "Could not find decoder\n"); ret = AVERROR_UNKNOWN; goto end; &#125; AVStream* out_stream = avformat_new_stream(ofmt_ctx,dec); videoindex_v =i; if(!out_stream)&#123; LOGD( "Failed allocating output stream\n"); ret = AVERROR_UNKNOWN; goto end; &#125; videoindex_out=out_stream-&gt;index; AVCodecContext* avCodecContext = avcodec_alloc_context3(dec); if ((ret =avcodec_parameters_to_context(avCodecContext, in_stream-&gt;codecpar)) &lt; 0) &#123; avcodec_free_context(&amp;avCodecContext); avCodecContext = NULL; LOGD("can not fill decodecctx"); goto end; &#125; avCodecContext-&gt;codec_tag = 0; if (ofmt_ctx-&gt;oformat-&gt;flags &amp; AVFMT_GLOBALHEADER) &#123; avCodecContext-&gt;flags |= CODEC_FLAG_GLOBAL_HEADER; &#125; ret = avcodec_parameters_from_context(out_stream-&gt;codecpar, avCodecContext); if (ret &lt; 0) &#123; printf("Failed to copy context input to output stream codec context\n"); goto end; &#125; break; &#125; &#125; //从输入audio的AVStream中获取一个audio输出的out_stream for (i = 0; i &lt; ifmt_ctx_a-&gt;nb_streams; i++) &#123; if(ifmt_ctx_a-&gt;streams[i]-&gt;codecpar-&gt;codec_type==AVMEDIA_TYPE_AUDIO)&#123; AVStream* in_stream = ifmt_ctx_a-&gt;streams[i]; AVCodec *dec = avcodec_find_decoder(in_stream-&gt;codecpar-&gt;codec_id); if(!dec)&#123; LOGD( "Could not find decoder\n"); ret = AVERROR_UNKNOWN; goto end; &#125; AVStream* out_stream = avformat_new_stream(ofmt_ctx,dec); audioindex_a =i; if(!out_stream)&#123; LOGD( "Failed allocating output stream\n"); ret = AVERROR_UNKNOWN; goto end; &#125; audioindex_out=out_stream-&gt;index; AVCodecContext* avCodecContext = avcodec_alloc_context3(dec); if ((ret =avcodec_parameters_to_context(avCodecContext, in_stream-&gt;codecpar)) &lt; 0) &#123; avcodec_free_context(&amp;avCodecContext); avCodecContext = NULL; LOGD("can not fill decodecctx"); goto end; &#125; avCodecContext-&gt;codec_tag = 0; if (ofmt_ctx-&gt;oformat-&gt;flags &amp; AVFMT_GLOBALHEADER) &#123; avCodecContext-&gt;flags |= CODEC_FLAG_GLOBAL_HEADER; &#125; ret = avcodec_parameters_from_context(out_stream-&gt;codecpar, avCodecContext); if (ret &lt; 0) &#123; printf("Failed to copy context input to output stream codec context\n"); goto end; &#125; break; &#125; &#125;// LOGD("==========Output Information==========\n");// av_dump_format(ofmt_ctx, 0, outPath, 1);// LOGD("======================================\n");// -------------------------------合成文件------------------------------------------- // Open output file if (!(ofmt-&gt;flags &amp; AVFMT_NOFILE)) &#123; ret = avio_open(&amp;ofmt_ctx-&gt;pb, outPath, AVIO_FLAG_WRITE); if (ret &lt; 0) &#123; LOGD("Could not open output file %s ", outPath); goto end; &#125; &#125; // Write file header ret = avformat_write_header(ofmt_ctx, NULL); if (ret &lt; 0) &#123; LOGD("Error occurred when opening output file\n"); goto end; &#125; while (1) &#123; AVFormatContext *ifmt_ctx; int stream_index=0; AVStream *in_stream, *out_stream; AVPacket *pkt = av_packet_alloc(); //Get an AVPacket . av_compare_ts是比较时间戳用的。通过该函数可以决定该写入视频还是音频。 //video 在 audio之前 if(av_compare_ts(cur_pts_v, ifmt_ctx_v-&gt;streams[videoindex_v]-&gt;time_base, cur_pts_a, ifmt_ctx_a-&gt;streams[audioindex_a]-&gt;time_base) &lt;= 0)&#123; ifmt_ctx=ifmt_ctx_v; stream_index=videoindex_out; &#125; else&#123; ifmt_ctx=ifmt_ctx_a; stream_index=audioindex_out; &#125; //如果video在audio之后 if(av_compare_ts(cur_pts_v, ifmt_ctx_v-&gt;streams[videoindex_v]-&gt;time_base, cur_pts_a, ifmt_ctx_a-&gt;streams[audioindex_a]-&gt;time_base) &lt;= 0)&#123; ifmt_ctx=ifmt_ctx_v; stream_index=videoindex_out; if(av_read_frame(ifmt_ctx, pkt) &gt;= 0)&#123; do&#123; if(pkt-&gt;stream_index==videoindex_v)&#123; in_stream = ifmt_ctx-&gt;streams[pkt-&gt;stream_index]; out_stream = ofmt_ctx-&gt;streams[stream_index]; //FIX：No PTS (Example: Raw H.264) H.264裸流没有PTS，因此必须手动写入PTS //Simple Write PTS if(pkt-&gt;pts==AV_NOPTS_VALUE)&#123; //Write PTS AVRational time_base1=in_stream-&gt;time_base; //Duration between 2 frames (us) int64_t calc_duration=(double)AV_TIME_BASE/av_q2d(in_stream-&gt;r_frame_rate); //Parameters pkt-&gt;pts=(double)(frame_index*calc_duration)/(double)(av_q2d(time_base1)*AV_TIME_BASE); pkt-&gt;dts=pkt-&gt;pts; pkt-&gt;duration=(double)calc_duration/(double)(av_q2d(time_base1)*AV_TIME_BASE); frame_index++; &#125; cur_pts_v=pkt-&gt;pts; break; &#125; &#125;while(av_read_frame(ifmt_ctx, pkt) &gt;= 0); &#125;else&#123; av_packet_free(&amp;pkt); av_free(pkt); break; &#125; &#125;else&#123; ifmt_ctx=ifmt_ctx_a; stream_index=audioindex_out; if(av_read_frame(ifmt_ctx, pkt) &gt;= 0)&#123; do&#123; if(pkt-&gt;stream_index==audioindex_a)&#123; in_stream = ifmt_ctx-&gt;streams[pkt-&gt;stream_index]; out_stream = ofmt_ctx-&gt;streams[stream_index]; //FIX：No PTS //Simple Write PTS if(pkt-&gt;pts==AV_NOPTS_VALUE)&#123; //Write PTS AVRational time_base1=in_stream-&gt;time_base; //Duration between 2 frames (us) int64_t calc_duration=(double)AV_TIME_BASE/av_q2d(in_stream-&gt;r_frame_rate); //Parameters pkt-&gt;pts=(double)(frame_index*calc_duration)/(double)(av_q2d(time_base1)*AV_TIME_BASE); pkt-&gt;dts=pkt-&gt;pts; pkt-&gt;duration=(double)calc_duration/(double)(av_q2d(time_base1)*AV_TIME_BASE); frame_index++; &#125; cur_pts_a=pkt-&gt;pts; break; &#125; &#125;while(av_read_frame(ifmt_ctx, pkt) &gt;= 0); &#125;else&#123; av_packet_free(&amp;pkt); av_free(pkt); break; &#125; &#125; //Convert PTS/DTS pkt-&gt;pts = av_rescale_q_rnd(pkt-&gt;pts, in_stream-&gt;time_base, out_stream-&gt;time_base, (AVRounding)(AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX)); pkt-&gt;dts = av_rescale_q_rnd(pkt-&gt;dts, in_stream-&gt;time_base, out_stream-&gt;time_base, (AVRounding)(AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX)); pkt-&gt;duration = av_rescale_q(pkt-&gt;duration, in_stream-&gt;time_base, out_stream-&gt;time_base); pkt-&gt;pos = -1; pkt-&gt;stream_index=stream_index; LOGD("Write 1 Packet. size:%5d\tpts:%lld\n",pkt-&gt;size,pkt-&gt;pts); //Write AVPacket 音频或视频裸流 if (av_interleaved_write_frame(ofmt_ctx, pkt) &lt; 0) &#123; LOGD( "Error muxing packet\n"); av_packet_free(&amp;pkt); av_free(pkt); break; &#125; av_packet_free(&amp;pkt); av_free(pkt); &#125; //Write file trailer av_write_trailer(ofmt_ctx);end: avformat_close_input(&amp;ifmt_ctx_v); avformat_close_input(&amp;ifmt_ctx_a); /* close output */ if (ofmt_ctx &amp;&amp; !(ofmt-&gt;flags &amp; AVFMT_NOFILE)) avio_close(ofmt_ctx-&gt;pb); avformat_free_context(ofmt_ctx); env-&gt;ReleaseStringUTFChars(musicPath_, musicPath); env-&gt;ReleaseStringUTFChars(videoPath_, videoPath); env-&gt;ReleaseStringUTFChars(outPath_, outPath);&#125;]]></content>
      <categories>
        <category>ffmpeg</category>
      </categories>
      <tags>
        <tag>音视频</tag>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ffmpeg添加水印和滤镜效果]]></title>
    <url>%2Fffmpeg%E6%B7%BB%E5%8A%A0%E6%B0%B4%E5%8D%B0%E5%92%8C%E6%BB%A4%E9%95%9C%E6%95%88%E6%9E%9C.html</url>
    <content type="text"><![CDATA[主要用到的api 1234567avfilter_register_all()：注册所有AVFilter。avfilter_graph_alloc()：为FilterGraph分配内存。avfilter_graph_create_filter()：创建并向FilterGraph中添加一个Filter。avfilter_graph_parse_ptr()：将一串通过字符串描述的Graph添加到FilterGraph中。avfilter_graph_config()：检查FilterGraph的配置。av_buffersrc_add_frame()：向FilterGraph中加入一个AVFrame。av_buffersink_get_frame()：从FilterGraph中取出一个AVFrame。 源代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286#include &lt;jni.h&gt;#include &lt;android/log.h&gt;#include &lt;android/native_window.h&gt;#include &lt;android/native_window_jni.h&gt;extern "C" &#123;#include "libavcodec/avcodec.h"#include "libavformat/avformat.h"#include "libswscale/swscale.h"#include "libavutil/imgutils.h"//-----AVfilter-----#include &lt;libavfilter/avfiltergraph.h&gt;#include &lt;libavfilter/buffersrc.h&gt;#include &lt;libavfilter/buffersink.h&gt;//-----AVfilter-----&#125;;#define LOG_TAG "JNI_TAG"#define LOGD(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)const char *filters_descr = "lutyuv='u=128:v=128'";//const char *filters_descr = "hflip";//const char *filters_descr = "hue='h=60:s=-3'";//const char *filters_descr = "crop=2/3*in_w:2/3*in_h";//const char *filters_descr = "drawbox=x=200:y=200:w=300:h=300:color=pink@0.5";//const char *filters_descr = "movie=/storage/emulated/0/shuiyin.png[wm];[in][wm]overlay=5:5[out]";//const char *filters_descr="drawgrid=width=100:height=100:thickness=4:color=pink@0.9";int getCodecContext(AVCodecParameters *codecpar, AVCodecContext **avCodecContext) &#123; AVCodec *dec = avcodec_find_decoder(codecpar-&gt;codec_id); if (!dec) &#123; LOGD("can not find decoder"); return -1; &#125; *avCodecContext = avcodec_alloc_context3(dec); if (!*avCodecContext) &#123; LOGD("can not alloc new decodecctx"); return -1; &#125; if (avcodec_parameters_to_context(*avCodecContext, codecpar) &lt; 0) &#123; avcodec_free_context(avCodecContext); *avCodecContext = NULL; LOGD("can not fill decodecctx"); return -1; &#125; if (avcodec_open2(*avCodecContext, dec, 0) != 0) &#123; LOGD("cant not open audio strames"); avcodec_free_context(avCodecContext); *avCodecContext = NULL; return -1; &#125; return 0;&#125;extern "C"JNIEXPORT void JNICALLJava_com_zzw_ffmpegdemo_FFmpegHelper_play(JNIEnv *env, jobject instance, jstring url_, jobject surface) &#123; const char *url = env-&gt;GetStringUTFChars(url_, 0); AVFormatContext *pFormatCtx = NULL; AVCodecContext *pCodecCtx = NULL; AVFilterContext *buffersink_ctx = NULL; AVFilterContext *buffersrc_ctx = NULL; AVFilterGraph *filter_graph = NULL; //-----------------------------AVCodecContext init start---------------------------- av_register_all(); avfilter_register_all();// pFormatCtx = avformat_alloc_context(); // Open video file if (avformat_open_input(&amp;pFormatCtx, url, NULL, NULL) != 0) &#123; LOGD("Couldn't open url:%s\n", url); return; // Couldn't open file &#125; // Retrieve stream information if (avformat_find_stream_info(pFormatCtx, NULL) &lt; 0) &#123; LOGD("Couldn't find stream information."); return; &#125; // Find the first video stream int videoStream = -1, i; for (i = 0; i &lt; pFormatCtx-&gt;nb_streams; i++) &#123; if (pFormatCtx-&gt;streams[i]-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO &amp;&amp; videoStream &lt; 0) &#123; videoStream = i; &#125; &#125; if (videoStream == -1) &#123; LOGD("Didn't find a video stream."); return; // Didn't find a video stream &#125; if (getCodecContext(pFormatCtx-&gt;streams[videoStream]-&gt;codecpar, &amp;pCodecCtx) != 0) &#123; LOGD("Didn't get CodecContext."); return; &#125; //-----------------------------AVCodecContext init end------------------------------- //------------------------------filter init start------------------------------------ char args[512]; AVFilter *buffersrc = avfilter_get_by_name("buffer"); AVFilter *buffersink = avfilter_get_by_name("buffersink");//新版的ffmpeg库必须为buffersink AVFilterInOut *outputs = avfilter_inout_alloc(); AVFilterInOut *inputs = avfilter_inout_alloc(); enum AVPixelFormat pix_fmts[] = &#123;AV_PIX_FMT_YUV420P, AV_PIX_FMT_NONE&#125;; filter_graph = avfilter_graph_alloc(); /* buffer video source: the decoded frames from the decoder will be inserted here. */ snprintf(args, sizeof(args), "video_size=%dx%d:pix_fmt=%d:time_base=%d/%d:pixel_aspect=%d/%d", pCodecCtx-&gt;width, pCodecCtx-&gt;height, pCodecCtx-&gt;pix_fmt, pFormatCtx-&gt;streams[videoStream]-&gt;time_base.num, pFormatCtx-&gt;streams[videoStream]-&gt;time_base.den, pCodecCtx-&gt;sample_aspect_ratio.num, pCodecCtx-&gt;sample_aspect_ratio.den); if (avfilter_graph_create_filter(&amp;buffersrc_ctx, buffersrc, "in", args, NULL, filter_graph) &lt; 0) &#123; LOGD("Cannot create buffer source\n"); return; &#125; AVBufferSinkParams *buffersink_params = av_buffersink_params_alloc(); buffersink_params-&gt;pixel_fmts = pix_fmts; if (avfilter_graph_create_filter(&amp;buffersink_ctx, buffersink, "out", NULL, buffersink_params, filter_graph) &lt; 0) &#123; LOGD("Cannot create buffer sink\n"); return; &#125; av_free(buffersink_params); /* Endpoints for the filter graph. */ outputs-&gt;name = av_strdup("in"); outputs-&gt;filter_ctx = buffersrc_ctx; outputs-&gt;pad_idx = 0; outputs-&gt;next = NULL; inputs-&gt;name = av_strdup("out"); inputs-&gt;filter_ctx = buffersink_ctx; inputs-&gt;pad_idx = 0; inputs-&gt;next = NULL; if ((avfilter_graph_parse_ptr(filter_graph, filters_descr, &amp;inputs, &amp;outputs, NULL)) &lt; 0) &#123; LOGD("Cannot avfilter_graph_parse_ptr\n"); return; &#125; if ((avfilter_graph_config(filter_graph, NULL)) &lt; 0) &#123; LOGD("Cannot avfilter_graph_config\n"); return; &#125; //------------------------------filter init end------------------------------------ //------------------------------window init start----------------------------------- // 获取native window ANativeWindow *nativeWindow = ANativeWindow_fromSurface(env, surface); // 获取视频宽高 int videoWidth = pCodecCtx-&gt;width; int videoHeight = pCodecCtx-&gt;height; // 设置native window的buffer大小,可自动拉伸 ANativeWindow_setBuffersGeometry(nativeWindow, videoWidth, videoHeight, WINDOW_FORMAT_RGBA_8888); ANativeWindow_Buffer windowBuffer; //------------------------------window init end----------------------------------- //------------------------------get data----------------------------------- // 用于渲染 AVFrame *pFrameRGBA = av_frame_alloc(); // Determine required buffer size and allocate buffer // buffer中数据就是用于渲染的,且格式为RGBA int numBytes = av_image_get_buffer_size(AV_PIX_FMT_RGBA, pCodecCtx-&gt;width, pCodecCtx-&gt;height, 1); uint8_t *buffer = (uint8_t *) av_malloc(numBytes * sizeof(uint8_t)); av_image_fill_arrays(pFrameRGBA-&gt;data, pFrameRGBA-&gt;linesize, buffer, AV_PIX_FMT_RGBA, pCodecCtx-&gt;width, pCodecCtx-&gt;height, 1); // 由于解码出来的帧格式不是RGBA的,在渲染之前需要进行格式转换 SwsContext *sws_ctx = sws_getContext(pCodecCtx-&gt;width, pCodecCtx-&gt;height, pCodecCtx-&gt;pix_fmt, pCodecCtx-&gt;width, pCodecCtx-&gt;height, AV_PIX_FMT_RGBA, SWS_BILINEAR, NULL, NULL, NULL); AVPacket *packet = av_packet_alloc(); int count = 0; while (av_read_frame(pFormatCtx, packet) == 0) &#123; // Is this a packet from the video stream? if (packet-&gt;stream_index == videoStream) &#123; // Decode video frame if (avcodec_send_packet(pCodecCtx, packet) != 0) &#123; break; &#125; AVFrame *pFrame = av_frame_alloc(); while (avcodec_receive_frame(pCodecCtx, pFrame) == 0) &#123; // lock native window buffer ANativeWindow_lock(nativeWindow, &amp;windowBuffer, 0); //for AVfilter start pFrame-&gt;pts = av_frame_get_best_effort_timestamp(pFrame); //* push the decoded frame into the filtergraph if (av_buffersrc_add_frame(buffersrc_ctx, pFrame) == 0) &#123; av_buffersink_get_frame(buffersink_ctx, pFrame); &#125; else&#123; LOGD("Could not av_buffersrc_add_frame"); &#125; // 格式转换 sws_scale(sws_ctx, (uint8_t const *const *) pFrame-&gt;data, pFrame-&gt;linesize, 0, pCodecCtx-&gt;height, pFrameRGBA-&gt;data, pFrameRGBA-&gt;linesize); // 获取stride uint8_t *dst = (uint8_t *) windowBuffer.bits; int dstStride = windowBuffer.stride * 4; uint8_t *src = (pFrameRGBA-&gt;data[0]); int srcStride = pFrameRGBA-&gt;linesize[0]; // 由于window的stride和帧的stride不同,因此需要逐行复制 int h; for (h = 0; h &lt; videoHeight; h++) &#123; memcpy(dst + h * dstStride, src + h * srcStride, srcStride); &#125; ANativeWindow_unlockAndPost(nativeWindow); count++; LOGD("解码渲染%d帧", count); &#125; av_frame_free(&amp;pFrame); av_free(pFrame); &#125; &#125; ANativeWindow_release(nativeWindow); av_packet_free(&amp;packet); sws_freeContext(sws_ctx); avfilter_inout_free(&amp;outputs); av_free(outputs); avfilter_inout_free(&amp;inputs); av_free(inputs); av_free(buffer); av_frame_free(&amp;pFrameRGBA); av_free(pFrameRGBA); avfilter_graph_free(&amp;filter_graph); //for avfilter // Close the codecs avcodec_close(pCodecCtx); avcodec_free_context(&amp;pCodecCtx); pCodecCtx = NULL; // Close the video file avformat_close_input(&amp;pFormatCtx); avformat_free_context(pFormatCtx); pFormatCtx = NULL; env-&gt;ReleaseStringUTFChars(url_, url);&#125; 更多的特效使用： http://www.ffmpeg.org/ffmpeg-filters.html]]></content>
      <categories>
        <category>ffmpeg</category>
      </categories>
      <tags>
        <tag>音视频</tag>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android OpenGLES渲染MediaCodec解码数据]]></title>
    <url>%2FAndroid%20OpenGLES%E6%B8%B2%E6%9F%93MediaCodec%E8%A7%A3%E7%A0%81%E6%95%B0%E6%8D%AE.html</url>
    <content type="text"><![CDATA[1、OpenGL生成纹理2、纹理绑定到SurfaceTexture上3、用SurfaceTexture做参数创建Surface4、MediaCodec解码的视频就往Surface发送，就显示出画面了 Shader编写 vertex_shader.glsl12345678attribute vec4 av_Position;attribute vec2 af_Position;varying vec2 v_texPosition;void main() &#123; v_texPosition = af_Position; gl_Position = av_Position;&#125; fragment_mediacodec.glsl 123456789#extension GL_OES_EGL_image_external : requireprecision mediump float;varying vec2 v_texPosition;//samplerExternalOES渲染视频uniform samplerExternalOES sTexture;void main() &#123; gl_FragColor=texture2D(sTexture, v_texPosition);&#125; VideoRender.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151import android.content.Context;import android.graphics.SurfaceTexture;import android.opengl.GLES11Ext;import android.opengl.GLES20;import android.opengl.GLSurfaceView;import android.view.Surface;import java.nio.ByteBuffer;import java.nio.ByteOrder;import java.nio.FloatBuffer;import javax.microedition.khronos.egl.EGLConfig;import javax.microedition.khronos.opengles.GL10;public class VideoRender implements GLSurfaceView.Renderer, SurfaceTexture.OnFrameAvailableListener &#123; private Context context; private final float[] vertexData = &#123; -1f, -1f, 1f, -1f, -1f, 1f, 1f, 1f &#125;; private final float[] textureData = &#123; 0f, 1f, 1f, 1f, 0f, 0f, 1f, 0f &#125;; private FloatBuffer vertexBuffer; private FloatBuffer textureBuffer; //mediacodec private int program_mediacodec; private int avPosition_mediacodec; private int afPosition_mediacodec; private int samplerOES_mediacodec; private int textureId_mediacodec; private SurfaceTexture surfaceTexture; private Surface surface; private OnSurfaceCreateListener onSurfaceCreateListener; private OnRenderListener onRenderListener; public VideoRender(Context context) &#123; this.context = context; vertexBuffer = ByteBuffer.allocateDirect(vertexData.length * 4) .order(ByteOrder.nativeOrder()) .asFloatBuffer() .put(vertexData); vertexBuffer.position(0); textureBuffer = ByteBuffer.allocateDirect(textureData.length * 4) .order(ByteOrder.nativeOrder()) .asFloatBuffer() .put(textureData); textureBuffer.position(0); &#125; public void setOnSurfaceCreateListener(OnSurfaceCreateListener onSurfaceCreateListener) &#123; this.onSurfaceCreateListener = onSurfaceCreateListener; &#125; public void setOnRenderListener(OnRenderListener onRenderListener) &#123; this.onRenderListener = onRenderListener; &#125; @Override public void onSurfaceCreated(GL10 gl, EGLConfig config) &#123; initRenderMediacodec(); &#125; @Override public void onSurfaceChanged(GL10 gl, int width, int height) &#123; GLES20.glViewport(0, 0, width, height); &#125; @Override public void onDrawFrame(GL10 gl) &#123; GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT); GLES20.glClearColor(0.0f, 0.0f, 0.0f, 1.0f); renderMediacodec(); GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, 4); &#125; @Override public void onFrameAvailable(SurfaceTexture surfaceTexture) &#123; if (onRenderListener != null) &#123; ////将onFrameAvailable函数回掉到GLSurfaceView调用requestRender()触发onDrawFrame() onRenderListener.onRender(); &#125; &#125; private void initRenderMediacodec() &#123; String vertexSource = ShaderUtil.readRawTxt(context, R.raw.vertex_shader); String fragmentSource = ShaderUtil.readRawTxt(context, R.raw.fragment_mediacodec); program_mediacodec = ShaderUtil.createProgram(vertexSource, fragmentSource); avPosition_mediacodec = GLES20.glGetAttribLocation(program_mediacodec, "av_Position"); afPosition_mediacodec = GLES20.glGetAttribLocation(program_mediacodec, "af_Position"); samplerOES_mediacodec = GLES20.glGetUniformLocation(program_mediacodec, "sTexture"); int[] textureids = new int[1]; GLES20.glGenTextures(1, textureids, 0); textureId_mediacodec = textureids[0]; GLES20.glTexParameteri(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_REPEAT); GLES20.glTexParameteri(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_REPEAT); GLES20.glTexParameteri(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR); GLES20.glTexParameteri(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR); surfaceTexture = new SurfaceTexture(textureId_mediacodec); surface = new Surface(surfaceTexture); surfaceTexture.setOnFrameAvailableListener(this); if (onSurfaceCreateListener != null) &#123; //将Surface回掉出去给MediaCodec绑定渲染 onSurfaceCreateListener.onSurfaceCreate(surface); &#125; &#125; private void renderMediacodec() &#123; surfaceTexture.updateTexImage(); GLES20.glUseProgram(program_mediacodec); GLES20.glEnableVertexAttribArray(avPosition_mediacodec); GLES20.glVertexAttribPointer(avPosition_mediacodec, 2, GLES20.GL_FLOAT, false, 8, vertexBuffer); GLES20.glEnableVertexAttribArray(afPosition_mediacodec); GLES20.glVertexAttribPointer(afPosition_mediacodec, 2, GLES20.GL_FLOAT, false, 8, textureBuffer); GLES20.glActiveTexture(GLES20.GL_TEXTURE0); GLES20.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, textureId_mediacodec); GLES20.glUniform1i(samplerOES_mediacodec, 0); &#125; public interface OnSurfaceCreateListener &#123; void onSurfaceCreate(Surface surface); &#125; public interface OnRenderListener &#123; void onRender(); &#125;&#125; VideoGLSurfaceView.java12345678910111213141516171819202122232425262728293031import android.content.Context;import android.opengl.GLSurfaceView;import android.util.AttributeSet;public class VideoGLSurfaceView extends GLSurfaceView &#123; private VideoRender render; public VideoGLSurfaceView(Context context) &#123; this(context, null); &#125; public VideoGLSurfaceView(Context context, AttributeSet attrs) &#123; super(context, attrs); setEGLContextClientVersion(2); render = new VideoRender(context); setRenderer(render); setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY); render.setOnRenderListener(new VideoRender.OnRenderListener() &#123; @Override public void onRender() &#123; requestRender(); &#125; &#125;); &#125; public VideoRender getWlRender() &#123; return render; &#125;&#125;]]></content>
      <categories>
        <category>OpenGLES</category>
      </categories>
      <tags>
        <tag>OpenGLES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android OpenGLES绘制yuv420纹理]]></title>
    <url>%2FAndroid%20OpenGLES%E7%BB%98%E5%88%B6yuv420%E7%BA%B9%E7%90%86.html</url>
    <content type="text"><![CDATA[把shader代码写入raw里面 vertex_shader.glsl1234567attribute vec4 av_Position;//顶点位置attribute vec2 af_Position;//纹理位置varying vec2 v_texPo;//纹理位置 与fragment_shader交互void main() &#123; v_texPo = af_Position; gl_Position = av_Position;&#125; fragment_shader.glsl 12345678910111213141516171819precision mediump float;//精度 为floatvarying vec2 v_texPo;//纹理位置 接收于vertex_shaderuniform sampler2D sampler_y;//纹理yuniform sampler2D sampler_u;//纹理uuniform sampler2D sampler_v;//纹理vvoid main() &#123; //yuv420-&gt;rgb float y,u,v; y = texture2D(sampler_y,v_texPo).r; u = texture2D(sampler_u,v_texPo).r- 0.5; v = texture2D(sampler_v,v_texPo).r- 0.5; vec3 rgb; rgb.r = y + 1.403 * v; rgb.g = y - 0.344 * u - 0.714 * v; rgb.b = y + 1.770 * u; gl_FragColor=vec4(rgb,1);&#125; 因为OpenGLES需要用rgb来加载显示，这里就需要将yuv转rgb，这里放在OpenGL里面转换，OpenGL里面使用GPU,提高性能。 数据写入 YUV420Texture.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174import android.content.Context;import android.opengl.GLES20;import java.nio.ByteBuffer;import java.nio.ByteOrder;import java.nio.FloatBuffer;public class YUV420Texture &#123; private Context context; //顶点坐标 static float vertexData[] = &#123; // in counterclockwise order: -1f, -1f, 0.0f, // bottom left 1f, -1f, 0.0f, // bottom right -1f, 1f, 0.0f, // top left 1f, 1f, 0.0f, // top right &#125;; //纹理坐标 static float textureData[] = &#123; // in counterclockwise order: 0f, 1f, 0.0f, // bottom left 1f, 1f, 0.0f, // bottom right 0f, 0f, 0.0f, // top left 1f, 0f, 0.0f, // top right &#125;; //每一次取点的时候取几个点 static final int COORDS_PER_VERTEX = 3; private final int vertexCount = vertexData.length / COORDS_PER_VERTEX; //每一次取的总的点 大小 private final int vertexStride = COORDS_PER_VERTEX * 4; // 4 bytes per vertex //位置 private FloatBuffer vertexBuffer; //纹理 private FloatBuffer textureBuffer; private int program; //顶点位置 private int avPosition; //纹理位置 private int afPosition; //shader yuv变量 private int sampler_y; private int sampler_u; private int sampler_v; private int[] textureId_yuv; //YUV数据 private int width_yuv; private int height_yuv; private ByteBuffer y; private ByteBuffer u; private ByteBuffer v; public YUV420Texture(Context context) &#123; this.context = context; vertexBuffer = ByteBuffer.allocateDirect(vertexData.length * 4) .order(ByteOrder.nativeOrder()) .asFloatBuffer() .put(vertexData); vertexBuffer.position(0); textureBuffer = ByteBuffer.allocateDirect(textureData.length * 4) .order(ByteOrder.nativeOrder()) .asFloatBuffer() .put(textureData); textureBuffer.position(0); &#125; public void initYUV() &#123; String vertexSource = ShaderUtil.readRawTxt(context, R.raw.vertex_shader); String fragmentSource = ShaderUtil.readRawTxt(context, R.raw.fragment_shader); program = ShaderUtil.createProgram(vertexSource, fragmentSource); if (program &gt; 0) &#123; //获取顶点坐标字段 avPosition = GLES20.glGetAttribLocation(program, "av_Position"); //获取纹理坐标字段 afPosition = GLES20.glGetAttribLocation(program, "af_Position"); //获取yuv字段 sampler_y = GLES20.glGetUniformLocation(program, "sampler_y"); sampler_u = GLES20.glGetUniformLocation(program, "sampler_u"); sampler_v = GLES20.glGetUniformLocation(program, "sampler_v"); textureId_yuv = new int[3]; //创建3个纹理 GLES20.glGenTextures(3, textureId_yuv, 0); //绑定纹理 for (int id : textureId_yuv) &#123; GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, id); //环绕（超出纹理坐标范围） （s==x t==y GL_REPEAT 重复） GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_REPEAT); GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_REPEAT); //过滤（纹理像素映射到坐标点） （缩小、放大：GL_LINEAR线性） GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR); GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR); &#125; &#125; &#125; public void setYUVData(int width, int height, byte[] y, byte[] u, byte[] v) &#123; this.width_yuv = width; this.height_yuv = height; this.y = ByteBuffer.wrap(y); this.u = ByteBuffer.wrap(u); this.v = ByteBuffer.wrap(v); &#125; public void draw() &#123; if (width_yuv &gt; 0 &amp;&amp; height_yuv &gt; 0 &amp;&amp; y != null &amp;&amp; u != null &amp;&amp; v != null) &#123; GLES20.glUseProgram(program); GLES20.glEnableVertexAttribArray(avPosition); GLES20.glVertexAttribPointer(avPosition, COORDS_PER_VERTEX, GLES20.GL_FLOAT, false, vertexStride, vertexBuffer); GLES20.glEnableVertexAttribArray(afPosition); GLES20.glVertexAttribPointer(afPosition, COORDS_PER_VERTEX, GLES20.GL_FLOAT, false, vertexStride, textureBuffer); //激活纹理0来绑定y数据 GLES20.glActiveTexture(GLES20.GL_TEXTURE0); GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureId_yuv[0]); //glTexImage2D (int target, // int level, // int internalformat, // int width, // int height, // int border, // int format, // int type, // Buffer pixels) GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, 0, GLES20.GL_LUMINANCE, width_yuv, height_yuv, 0, GLES20.GL_LUMINANCE, GLES20.GL_UNSIGNED_BYTE, y); //激活纹理1来绑定u数据 GLES20.glActiveTexture(GLES20.GL_TEXTURE1); GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureId_yuv[1]); GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, 0, GLES20.GL_LUMINANCE, width_yuv / 2, height_yuv / 2, 0, GLES20.GL_LUMINANCE, GLES20.GL_UNSIGNED_BYTE, u); //激活纹理2来绑定u数据 GLES20.glActiveTexture(GLES20.GL_TEXTURE2); GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureId_yuv[2]); GLES20.glTexImage2D(GLES20.GL_TEXTURE_2D, 0, GLES20.GL_LUMINANCE, width_yuv / 2, height_yuv / 2, 0, GLES20.GL_LUMINANCE, GLES20.GL_UNSIGNED_BYTE, v); //给fragment_shader里面yuv变量设置值 0 1 2 标识纹理x GLES20.glUniform1i(sampler_y, 0); GLES20.glUniform1i(sampler_u, 1); GLES20.glUniform1i(sampler_v, 2); //绘制 GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, vertexCount); y.clear(); u.clear(); v.clear(); y = null; u = null; v = null; GLES20.glDisableVertexAttribArray(afPosition); GLES20.glDisableVertexAttribArray(avPosition); &#125; &#125;&#125; ShaderUtil.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import android.content.Context;import android.opengl.GLES20;import android.util.Log;import java.io.BufferedReader;import java.io.InputStream;import java.io.InputStreamReader;public class ShaderUtil &#123; private static final String TAG = "ShaderUtil"; public static String readRawTxt(Context context, int rawId) &#123; InputStream inputStream = context.getResources().openRawResource(rawId); BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)); StringBuffer sb = new StringBuffer(); String line; try &#123; while ((line = reader.readLine()) != null) &#123; sb.append(line).append("\n"); &#125; reader.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return sb.toString(); &#125; public static int loadShader(int shaderType, String source) &#123; // create a vertex shader type (GLES20.GL_VERTEX_SHADER) // or a fragment shader type (GLES20.GL_FRAGMENT_SHADER) int shader = GLES20.glCreateShader(shaderType); if (shader != 0) &#123; //添加代码到shader GLES20.glShaderSource(shader, source); //编译shader GLES20.glCompileShader(shader); int[] compile = new int[1]; //检测是否编译成功 GLES20.glGetShaderiv(shader, GLES20.GL_COMPILE_STATUS, compile, 0); if (compile[0] != GLES20.GL_TRUE) &#123; Log.d(TAG, "shader compile error"); GLES20.glDeleteShader(shader); shader = 0; &#125; &#125; return shader; &#125; public static int createProgram(String vertexSource, String fragmentSource) &#123; //获取vertex shader int vertexShader = loadShader(GLES20.GL_VERTEX_SHADER, vertexSource); if (vertexShader == 0) &#123; return 0; &#125; //获取fragment shader int fragmentShader = loadShader(GLES20.GL_FRAGMENT_SHADER, fragmentSource); if (fragmentShader == 0) &#123; return 0; &#125; //创建一个空的渲染程序 int program = GLES20.glCreateProgram(); if (program != 0) &#123; //添加vertexShader到渲染程序 GLES20.glAttachShader(program, vertexShader); //添加fragmentShader到渲染程序 GLES20.glAttachShader(program, fragmentShader); //关联为可执行渲染程序 GLES20.glLinkProgram(program); int[] linsStatus = new int[1]; //检测是否关联成功 GLES20.glGetProgramiv(program, GLES20.GL_LINK_STATUS, linsStatus, 0); if (linsStatus[0] != GLES20.GL_TRUE) &#123; Log.d(TAG, "link program error"); GLES20.glDeleteProgram(program); program = 0; &#125; &#125; return program; &#125;&#125; Render书写MyRender.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import android.content.Context;import android.opengl.GLES20;import android.opengl.GLSurfaceView;import javax.microedition.khronos.egl.EGLConfig;import javax.microedition.khronos.opengles.GL10;public class MyRender implements GLSurfaceView.Renderer &#123; private Context context; private YUV420Texture yuv420Texture; public MyRender(Context context) &#123; this.context = context; &#125; @Override public void onSurfaceCreated(GL10 gl, EGLConfig config) &#123; yuv420Texture = new YUV420Texture(context); yuv420Texture.initYUV(); &#125; @Override public void onSurfaceChanged(GL10 gl, int width, int height) &#123; //宽高 GLES20.glViewport(0, 0, width, height); &#125; @Override public void onDrawFrame(GL10 gl) &#123; //清空颜色 GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT); //设置背景颜色// GLES20.glClearColor(1.0f, 1.0f, 1.0f, 1.0f); yuv420Texture.draw(); &#125; public void setYuvData(int width, int height, byte[] y, byte[] u, byte[] v) &#123; if (yuv420Texture != null) &#123; yuv420Texture.setYUVData(width, height, y, u, v); &#125; &#125;&#125; GLSurfaceView引用Renderer MyGLSurfaceView.java123456789101112131415161718192021222324252627282930import android.content.Context;import android.opengl.GLSurfaceView;import android.util.AttributeSet;public class MyGLSurfaceView extends GLSurfaceView &#123; private MyRender myRender; public MyGLSurfaceView(Context context) &#123; this(context, null); &#125; public MyGLSurfaceView(Context context, AttributeSet attrs) &#123; super(context, attrs); setEGLContextClientVersion(2); myRender = new MyRender(context); setRenderer(myRender); //mode=GLSurfaceView.RENDERMODE_WHEN_DIRTY之后 调用requestRender()触发Render的onDrawFrame函数 //mode=GLSurfaceView.RENDERMODE_CONTINUOUSLY之后 自动调用onDrawFrame 60fps左右 setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY); &#125; public void setYUVData(int width, int height, byte[] y, byte[] u, byte[] v) &#123; if (myRender != null) &#123; myRender.setYuvData(width, height, y, u, v); requestRender(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>OpenGLES</category>
      </categories>
      <tags>
        <tag>OpenGLES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android OpenGLES 绘制图片纹理]]></title>
    <url>%2FAndroid%20OpenGLES%20%E7%BB%98%E5%88%B6%E5%9B%BE%E7%89%87%E7%BA%B9%E7%90%86.html</url>
    <content type="text"><![CDATA[把shader代码写入raw里面 vertex_shader.glsl 1234567attribute vec4 av_Position;//顶点位置attribute vec2 af_Position;//纹理位置varying vec2 v_texPo;//纹理位置 与fragment_shader交互void main() &#123; v_texPo = af_Position; gl_Position = av_Position;&#125; fragment_shader.glsl 1234567precision mediump float;//精度 为floatvarying vec2 v_texPo;//纹理位置 接收于vertex_shaderuniform sampler2D sTexture;//纹理void main() &#123; gl_FragColor=texture2D(sTexture, v_texPo);&#125; 写入数据,注意纹理映射 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122import android.content.Context;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.opengl.GLES20;import android.opengl.GLUtils;import java.nio.ByteBuffer;import java.nio.ByteOrder;import java.nio.FloatBuffer;//纹理 根据坐标系映射public class BitmapTexture &#123; //顶点坐标 static float vertexData[] = &#123; // in counterclockwise order: -1f, -1f, 0.0f, // bottom left 1f, -1f, 0.0f, // bottom right -1f, 1f, 0.0f, // top left 1f, 1f, 0.0f, // top right &#125;; //纹理坐标 对应顶点坐标 与之映射 static float textureData[] = &#123; // in counterclockwise order: 0f, 1f, 0.0f, // bottom left 1f, 1f, 0.0f, // bottom right 0f, 0f, 0.0f, // top left 1f, 0f, 0.0f, // top right &#125;; //每一次取点的时候取几个点 static final int COORDS_PER_VERTEX = 3; private final int vertexCount = vertexData.length / COORDS_PER_VERTEX; //每一次取的总的点 大小 private final int vertexStride = COORDS_PER_VERTEX * 4; // 4 bytes per vertex private Context context; //位置 private FloatBuffer vertexBuffer; //纹理 private FloatBuffer textureBuffer; private int program; private int avPosition; //纹理位置 private int afPosition; //纹理id private int textureId; public BitmapTexture(Context context) &#123; this.context = context; vertexBuffer = ByteBuffer.allocateDirect(vertexData.length * 4) .order(ByteOrder.nativeOrder()) .asFloatBuffer() .put(vertexData); vertexBuffer.position(0); textureBuffer = ByteBuffer.allocateDirect(textureData.length * 4) .order(ByteOrder.nativeOrder()) .asFloatBuffer() .put(textureData); textureBuffer.position(0); &#125; public void onSurfaceCreated() &#123; String vertexSource = ShaderUtil.readRawTxt(context, R.raw.vertex_shader); String fragmentSource = ShaderUtil.readRawTxt(context, R.raw.fragment_shader); program = ShaderUtil.createProgram(vertexSource, fragmentSource); if (program &gt; 0) &#123; //获取顶点坐标字段 avPosition = GLES20.glGetAttribLocation(program, "av_Position"); //获取纹理坐标字段 afPosition = GLES20.glGetAttribLocation(program, "af_Position"); int[] textureIds = new int[1]; //创建纹理 GLES20.glGenTextures(1, textureIds, 0); if (textureIds[0] == 0) &#123; return; &#125; textureId = textureIds[0]; //绑定纹理 GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textureId); //环绕（超出纹理坐标范围） （s==x t==y GL_REPEAT 重复） GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_S, GLES20.GL_REPEAT); GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_WRAP_T, GLES20.GL_REPEAT); //过滤（纹理像素映射到坐标点） （缩小、放大：GL_LINEAR线性） GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR); GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR); Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), R.mipmap.bg); if (bitmap == null) &#123; return; &#125; //设置纹理为2d图片 GLUtils.texImage2D(GLES20.GL_TEXTURE_2D, 0, bitmap, 0); &#125; &#125; public void draw() &#123; //使用程序 GLES20.glUseProgram(program); GLES20.glEnableVertexAttribArray(avPosition); GLES20.glEnableVertexAttribArray(afPosition); //设置顶点位置值 GLES20.glVertexAttribPointer(avPosition, COORDS_PER_VERTEX, GLES20.GL_FLOAT, false, vertexStride, vertexBuffer); //设置纹理位置值 GLES20.glVertexAttribPointer(afPosition, COORDS_PER_VERTEX, GLES20.GL_FLOAT, false, vertexStride, textureBuffer); //绘制 GLES20.GL_TRIANGLE_STRIP:复用坐标 GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP, 0, vertexCount); GLES20.glDisableVertexAttribArray(avPosition); GLES20.glDisableVertexAttribArray(afPosition); &#125;&#125; ShaderUtil.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import android.content.Context;import android.opengl.GLES20;import android.util.Log;import java.io.BufferedReader;import java.io.InputStream;import java.io.InputStreamReader;public class ShaderUtil &#123; private static final String TAG = "ShaderUtil"; public static String readRawTxt(Context context, int rawId) &#123; InputStream inputStream = context.getResources().openRawResource(rawId); BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)); StringBuffer sb = new StringBuffer(); String line; try &#123; while ((line = reader.readLine()) != null) &#123; sb.append(line).append("\n"); &#125; reader.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return sb.toString(); &#125; public static int loadShader(int shaderType, String source) &#123; // create a vertex shader type (GLES20.GL_VERTEX_SHADER) // or a fragment shader type (GLES20.GL_FRAGMENT_SHADER) int shader = GLES20.glCreateShader(shaderType); if (shader != 0) &#123; //添加代码到shader GLES20.glShaderSource(shader, source); //编译shader GLES20.glCompileShader(shader); int[] compile = new int[1]; //检测是否编译成功 GLES20.glGetShaderiv(shader, GLES20.GL_COMPILE_STATUS, compile, 0); if (compile[0] != GLES20.GL_TRUE) &#123; Log.d(TAG, "shader compile error"); GLES20.glDeleteShader(shader); shader = 0; &#125; &#125; return shader; &#125; public static int createProgram(String vertexSource, String fragmentSource) &#123; //获取vertex shader int vertexShader = loadShader(GLES20.GL_VERTEX_SHADER, vertexSource); if (vertexShader == 0) &#123; return 0; &#125; //获取fragment shader int fragmentShader = loadShader(GLES20.GL_FRAGMENT_SHADER, fragmentSource); if (fragmentShader == 0) &#123; return 0; &#125; //创建一个空的渲染程序 int program = GLES20.glCreateProgram(); if (program != 0) &#123; //添加vertexShader到渲染程序 GLES20.glAttachShader(program, vertexShader); //添加fragmentShader到渲染程序 GLES20.glAttachShader(program, fragmentShader); //关联为可执行渲染程序 GLES20.glLinkProgram(program); int[] linsStatus = new int[1]; //检测是否关联成功 GLES20.glGetProgramiv(program, GLES20.GL_LINK_STATUS, linsStatus, 0); if (linsStatus[0] != GLES20.GL_TRUE) &#123; Log.d(TAG, "link program error"); GLES20.glDeleteProgram(program); program = 0; &#125; &#125; return program; &#125;&#125; Render书写MyRender.java 12345678910111213141516171819202122232425262728293031323334353637383940import android.content.Context;import android.opengl.GLES20;import android.opengl.GLSurfaceView;import javax.microedition.khronos.egl.EGLConfig;import javax.microedition.khronos.opengles.GL10;public class MyRender implements GLSurfaceView.Renderer &#123; private Context context; private BitmapTexture bitmapTexture; public MyRender(Context context) &#123; this.context = context; &#125; @Override public void onSurfaceCreated(GL10 gl, EGLConfig config) &#123; bitmapTexture = new BitmapTexture(context); bitmapTexture.onSurfaceCreated(); &#125; @Override public void onSurfaceChanged(GL10 gl, int width, int height) &#123; //宽高 GLES20.glViewport(0, 0, width, height); &#125; @Override public void onDrawFrame(GL10 gl) &#123; //清空颜色 GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT); //设置背景颜色// GLES20.glClearColor(1.0f, 1.0f, 1.0f, 1.0f); bitmapTexture.draw(); &#125;&#125; GLSurfaceView引用Renderer MyGLSurfaceView.java12345678910111213141516import android.content.Context;import android.opengl.GLSurfaceView;import android.util.AttributeSet;public class MyGLSurfaceView extends GLSurfaceView&#123; public MyGLSurfaceView(Context context) &#123; this(context, null); &#125; public MyGLSurfaceView(Context context, AttributeSet attrs) &#123; super(context, attrs); setEGLContextClientVersion(2); setRenderer(new MyRender(context)); &#125;&#125;]]></content>
      <categories>
        <category>OpenGLES</category>
      </categories>
      <tags>
        <tag>OpenGLES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android OpenGLES 绘制三角形 ，四边形]]></title>
    <url>%2FAndroid%20OpenGLES%20%E7%BB%98%E5%88%B6%E4%B8%89%E8%A7%92%E5%BD%A2%20%EF%BC%8C%E5%9B%9B%E8%BE%B9%E5%BD%A2.html</url>
    <content type="text"><![CDATA[验证是否支持OpenGLES2.0 1234//检查设备是否支持OpenGL ES 2.0final ActivityManager activityManager = (ActivityManager) getSystemService(ACTIVITY_SERVICE);final ConfigurationInfo configurationInfo = activityManager.getDeviceConfigurationInfo();final boolean supportES2 = configurationInfo.reqGlEsVersion &gt;= 0x00020000; 确保可用，在manifest里面添加验证1&lt;uses-feature android:glEsVersion="0x00020000" android:required="true" /&gt; 定义vertex_shader.glsl和fragment_shader.glsl到res/raw里面 vertex_shader.glsl1234attribute vec4 vPosition;void main()&#123; gl_Position = vPosition;&#125; fragment_shader.glsl12345precision mediump float;uniform vec4 vColor;void main()&#123; gl_FragColor = vColor;&#125; OpenGL ES Shader的三种变量类型uniform，attribute和varying 定义形状 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import android.content.Context;import android.opengl.GLES20;import java.nio.ByteBuffer;import java.nio.ByteOrder;import java.nio.FloatBuffer;public class Triangle &#123; //坐标本地内存地址 private FloatBuffer vertexBuffer; //每一次取点的时候取几个点 static final int COORDS_PER_VERTEX = 3; //绘制坐标 static float triangleCoords[] = &#123; // in counterclockwise order: 0.0f, 0.622008459f, 0.0f, // top -0.5f, -0.311004243f, 0.0f, // bottom left 0.5f, -0.311004243f, 0.0f // bottom right &#125;; // Set color with red, green, blue and alpha (opacity) values float color[] = &#123;0.63671875f, 0.76953125f, 0.22265625f, 1.0f&#125;; private final int mProgram; private int mPositionHandle; private int mColorHandle; private final int vertexCount = triangleCoords.length / COORDS_PER_VERTEX; //每一次取的总的点 大小 private final int vertexStride = COORDS_PER_VERTEX * 4; // 4 bytes per vertex public Triangle(Context context) &#123; //为坐标分配本地内存地址 vertexBuffer = ByteBuffer .allocateDirect(triangleCoords.length * 4) .order(ByteOrder.nativeOrder()) .asFloatBuffer() .put(triangleCoords); vertexBuffer.position(0); //根据shader代码和fragment代码 获取到一个渲染程序 mProgram = ShaderUtil.createProgram(ShaderUtil.readRawTxt(context, R.raw.vertex_shader), ShaderUtil.readRawTxt(context, R.raw.fragment_shader)); if (mProgram &gt; 0) &#123; //获取vertex shader的属性vPosition 的地址 mPositionHandle = GLES20.glGetAttribLocation(mProgram, "vPosition"); //获取fragment shader的属性vColor 的地址 mColorHandle = GLES20.glGetUniformLocation(mProgram, "vColor"); &#125; &#125; public void draw() &#123; //使用渲染程序 GLES20.glUseProgram(mProgram); // 使顶点属性数组有效 GLES20.glEnableVertexAttribArray(mPositionHandle); // 为顶点属性赋值 GLES20.glVertexAttribPointer(mPositionHandle, COORDS_PER_VERTEX, GLES20.GL_FLOAT, false, vertexStride, vertexBuffer); // 设置颜色 GLES20.glUniform4fv(mColorHandle, 1, color, 0); // 绘制图形 GLES20.glDrawArrays(GLES20.GL_TRIANGLES, 0, vertexCount); // 禁用顶点数组 GLES20.glDisableVertexAttribArray(mPositionHandle); &#125;&#125; ShaderUtil.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import android.content.Context;import android.opengl.GLES20;import android.util.Log;import java.io.BufferedReader;import java.io.InputStream;import java.io.InputStreamReader;public class ShaderUtil &#123; private static final String TAG = "ShaderUtil"; public static String readRawTxt(Context context, int rawId) &#123; InputStream inputStream = context.getResources().openRawResource(rawId); BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)); StringBuffer sb = new StringBuffer(); String line; try &#123; while ((line = reader.readLine()) != null) &#123; sb.append(line).append("\n"); &#125; reader.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return sb.toString(); &#125; public static int loadShader(int shaderType, String source) &#123; // create a vertex shader type (GLES20.GL_VERTEX_SHADER) // or a fragment shader type (GLES20.GL_FRAGMENT_SHADER) int shader = GLES20.glCreateShader(shaderType); if (shader != 0) &#123; //添加代码到shader GLES20.glShaderSource(shader, source); //编译shader GLES20.glCompileShader(shader); int[] compile = new int[1]; //检测是否编译成功 GLES20.glGetShaderiv(shader, GLES20.GL_COMPILE_STATUS, compile, 0); if (compile[0] != GLES20.GL_TRUE) &#123; Log.d(TAG, "shader compile error"); GLES20.glDeleteShader(shader); shader = 0; &#125; &#125; return shader; &#125; public static int createProgram(String vertexSource, String fragmentSource) &#123; //获取vertex shader int vertexShader = loadShader(GLES20.GL_VERTEX_SHADER, vertexSource); if (vertexShader == 0) &#123; return 0; &#125; //获取fragment shader int fragmentShader = loadShader(GLES20.GL_FRAGMENT_SHADER, fragmentSource); if (fragmentShader == 0) &#123; return 0; &#125; //创建一个空的渲染程序 int program = GLES20.glCreateProgram(); if (program != 0) &#123; //添加vertexShader到渲染程序 GLES20.glAttachShader(program, vertexShader); //添加fragmentShader到渲染程序 GLES20.glAttachShader(program, fragmentShader); //关联为可执行渲染程序 GLES20.glLinkProgram(program); int[] linsStatus = new int[1]; //检测是否关联成功 GLES20.glGetProgramiv(program, GLES20.GL_LINK_STATUS, linsStatus, 0); if (linsStatus[0] != GLES20.GL_TRUE) &#123; Log.d(TAG, "link program error"); GLES20.glDeleteProgram(program); program = 0; &#125; &#125; return program; &#125;&#125; 定义shader 123456789101112131415161718192021222324252627282930313233343536373839import android.content.Context;import android.opengl.GLES20;import android.opengl.GLSurfaceView;import javax.microedition.khronos.egl.EGLConfig;import javax.microedition.khronos.opengles.GL10;public class MyRender implements GLSurfaceView.Renderer &#123; private Context context; private Triangle triangle; public MyRender(Context context) &#123; this.context = context; &#125; @Override public void onSurfaceCreated(GL10 gl, EGLConfig config) &#123; triangle = new Triangle(context); &#125; @Override public void onSurfaceChanged(GL10 gl, int width, int height) &#123; //宽高 GLES20.glViewport(0, 0, width, height); &#125; @Override public void onDrawFrame(GL10 gl) &#123; //清空颜色 GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT); //设置背景颜色// GLES20.glClearColor(1.0f, 1.0f, 1.0f, 1.0f); triangle.draw(); &#125;&#125; 设置shader到GLSurfaceView 12345678910111213141516import android.content.Context;import android.opengl.GLSurfaceView;import android.util.AttributeSet;public class MyGLSurfaceView extends GLSurfaceView&#123; public MyGLSurfaceView(Context context) &#123; this(context, null); &#125; public MyGLSurfaceView(Context context, AttributeSet attrs) &#123; super(context, attrs); setEGLContextClientVersion(2); setRenderer(new MyRender(context)); &#125;&#125; 上述三角形已经绘制成功。 绘制四边形绘制四边形的方式是由两个三角形形成一个四边形，所以顶点位置一定要注意。调用GLES20.glDrawArrays的时候设置flog可以设置为GLES20.GL_TRIANGLE_STRIP和GLES20.GL_TRIANGLES,前者复用坐标，后者分别取几个坐标。]]></content>
      <categories>
        <category>OpenGLES</category>
      </categories>
      <tags>
        <tag>OpenGLES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MediaCodec硬编码pcm2aac]]></title>
    <url>%2FMediaCodec%E7%A1%AC%E7%BC%96%E7%A0%81pcm2aac.html</url>
    <content type="text"><![CDATA[MediaCodec是Android（api&gt;=16）提供的一个多媒体硬解编码库，能实现音视频的编解码。 工作原理：其内部有2个队列，一个是输入队列，一个是输出队列。输入队列负责存储编解码前的原始数据存储，并输送给MediaCodec处理；输出队列负责存储编解码后的新数据，可以直接处理或保存到文件中。 AAC 的头部信息介绍 ：https://blog.csdn.net/jay100500/article/details/52955232 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184//mediacodec private MediaFormat encoderFormat = null; private MediaCodec encoder = null; private FileOutputStream outputStream = null; private MediaCodec.BufferInfo info = null; private int perpcmsize = 0; private byte[] outByteBuffer = null; private int aacsamplerate = 4; private double recordTime = 0; private int audioSamplerate = 0; private void initMediacodec(int samperate, File outfile) &#123; try &#123; aacsamplerate = getADTSsamplerate(samperate); //立体声 encoderFormat = MediaFormat.createAudioFormat(MediaFormat.MIMETYPE_AUDIO_AAC, samperate, 2); //96kbps fm音质 encoderFormat.setInteger(MediaFormat.KEY_BIT_RATE, 96000); encoderFormat.setInteger(MediaFormat.KEY_AAC_PROFILE, MediaCodecInfo.CodecProfileLevel.AACObjectLC); encoderFormat.setInteger(MediaFormat.KEY_MAX_INPUT_SIZE, 4096); encoder = MediaCodec.createEncoderByType(MediaFormat.MIMETYPE_AUDIO_AAC); info = new MediaCodec.BufferInfo(); if(encoder == null) &#123; MyLog.d("craete encoder wrong"); return; &#125; recordTime = 0; encoder.configure(encoderFormat, null, null, MediaCodec.CONFIGURE_FLAG_ENCODE); outputStream = new FileOutputStream(outfile); encoder.start(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; private void encodecPcmToAAc(int size, byte[] buffer) &#123; if(buffer != null &amp;&amp; encoder != null) &#123; //录音时间 size/ 采样率*声道数 * bits/8 recordTime += size * 1.0 / (audioSamplerate * 2 * (16 / 8)); MyLog.d("recordTime = " + recordTime); //回掉 if(wlOnRecordTimeListener != null) &#123; wlOnRecordTimeListener.onRecordTime((int) recordTime); &#125; int inputBufferindex = encoder.dequeueInputBuffer(0); if(inputBufferindex &gt;= 0) &#123; ByteBuffer byteBuffer = encoder.getInputBuffers()[inputBufferindex]; byteBuffer.clear(); byteBuffer.put(buffer); encoder.queueInputBuffer(inputBufferindex, 0, size, 0, 0); &#125; int index = encoder.dequeueOutputBuffer(info, 0); while(index &gt;= 0) &#123; try &#123; perpcmsize = info.size + 7; outByteBuffer = new byte[perpcmsize]; ByteBuffer byteBuffer = encoder.getOutputBuffers()[index]; byteBuffer.position(info.offset); byteBuffer.limit(info.offset + info.size); addADtsHeader(outByteBuffer, perpcmsize, aacsamplerate); byteBuffer.get(outByteBuffer, 7, info.size); byteBuffer.position(info.offset); outputStream.write(outByteBuffer, 0, perpcmsize); encoder.releaseOutputBuffer(index, false); index = encoder.dequeueOutputBuffer(info, 0); outByteBuffer = null; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; private void addADtsHeader(byte[] packet, int packetLen, int samplerate) &#123; int profile = 2; // AAC LC int freqIdx = samplerate; // samplerate int chanCfg = 2; // CPE packet[0] = (byte) 0xFF; // 0xFFF(12bit) 这里只取了8位，所以还差4位放到下一个里面 packet[1] = (byte) 0xF9; // 第一个t位放F packet[2] = (byte) (((profile - 1) &lt;&lt; 6) + (freqIdx &lt;&lt; 2) + (chanCfg &gt;&gt; 2)); packet[3] = (byte) (((chanCfg &amp; 3) &lt;&lt; 6) + (packetLen &gt;&gt; 11)); packet[4] = (byte) ((packetLen &amp; 0x7FF) &gt;&gt; 3); packet[5] = (byte) (((packetLen &amp; 7) &lt;&lt; 5) + 0x1F); packet[6] = (byte) 0xFC; &#125; private int getADTSsamplerate(int samplerate) &#123; int rate = 4; switch (samplerate) &#123; case 96000: rate = 0; break; case 88200: rate = 1; break; case 64000: rate = 2; break; case 48000: rate = 3; break; case 44100: rate = 4; break; case 32000: rate = 5; break; case 24000: rate = 6; break; case 22050: rate = 7; break; case 16000: rate = 8; break; case 12000: rate = 9; break; case 11025: rate = 10; break; case 8000: rate = 11; break; case 7350: rate = 12; break; &#125; return rate; &#125; private void releaseMedicacodec() &#123; if(encoder == null) &#123; return; &#125; try &#123; recordTime = 0; outputStream.close(); outputStream = null; encoder.stop(); encoder.release(); encoder = null; encoderFormat = null; info = null; initmediacodec = false; MyLog.d("录制完成..."); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(outputStream != null) &#123; try &#123; outputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; outputStream = null; &#125; &#125; &#125;]]></content>
      <categories>
        <category>MediaCodec</category>
      </categories>
      <tags>
        <tag>音视频</tag>
        <tag>MediaCodec</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mediacodec解码ffmpeg AvPacket]]></title>
    <url>%2FMediaCodec%E8%A7%A3%E7%A0%81FFmpeg%20AvPacket.html</url>
    <content type="text"><![CDATA[初始化MediaCodec1234567891011121314151617181920212223242526272829303132333435363738private MediaFormat mediaFormat;private MediaCodec mediaCodec;private MediaCodec.BufferInfo info;private Surface surface;//这个是OpenGL渲染的Surface/** * 初始化MediaCodec * * @param codecName * @param width * @param height * @param csd_0 * @param csd_1 */public void initMediaCodec(String codecName, int width, int height, byte[] csd_0, byte[] csd_1) &#123; try &#123; if (surface != null) &#123; String mime = VideoSupportUtil.findVideoCodecName(codecName); mediaFormat = MediaFormat.createVideoFormat(mime, width, height); mediaFormat.setInteger(MediaFormat.KEY_MAX_INPUT_SIZE, width * height); mediaFormat.setByteBuffer("csd-0", ByteBuffer.wrap(csd_0)); mediaFormat.setByteBuffer("csd-1", ByteBuffer.wrap(csd_1)); MyLog.d(mediaFormat.toString()); mediaCodec = MediaCodec.createDecoderByType(mime); info = new MediaCodec.BufferInfo(); if(mediaCodec == null) &#123; MyLog.d("craete mediaCodec wrong"); return; &#125; mediaCodec.configure(mediaFormat, surface, null, 0); mediaCodec.start(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; VideoSupportUtil.java 12345678910111213141516171819202122232425262728293031323334353637383940import android.media.MediaCodecList;import java.util.HashMap;import java.util.Map;public class VideoSupportUtil &#123; private static Map&lt;String, String&gt; codecMap = new HashMap&lt;&gt;(); static &#123; codecMap.put("h264", "video/avc"); &#125; public static String findVideoCodecName(String ffcodename)&#123; if(codecMap.containsKey(ffcodename)) &#123; return codecMap.get(ffcodename); &#125; return ""; &#125; public static boolean isSupportCodec(String ffcodecname)&#123; boolean supportvideo = false; int count = MediaCodecList.getCodecCount(); for(int i = 0; i &lt; count; i++)&#123; String[] tyeps = MediaCodecList.getCodecInfoAt(i).getSupportedTypes(); for(int j = 0; j &lt; tyeps.length; j++)&#123; if(tyeps[j].equals(findVideoCodecName(ffcodecname)))&#123; supportvideo = true; break; &#125; &#125; if(supportvideo)&#123; break; &#125; &#125; return supportvideo; &#125;&#125; c++层: 1234567891011121314151617181920212223242526272829303132333435363738394041424344const char* codecName = ((const AVCodec*)avCodecContext-&gt;codec)-&gt;name;onCallInitMediacodec( codecName, avCodecContext-&gt;width, avCodecContext-&gt;height, avCodecContext-&gt;extradata_size, avCodecContext-&gt;extradata_size, avCodecContext-&gt;extradata, avCodecContext-&gt;extradata );//获取jmid_initmediacodecjclass jlz = jniEnv-&gt;GetObjectClass(jobj);jmethodID jmid_initmediacodec = env-&gt;GetMethodID(jlz, "initMediaCodec", "(Ljava/lang/String;II[B[B)V");//在子线程void onCallInitMediacodec(const char* mime, int width, int height, int csd0_size, int csd1_size, uint8_t *csd_0, uint8_t *csd_1) &#123; JNIEnv *jniEnv; if(javaVM-&gt;AttachCurrentThread(&amp;jniEnv, 0) != JNI_OK) &#123; if(LOG_DEBUG) &#123; LOGE("call onCallComplete worng"); &#125; &#125; jstring type = jniEnv-&gt;NewStringUTF(mime); jbyteArray csd0 = jniEnv-&gt;NewByteArray(csd0_size); jniEnv-&gt;SetByteArrayRegion(csd0, 0, csd0_size, reinterpret_cast&lt;const jbyte *&gt;(csd_0)); jbyteArray csd1 = jniEnv-&gt;NewByteArray(csd1_size); jniEnv-&gt;SetByteArrayRegion(csd1, 0, csd1_size, reinterpret_cast&lt;const jbyte *&gt;(csd_1)); jniEnv-&gt;CallVoidMethod(jobj, jmid_initmediacodec, type, width, height, csd0, csd1); jniEnv-&gt;DeleteLocalRef(csd0); jniEnv-&gt;DeleteLocalRef(csd1); jniEnv-&gt;DeleteLocalRef(type); javaVM-&gt;DetachCurrentThread();&#125; 解码AvPacket数据1234567891011121314151617public void decodeAVPacket(int datasize, byte[] data) &#123; if (surface != null &amp;&amp; datasize &gt; 0 &amp;&amp; data != null) &#123; int intputBufferIndex = mediaCodec.dequeueInputBuffer(10); if (intputBufferIndex &gt;= 0) &#123; ByteBuffer byteBuffer = mediaCodec.getOutputBuffers()[intputBufferIndex]; byteBuffer.clear(); byteBuffer.put(data); mediaCodec.queueInputBuffer(intputBufferIndex, 0, datasize, 0, 0); &#125; //这里拿到outputBufferIndex然后就可以获取到数据,这里会通过surface达到渲染 int outputBufferIndex = mediaCodec.dequeueOutputBuffer(info, 10); while (outputBufferIndex &gt;= 0) &#123; mediaCodec.releaseOutputBuffer(outputBufferIndex, true); outputBufferIndex = mediaCodec.dequeueOutputBuffer(info, 10); &#125; &#125;&#125; c++层回调decodeAVPacket12datasize = avPacket-&gt;size;data = avPacket-&gt;data;//jni这里需要把uint8_t转为jbyteArray，类似初始化那]]></content>
      <categories>
        <category>MediaCodec</category>
      </categories>
      <tags>
        <tag>音视频</tag>
        <tag>MediaCodec</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MediaCodec判断是否可以采用硬解码]]></title>
    <url>%2FMediaCodec%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E9%87%87%E7%94%A8%E7%A1%AC%E8%A7%A3%E7%A0%81.html</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142import android.media.MediaCodecList;import java.util.HashMap;import java.util.Map;public class VideoSupportUitl &#123; private static Map&lt;String, String&gt; codecMap = new HashMap&lt;&gt;(); static &#123; codecMap.put("h264", "video/avc"); &#125; public static String findVideoCodecName(String ffcodename)&#123; if(codecMap.containsKey(ffcodename)) &#123; return codecMap.get(ffcodename); &#125; return ""; &#125; public static boolean isSupportCodec(String ffcodecname)&#123; boolean supportvideo = false; int count = MediaCodecList.getCodecCount(); for(int i = 0; i &lt; count; i++) &#123; String[] tyeps = MediaCodecList.getCodecInfoAt(i).getSupportedTypes(); for(int j = 0; j &lt; tyeps.length; j++) &#123; if(tyeps[j].equals(findVideoCodecName(ffcodecname))) &#123; supportvideo = true; break; &#125; &#125; if(supportvideo) &#123; break; &#125; &#125; return supportvideo; &#125;&#125; 具体的类型对应关系可以查看相关文档，这里在Android源码MediaCodec.createDecoderByType()里面有一些相关的对应支持类型。1234567891011121314151617181920212223242526272829303132333435/** * Instantiate the preferred decoder supporting input data of the given mime type. * * The following is a partial list of defined mime types and their semantics: * &lt;ul&gt; * &lt;li&gt;"video/x-vnd.on2.vp8" - VP8 video (i.e. video in .webm) * &lt;li&gt;"video/x-vnd.on2.vp9" - VP9 video (i.e. video in .webm) * &lt;li&gt;"video/avc" - H.264/AVC video * &lt;li&gt;"video/hevc" - H.265/HEVC video * &lt;li&gt;"video/mp4v-es" - MPEG4 video * &lt;li&gt;"video/3gpp" - H.263 video * &lt;li&gt;"audio/3gpp" - AMR narrowband audio * &lt;li&gt;"audio/amr-wb" - AMR wideband audio * &lt;li&gt;"audio/mpeg" - MPEG1/2 audio layer III * &lt;li&gt;"audio/mp4a-latm" - AAC audio (note, this is raw AAC packets, not packaged in LATM!) * &lt;li&gt;"audio/vorbis" - vorbis audio * &lt;li&gt;"audio/g711-alaw" - G.711 alaw audio * &lt;li&gt;"audio/g711-mlaw" - G.711 ulaw audio * &lt;/ul&gt; * * &lt;strong&gt;Note:&lt;/strong&gt; It is preferred to use &#123;@link MediaCodecList#findDecoderForFormat&#125; * and &#123;@link #createByCodecName&#125; to ensure that the resulting codec can handle a * given format. * * @param type The mime type of the input data. * @throws IOException if the codec cannot be created. * @throws IllegalArgumentException if type is not a valid mime type. * @throws NullPointerException if type is null. */ @NonNull public static MediaCodec createDecoderByType(@NonNull String type) throws IOException &#123; return new MediaCodec(type, true /* nameIsType */, false /* encoder */); &#125; 在ffmpeg里面1((const AVCodec*)(avCodecContext-&gt;codec))-&gt;name; 即可拿到name，然后jni交互调用即可。]]></content>
      <categories>
        <category>MediaCodec</category>
      </categories>
      <tags>
        <tag>音视频</tag>
        <tag>MediaCodec</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ffmpeg为AVPacket添加解码头信息]]></title>
    <url>%2Fffmpeg%E4%B8%BAAVPacket%E6%B7%BB%E5%8A%A0%E8%A7%A3%E7%A0%81%E5%A4%B4%E4%BF%A1%E6%81%AF.html</url>
    <content type="text"><![CDATA[FFmpeg解码获得的AVPacket只包含视频压缩数据，并没有包含相关的解码信息（比如：h264的sps pps头信息，AAC的adts头信息），没有这些编码头信息解码器（MediaCodec）是识别不到不能解码的。在FFmpeg中，这些头信息是保存在解码器上下文（AVCodecContext）的extradata中的，所以我们需要为每一种格式的视频添加相应的解码头信息，这样解码器（MediaCodec）才能正确解析每一个AVPacket里的视频数据。 主要使用的类AVBitStreamFilter 添加过程: 123456789101112131415161718192021222324252627282930313233343536373839404142const AVBitStreamFilter *absFilter = NULL;AVBSFContext *absCtx = NULL;AVCodecParameters *codecpar = NULL;//1. 找到相应解码器的过滤器if(strcasecmp(codecName, "h264") == 0)&#123; absFilter = av_bsf_get_by_name("h264_mp4toannexb");&#125;else if(strcasecmp(codecName, "h265") == 0)&#123; absFilter = av_bsf_get_by_name("hevc_mp4toannexb");&#125;//2.过滤器分配内存av_bsf_alloc(absFilter,absCtx)//3. 添加解码器属性if(pFormatCtx-&gt;streams[i]-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO)&#123; codecpar = pFormatCtx-&gt;streams[i]-&gt;codecpar;&#125;avcodec_parameters_copy(absCtx-&gt;par_in, codecpar);//4. 初始化过滤器上下文av_bsf_init(absCtx);//5. AVPacket处理if(av_bsf_send_packet(absCtx, avPacket) != 0)&#123; av_packet_free(&amp;avPacket); av_free(avPacket); avPacket = NULL; continue;&#125;while(av_bsf_receive_packet(absCtx, avPacket) == 0)&#123; LOGE("开始解码"); av_packet_free(&amp;avPacket); av_free(avPacket); continue;&#125;avPacket = NULL;//6. 释放资源av_bsf_free(&amp;absCtx);absCtx = NULL;]]></content>
      <categories>
        <category>ffmpeg</category>
      </categories>
      <tags>
        <tag>音视频</tag>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ffmpeg视频播放器相关]]></title>
    <url>%2Fffmpeg%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8%E7%9B%B8%E5%85%B3.html</url>
    <content type="text"><![CDATA[视频播放思路和播放音频一样，采用生产者消费者模型。AvPacket入队，然后AvPacket出队伍解码。 视频解码渲染软解码：如果解码之后的数据格式是AV_PIX_FMT_YUV420P直接使用采用OpenGLES渲染，如果不是AV_PIX_FMT_YUV420P采用sws_scale转为AV_PIX_FMT_YUV420P在采用OpenGLES渲染。将YUV数据转换RGB的操作放在OpenGLES里面，使用GPU提升效率。软解码容易造成容易造成音视频不同步。硬解码：在解码之前判断是否支持硬解码，如果支持硬解码就直接通过ffmpeg处理视频数据H264 H265等，为其加上头信息，然后硬解码交其OpenGLES渲染。 音视频同步问题 音频线性播放，视频同步到音频上。 视频线性播放，音频同步到视频上。 用一个外部线性时间，音频和视频都同步到这个外部时间上。 由于人们对声音更敏感，视频画面的一会儿快一会儿慢是察觉不出来的。而声音的节奏变化是很容易察觉的。所以我们这里采用第一种方式来同步音视频。这里需要计算当前视频帧的播放时间和当前音频的播放时间来进行比较，然后计算出睡眠时间来让视频不渲染还是延迟渲染,保持音视频尽量同步。 音视频同步相关计算 计算当前视频帧播放的时间 12345678910111213141516171819double clock = 0;if(pFormatCtx-&gt;streams[i]-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO)&#123; time_base = pFormatCtx-&gt;streams[i]-&gt;time_base;&#125;//... double pts = av_frame_get_best_effort_timestamp(avFrame); if(pts == AV_NOPTS_VALUE) &#123; pts = 0; &#125; pts *= av_q2d(time_base); if(pts &gt; 0) &#123; clock = pts; &#125; 计算音视频播放时间差值 123456789101112131415161718//如果&gt;0表示音频播放在前，视频渲染慢了，需要加速渲染 &lt;0表示音频播放在后，视频渲染快了，需要延迟渲染double getFrameDiffTime(AVFrame *avFrame) &#123; double pts = av_frame_get_best_effort_timestamp(avFrame); if(pts == AV_NOPTS_VALUE) &#123; pts = 0; &#125; pts *= av_q2d(time_base); if(pts &gt; 0) &#123; clock = pts; &#125; double diff = audio-&gt;clock - clock; return diff;&#125; 计算渲染睡眠时间 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 //延时时间 单位秒double delayTime = 0;//默认的延时时间 通过当前帧的AVRational计算fps所得 单位秒double defaultDelayTime = 0.04;if(pFormatCtx-&gt;streams[i]-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO)&#123; int num = pFormatCtx-&gt;streams[i]-&gt;avg_frame_rate.num; int den = pFormatCtx-&gt;streams[i]-&gt;avg_frame_rate.den; if(num != 0 &amp;&amp; den != 0) &#123; int fps = num / den;//[25 / 1] defaultDelayTime = 1.0 / fps; &#125;&#125;double getDelayTime(double diff) &#123; //如果音频的播放时间超过了30ms 视频需要加速渲染 慢慢的缩小睡眠时间 达到平缓的效果 if (diff &gt; 0.003) &#123; delayTime = delayTime * 2 / 3; if (delayTime &lt; defaultDelayTime / 2) &#123; delayTime = defaultDelayTime * 2 / 3; &#125; else if (delayTime &gt; defaultDelayTime * 2) &#123; delayTime = defaultDelayTime * 2; &#125; &#125; else if (diff &lt; -0.003) &#123; //如果音频的播放时间慢了30ms 视频需要延迟渲染 delayTime = delayTime * 3 / 2; if (delayTime &lt; defaultDelayTime / 2) &#123; delayTime = defaultDelayTime * 2 / 3; &#125; else if (delayTime &gt; defaultDelayTime * 2) &#123; delayTime = defaultDelayTime * 2; &#125; &#125; else if (diff == 0.003) &#123; &#125; if (diff &gt;= 0.5) &#123; delayTime = 0; &#125; else if (diff &lt;= -0.5) &#123; delayTime = defaultDelayTime * 2; &#125; if (fabs(diff) &gt;= 10) &#123; delayTime = defaultDelayTime; &#125; return delayTime;&#125; 播放暂停，停止，继续播放解码渲染之前用一个标识判断即可 seek和音频播放类似，解码之前采用标识判断，当调用seek的时候设置标识，清除缓冲队列，调用1avcodec_flush_buffers(&amp;AVCodecContext); 进行seek,接着清空队列，并调用1avformat_seek_file(pFormatCtx, -1, INT64_MIN, rel, INT64_MAX, 0); 清空ffmpeg的缓存。 注意 这里有一个线程在使用AVFormatContext获取AvPacket,有一个线程在使用AVCodecContext在进行解码，需要为AVFormatContext和AVCodecContext添加锁。防止同步问题造成其他问题。 可能在seek之前，我们的数据已经读取完了存储在缓冲队列里面，这里seek清空缓冲队列，就会播放完毕，所以我们需要在读取不到数据的时候也加上seek标识判断。比如 12345678910111213//这里是读取数据完毕的时候while(playstatus != NULL &amp;&amp; !playstatus-&gt;exit)&#123; if(audio-&gt;queue-&gt;getQueueSize() &gt; 0)&#123; av_usleep(1000 * 100); continue; &#125; else&#123; if(!playstatus-&gt;seek)&#123; av_usleep(1000 * 100); playstatus-&gt;exit = true; &#125; break; &#125;&#125; release内存回收这里需要特别注意的是线程退出的问题 单个线程退出 使用return 代替 pthread_exit(); 多个线程退出 使用pthread_join(thread_t, NULL)，会阻塞当前线程，直到thread_t退出完。退出的时候需要理清楚线程的退出顺序。]]></content>
      <categories>
        <category>ffmpeg</category>
      </categories>
      <tags>
        <tag>音视频</tag>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用SoudTouch实现变速变调]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8SoudTouch%E5%AE%9E%E7%8E%B0%E5%8F%98%E9%80%9F%E5%8F%98%E8%B0%83.html</url>
    <content type="text"><![CDATA[声明SoundTouch对象和内存变量,根据声道数和采样率初始化对象和内存 12345678910111213141516171819202122SoundTouch *soundTouch = NULL;SAMPLETYPE *sampleBuffer = NULL;//采样率int sample_rate=44100;//声道数int channels =2;//变调float pitch= 1.0f;//变数float speed= 1.0f;//采样位数 SoudTouch最低支持16bit，所以使用16bit的来播放int bits= 16; //每秒理论PCM大小int BUFF_SIZE =sample_rate * channels * bits/8; sampleBuffer = static_cast&lt;SAMPLETYPE *&gt;(malloc(BUFF_SIZE));soundTouch = new SoundTouch();soundTouch-&gt;setSampleRate(sample_rate);soundTouch-&gt;setChannels(channels);soundTouch-&gt;setPitch(pitch);soundTouch-&gt;setTempo(speed); 把PCM数据给SoundTouch处理 12345678910111213141516//采样个数，具体怎么获取看具体情况int nb=0;//示例1 ：文件读取int size = fread();nb = size/channels;//示例2 ：ffmpeg解码int nb = swr_convert();//最大采样数 int maxSamples = BUFF_SIZE / channels; //处理数据soundTouch-&gt;putSamples(sampleBuffer, nb);//得到数据到sampleBufferint num = soundTouch-&gt;receiveSamples(sampleBuffer, maxSamples); 设置变速和变调 12soundTouch-&gt;setPitch(1.0); //变调soundTouch-&gt;setTempo(1.5);//变速 SoudTouch选择处理数据是16bit还是32bit,在STTypes.h里面找到 1234567891011121314151617181920#if !(SOUNDTOUCH_INTEGER_SAMPLES || SOUNDTOUCH_FLOAT_SAMPLES) /// Choose either 32bit floating point or 16bit integer sampletype /// by choosing one of the following defines, unless this selection /// has already been done in some other file. //// /// Notes: /// - In Windows environment, choose the sample format with the /// following defines. /// - In GNU environment, the floating point samples are used by /// default, but integer samples can be chosen by giving the /// following switch to the configure script: /// ./configure --enable-integer-samples /// However, if you still prefer to select the sample format here /// also in GNU environment, then please #undef the INTEGER_SAMPLE /// and FLOAT_SAMPLE defines first as in comments above. //#define SOUNDTOUCH_INTEGER_SAMPLES 1 //&lt; 16bit integer samples #define SOUNDTOUCH_FLOAT_SAMPLES 1 //&lt; 32bit float samples #endif 根据你的类型注释选择对应的宏定义即可 ffmpeg里面使用的时候需要注意的点：因为FFmpeg解码出来的PCM数据是8bit （uint8）的，而SoundTouch中最低是16bit（ 16bit integer samples），所以我们需要将8bit的数据转换成16bit后再给SoundTouch处理。 8bit-&gt;16bit处理方式:1234567891011SAMPLETYPE *sampleBuffer=NULL ;uint8_t *out_buffer = NULL;//....初始化等//获取音频数据到out_bufferint data_size = resampleAudio(reinterpret_cast&lt;void **&gt;(&amp;out_buffer));for(int i = 0; i &lt; data_size / 2 + 1; i++)&#123; sampleBuffer[i] = (buffer[i * 2] | ((buffer[i * 2 + 1]) &lt;&lt; 8));&#125; 官方示例，将一个文件变速变调转为另外一个文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566static void_processFile(SoundTouch *pSoundTouch, const float pitch, const float tempo, const char *inFileName, const char *outFileName) &#123; SoundTouch *pSoundTouch = new SoundTouch(); //设置音调 pSoundTouch-&gt;setPitch(pitch); //设置音速 pSoundTouch-&gt;setTempo(tempo); int nSamples;//采样率 int nChannels;//声道 int buffSizeSamples;//每一次缓冲大小 SAMPLETYPE sampleBuffer[BUFF_SIZE];//缓冲 // open input file WavInFile inFile(inFileName); int sampleRate = inFile.getSampleRate(); int bits = inFile.getNumBits(); nChannels = inFile.getNumChannels(); // create output file WavOutFile outFile(outFileName, sampleRate, bits, nChannels); pSoundTouch-&gt;setSampleRate(sampleRate); pSoundTouch-&gt;setChannels(nChannels); assert(nChannels &gt; 0); buffSizeSamples = BUFF_SIZE / nChannels; // Process samples read from the input file while (inFile.eof() == 0) &#123; int num; // Read a chunk of samples from the input file num = inFile.read(sampleBuffer, BUFF_SIZE); nSamples = num / nChannels; // Feed the samples into SoundTouch processor pSoundTouch-&gt;putSamples(sampleBuffer, nSamples); // Read ready samples from SoundTouch processor &amp; write them output file. // NOTES: // - 'receiveSamples' doesn't necessarily return any samples at all // during some rounds! // - On the other hand, during some round 'receiveSamples' may have more // ready samples than would fit into 'sampleBuffer', and for this reason // the 'receiveSamples' call is iterated for as many times as it // outputs samples. do &#123; nSamples = pSoundTouch-&gt;receiveSamples(sampleBuffer, buffSizeSamples); outFile.write(sampleBuffer, nSamples * nChannels); &#125; while (nSamples != 0); &#125; // Now the input file is processed, yet 'flush' few last samples that are // hiding in the SoundTouch's internal processing pipeline. pSoundTouch-&gt;flush(); do &#123; nSamples = pSoundTouch-&gt;receiveSamples(sampleBuffer, buffSizeSamples); outFile.write(sampleBuffer, nSamples * nChannels); &#125; while (nSamples != 0); delete (pSoundTouch);&#125; ffmpeg示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273SoundTouch *soundTouch = NULL;SAMPLETYPE *sampleBuffer = NULL;//采样率int sample_rate=44100;//声道数int channels =2;//变调float pitch= 1.0f;//变数float speed= 1.0f;//采样位数 SoudTouch最低支持16bit，所以使用16bit的来播放int bits= 16; //每秒理论PCM大小int BUFF_SIZE =sample_rate * channels * bits/8; sampleBuffer = static_cast&lt;SAMPLETYPE *&gt;(malloc(BUFF_SIZE));soundTouch = new SoundTouch();soundTouch-&gt;setSampleRate(sample_rate);soundTouch-&gt;setChannels(channels);soundTouch-&gt;setPitch(pitch);soundTouch-&gt;setTempo(speed);//获取SoundTouch处理的数据int WlAudio::getSoundTouchData() &#123; int maxSamples = BUFF_SIZE / channels; while (playstatus != NULL &amp;&amp; !playstatus-&gt;exit) &#123; out_buffer = NULL; if (finished) &#123; finished = false; //获取pcm数据到out_buffer data_size = resampleAudio(reinterpret_cast&lt;void **&gt;(&amp;out_buffer)); if (data_size &gt; 0) &#123; for (int i = 0; i &lt; data_size / 2 + 1; i++) &#123; //解码的数据是8bit的 //8bit-&gt;16bit sampleBuffer[i] = (out_buffer[i * 2] | ((out_buffer[i * 2 + 1]) &lt;&lt; 8)); &#125; //nb 表示采样个数 在resampleAudio里面解码的时候通过swr_convert返回值回去 soundTouch-&gt;putSamples(sampleBuffer, nb); //获取处理后的数据 到sampleBuffer num = soundTouch-&gt;receiveSamples(sampleBuffer,maxSamples); &#125; else &#123; soundTouch-&gt;flush(); &#125; &#125; if (num == 0) &#123; finished = true; continue; &#125; else &#123; if (out_buffer == NULL) &#123; num = soundTouch-&gt;receiveSamples(sampleBuffer, maxSamples); if (num == 0) &#123; finished = true; continue; &#125; &#125; return num; &#125; &#125; return 0;&#125;//OpenSLES播放数据int buffersize = wlAudio-&gt;getSoundTouchData();if (buffersize &gt; 0) &#123;//两个8bit-&gt;一个16bit 转换为char*是为了都转换成字节来处理 (*wlAudio-&gt;pcmBufferQueue)-&gt;Enqueue(wlAudio-&gt;pcmBufferQueue, (char *) wlAudio-&gt;sampleBuffer, buffersize * nChannels * 2 ); &#125;]]></content>
      <categories>
        <category>SoudTouch</category>
      </categories>
      <tags>
        <tag>音视频</tag>
        <tag>SoudTouch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SoudTouch Android cmake编译]]></title>
    <url>%2FSoudTouch%20Android%20cmake%E7%BC%96%E8%AF%91.html</url>
    <content type="text"><![CDATA[源码下载： https://gitlab.com/soundtouch/soundtouch, 源码下载之后里面有demo参考。将下载的源码的include和source/SoundTouch目录的文件拷入 目录结构 cmake 123456789101112131415161718192021222324252627282930313233343536373839404142cmake_minimum_required(VERSION 3.4.1)include_directories(src/main/cpp/soundtouch/include)include_directories(src/main/cpp/soundtouch/SoundTouch)add_library( # Sets the name of the library. native-lib # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). src/main/cpp/native-lib.cpp src/main/cpp/soundtouch/SoundTouch/AAFilter.cpp src/main/cpp/soundtouch/SoundTouch/FIFOSampleBuffer.cpp src/main/cpp/soundtouch/SoundTouch/FIRFilter.cpp src/main/cpp/soundtouch/SoundTouch/cpu_detect_x86.cpp src/main/cpp/soundtouch/SoundTouch/sse_optimized.cpp src/main/cpp/soundtouch/SoundTouch/RateTransposer.cpp src/main/cpp/soundtouch/SoundTouch/SoundTouch.cpp src/main/cpp/soundtouch/SoundTouch/InterpolateCubic.cpp src/main/cpp/soundtouch/SoundTouch/InterpolateLinear.cpp src/main/cpp/soundtouch/SoundTouch/InterpolateShannon.cpp src/main/cpp/soundtouch/SoundTouch/TDStretch.cpp src/main/cpp/soundtouch/SoundTouch/PeakFinder.cpp )find_library( # Sets the name of the path variable. log-lib # Specifies the name of the NDK library that # you want CMake to locate. log )target_link_libraries( # Specifies the target library. native-lib # Links the target library to the log library # included in the NDK. $&#123;log-lib&#125; ) 配置信息参考demo]]></content>
      <categories>
        <category>SoudTouch</category>
      </categories>
      <tags>
        <tag>音视频</tag>
        <tag>SoudTouch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ffmpeg 音频播放器相关]]></title>
    <url>%2Fffmpeg%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE%E5%99%A8%E7%9B%B8%E5%85%B3.html</url>
    <content type="text"><![CDATA[每秒理论PCM大小1每秒理论PCM大小 = 采样率 * 声道数 * 位数/8 比如：12//44100hz 立体声 16bitint s_time = 44100 * 2 * 16/8; 获取总时长1duration = pFormatCtx-&gt;duration / AV_TIME_BASE; 获取当前AVframe时间123AVRational time_base = pFormatCtx-&gt;streams[audio_index]-&gt;time_basedouble now_time = frame-&gt;pts * av_q2d(time_base); 获取当前播放时间因为每一个AVframe的pts不一定都有，所以就需要自己手维护一个当前时间的变量 12公式：PCM实际数据大小 / 每秒理论PCM大小；clock += buffersize / ((double)(sample_rate * 2 * 2)); 伪代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364AVFormatContext *pFormatCtx = NULL;//采样率int sample_rate =0;//当前总时长int duration = 0;AVRational time_base =NULL;//当前AvFrame时间int now_time=0;//当前播放时长int clock = 0;//上次播放时长标识int last_time=0;uint8_t *buffer = NULL;int data_size=0;//获取到 pFormatCtx...for(int i = 0; i &lt; pFormatCtx-&gt;nb_streams; i++) &#123; if(pFormatCtx-&gt;streams[i]-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_AUDIO)//得到音频流 &#123; ... sample_rate = pFormatCtx-&gt;streams[i]-&gt;codecpar-&gt;sample_rate; duration= pFormatCtx-&gt;duration / AV_TIME_BASE; time_base = pFormatCtx-&gt;streams[i]-&gt;time_base; &#125;&#125;//解码数据 ... int nb = swr_convert( swr_ctx, &amp;buffer, avFrame-&gt;nb_samples, (const uint8_t **) avFrame-&gt;data, avFrame-&gt;nb_samples); int out_channels = av_get_channel_layout_nb_channels(AV_CH_LAYOUT_STEREO); data_size = nb * out_channels * av_get_bytes_per_sample(AV_SAMPLE_FMT_S16); now_time = avFrame-&gt;pts * av_q2d(time_base); if(now_time &lt; clock)&#123; now_time = clock; &#125; clock = now_time;//解码数据之后数据封装在 buffer，播放的时候...if(data_size&gt;0)&#123; //size/(采样率(44100hz) * 立体声*16bit/8) clock += data_size / ((double)(sample_rate * 2 * 2)); //设置一个回掉最小相差值 if(clock - last_tiem &gt;= 0.1) &#123; last_tiem = clock; //回调应用层 callJava-&gt;onCallTimeInfo(CHILD_THREAD,clock, duration); &#125; &#125; 解码播放流程思路采用多线程，生产者消费者模型，AVPacket入队，然后AVPacket出队解码播放，播放采用OpenSLES release内存回收当我们release的时候，我们需要注意 为了确保线程完全退出，我们最好是sleep个几十毫秒，然后在释放相关内存,但是最好的是使用pthred_join来同步线程退出。 有可能初始化未准备完毕我们就调用release，这时候最好是在初始化准备和release加个线程锁。 初始化的时候有可能avformat_open_input打开网络链接，网络很卡，所以我们需要为pFormatCtx加入一个interrupt_callback来及时响应12345678910111213int avformat_callback(void *ctx)&#123; WlFFmpeg *fFmpeg = (WlFFmpeg *) ctx; if(fFmpeg-&gt;playstatus-&gt;exit) &#123; return AVERROR_EOF; &#125; return 0;&#125;pFormatCtx-&gt;interrupt_callback.callback = avformat_callback;pFormatCtx-&gt;interrupt_callback.opaque = this; 暂停，继续,停止播放,播放完成暂停播放，继续播放采用OpenSLES的相关api,播放完成则在播放完毕的时候回掉即可 seek功能在seek的时候设置标志位并加锁，清空队列，标志位判断是否继续av_read_frame，seek完毕释放锁，还原标识位。即可重新读取最新数据 12345678910111213141516seek = true;queue-&gt;clearAvpacket();pthread_mutex_lock(&amp;seek_mutex);int64_t rel = secs * AV_TIME_BASE;//重置内部解码器状态/刷新内部缓冲区 avcodec_flush_buffers(avCodecContext);//主要是这个函数avformat_seek_file(pFormatCtx, -1, INT64_MIN, rel, INT64_MAX, 0);pthread_mutex_unlock(&amp;seek_mutex);seek = false;pthread_mutex_lock(&amp;seek_mutex);ret = av_read_frame(pFormatCtx, packet);pthread_mutex_unlock(&amp;seek_mutex); 音量,声道切换采用OpenSLES的相关api 播放变速变调OpenSL ES可以实现变速播放，但是再改变速度的同时也改变了音调，这种体验是不好的。所以采用SoundTouch来实现，在播放的时候，对原始数据重新进行计算即可 计算pcm分贝大小12345678910111213141516//char*是为了都转换成字节来处理 int WlAudio::getPCMDB(char *pcmcata, size_t pcmsize) &#123; int db = 0; short int pervalue = 0; double sum = 0; for (int i = 0; i &lt; pcmsize; i += 2) &#123; memcpy(&amp;pervalue, pcmcata + i, 2); sum += abs(pervalue); &#125; sum = sum / (pcmsize / 2); if (sum &gt; 0) &#123; db = (int) 20.0 * log10(sum); &#125; return db;&#125; 性能优化 由于解码用到了while循环，而不加睡眠的while循环会使CPU使用率提高30%左右，因此我们需要为解码线程加上一定的睡眠时间来降低CPU使用率。 停止时回收创建的内存空间。 一个AVPacket对应多个AVFrame 比如.ape格式的这种情况就需要在解码的时候，设置一个标识来判断不停的解析AVPacket,avcodec_send_packet(avCodecContext, avPacket)之后不停的avcodec_receive_frame，知道读取完毕在设置标识。 一个AVPacket对应多个AVFrame引发的seek问题由于一个AVPacket里面有多个AVFrame，当seek时，FFmpeg解码器中还残留AVFrame，所以会导致seek后，不能立即播放当前音乐。解决方案就是seek的时候调用 1avcodec_flush_buffers(avCodecContext)]]></content>
      <categories>
        <category>ffmpeg</category>
      </categories>
      <tags>
        <tag>音视频</tag>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenSLES基础功能]]></title>
    <url>%2FOpenSLES%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD.html</url>
    <content type="text"><![CDATA[OpenSLES（Open Sound Library for Embedded Systems）无授权费、跨平台、针对嵌入式系统精心优化的硬件音频加速API。它为嵌入式移动多媒体设备上的本地应用程序开发者提供标准化, 高性能,低响应时间的音频功能实现方法，并实现软/硬件音频性能的直接跨平台部署，降低执行难度，促进高级音频市场的发展。 在Android里面ndk-&gt;platforms-&gt; android-xx -&gt; arch-xx -&gt;usr-&gt;lib目录里面包含了ndk内置的so，可以看到支持了libOpenSLES.so。 在github上googlesamples/android-ndk可以看到ndk库的sample,里面native-audio目录就是OpenSLES得sample。 OpenSLES播放主要步骤如下: 创建接口对象 设置混音器 创建播放器（录音器） 设置缓冲队列和回调函数 设置播放状态 启动回调函数 销毁 4.1 创建接口对象 123456789// 引擎接口SLObjectItf engineObject = NULL;SLEngineItf engineEngine = NULL;// 创建引擎对象 slCreateEngine(&amp;engineObject, 0, NULL, 0, NULL, NULL); (*engineObject)-&gt;Realize(engineObject, SL_BOOLEAN_FALSE); (*engineObject)-&gt;GetInterface(engineObject, SL_IID_ENGINE, &amp;engineEngine); 4.2 设置混音器 1234567891011121314151617181920//混音器SLObjectItf outputMixObject = NULL;SLEnvironmentalReverbItf outputMixEnvironmentalReverb = NULL;SLEnvironmentalReverbSettings reverbSettings = SL_I3DL2_ENVIRONMENT_PRESET_STONECORRIDOR;const SLInterfaceID mids[1] = &#123;SL_IID_ENVIRONMENTALREVERB&#125;;const SLboolean mreq[1] = &#123;SL_BOOLEAN_FALSE&#125;;(*engineEngine)-&gt;CreateOutputMix(engineEngine, &amp;outputMixObject, 1, mids, mreq);(void)result;result = (*outputMixObject)-&gt;Realize(outputMixObject, SL_BOOLEAN_FALSE);(void)result;result = (*outputMixObject)-&gt;GetInterface(outputMixObject, SL_IID_ENVIRONMENTALREVERB, &amp;outputMixEnvironmentalReverb);if (SL_RESULT_SUCCESS == result) &#123; result = (*outputMixEnvironmentalReverb)-&gt;SetEnvironmentalReverbProperties( outputMixEnvironmentalReverb, &amp;reverbSettings); (void)result;&#125;SLDataLocator_OutputMix outputMix = &#123;SL_DATALOCATOR_OUTPUTMIX, outputMixObject&#125;; 4.3 创建播放器 123456789101112131415161718192021222324252627282930 //pcm SLObjectItf pcmPlayerObject = NULL; SLPlayItf pcmPlayerPlay = NULL; SLVolumeItf pcmPlayerVolume = NULL; SLDataLocator_AndroidSimpleBufferQueue android_queue=&#123;SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE,2&#125;; SLDataFormat_PCM pcm=&#123; SL_DATAFORMAT_PCM,//播放pcm格式的数据 2,//2个声道（立体声） SL_SAMPLINGRATE_44_1,//44100hz的频率 SL_PCMSAMPLEFORMAT_FIXED_16,//位数 16位 SL_PCMSAMPLEFORMAT_FIXED_16,//和位数一致就行 SL_SPEAKER_FRONT_LEFT | SL_SPEAKER_FRONT_RIGHT,//立体声（前左前右） SL_BYTEORDER_LITTLEENDIAN//结束标志 &#125;; SLDataSource slDataSource = &#123;&amp;android_queue, &amp;pcm&#125;; SLDataSink audioSnk = &#123;&amp;outputMix, NULL&#125;;// SL_IID_BUFFERQUEUE:缓冲 SL_IID_VOLUME:音量 SL_IID_PLAYBACKRATE:微调功能 防止卡顿 微调功能 SL_IID_MUTESOLO:声道切换 const SLInterfaceID ids[4] = &#123;SL_IID_BUFFERQUEUE, SL_IID_VOLUME, SL_IID_PLAYBACKRATE, SL_IID_MUTESOLO&#125;; const SLboolean req[4] = &#123;SL_BOOLEAN_TRUE, SL_BOOLEAN_TRUE, SL_BOOLEAN_TRUE, SL_BOOLEAN_TRUE&#125;; result = (*engineEngine)-&gt;CreateAudioPlayer(engineEngine, &amp;pcmPlayerObject, &amp;slDataSource, &amp;audioSnk, 3, ids, req); // 初始化播放器 (*pcmPlayerObject)-&gt;Realize(pcmPlayerObject, SL_BOOLEAN_FALSE); //得到接口后调用 获取Player接口 (*pcmPlayerObject)-&gt;GetInterface(pcmPlayerObject, SL_IID_PLAY, &amp;pcmPlayerPlay); 4.4 设置缓冲队列和回调函数12345678910111213141516171819202122232425262728293031323334353637383940414243//缓冲器队列接口SLAndroidSimpleBufferQueueItf pcmBufferQueue;void *buffer;uint8_t *out_buffer;void getPcmData(void **pcm)&#123; while(!feof(pcmFile)) &#123; int size = static_cast&lt;int&gt;(fread(out_buffer,1,44100 * 2 * 2,pcmFile)); if(out_buffer == NULL) &#123; LOGI("%s %d", "read end",size); break; &#125; else&#123; LOGI("%s %d", "reading",size); &#125; *pcm = out_buffer; break; &#125;&#125;void pcmBufferCallBack(SLAndroidSimpleBufferQueueItf bf, void * context)&#123; //assert(NULL == context); getPcmData(&amp;buffer); // for streaming playback, replace this test by logic to find and fill the next buffer if (NULL != buffer) &#123; SLresult result; // enqueue another buffer result = (*pcmBufferQueue)-&gt;Enqueue(pcmBufferQueue, buffer, 44100 * 2 * 2); // the most likely other result is SL_RESULT_BUFFER_INSUFFICIENT, // which for this code example would indicate a programming error &#125;&#125;// 创建缓冲区和回调函数(*pcmPlayerObject)-&gt;GetInterface(pcmPlayerObject, SL_IID_BUFFERQUEUE, &amp;pcmBufferQueue);//缓冲接口回调(*pcmBufferQueue)-&gt;RegisterCallback(pcmBufferQueue, pcmBufferCallBack, NULL);//获取音量接口(*pcmPlayerObject)-&gt;GetInterface(pcmPlayerObject, SL_IID_VOLUME, &amp;pcmPlayerVolume); 4.5 设置播放状态 1(*pcmPlayerPlay)-&gt;SetPlayState(pcmPlayerPlay, SL_PLAYSTATE_PLAYING); 4.6 启动回调函数12 // 主动调用回调函数开始工作pcmBufferCallBack(pcmBufferQueue, NULL); 4.7 销毁12345678910111213141516171819202122 if (pcmPlayerObject != NULL) &#123; (*pcmPlayerObject)-&gt;Destroy(pcmPlayerObject); pcmPlayerObject = NULL; pcmPlayerPlay = NULL; pcmBufferQueue = NULL; pcmPlayerVolume = NULL;&#125;if (outputMixObject != NULL) &#123; (*outputMixObject)-&gt;Destroy(outputMixObject); outputMixObject = NULL; outputMixEnvironmentalReverb = NULL;&#125; if (engineObject != NULL) &#123; (*engineObject)-&gt;Destroy(engineObject); engineObject = NULL; engineEngine = NULL;&#125; 示例代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;jni.h&gt;#include &lt;string&gt;extern "C"&#123;#include &lt;SLES/OpenSLES.h&gt;#include &lt;SLES/OpenSLES_Android.h&gt;&#125;#include &lt;android/log.h&gt;#define LOGI(FORMAT,...) __android_log_print(ANDROID_LOG_INFO,"zzw",FORMAT,##__VA_ARGS__);#define LOGE(FORMAT,...) __android_log_print(ANDROID_LOG_ERROR,"zzw",FORMAT,##__VA_ARGS__);// 引擎接口SLObjectItf engineObject = NULL;SLEngineItf engineEngine = NULL;//混音器SLObjectItf outputMixObject = NULL;SLEnvironmentalReverbItf outputMixEnvironmentalReverb = NULL;SLEnvironmentalReverbSettings reverbSettings = SL_I3DL2_ENVIRONMENT_PRESET_STONECORRIDOR;//pcmSLObjectItf pcmPlayerObject = NULL;SLPlayItf pcmPlayerPlay = NULL;SLVolumeItf pcmPlayerVolume = NULL;//缓冲器队列接口SLAndroidSimpleBufferQueueItf pcmBufferQueue;FILE *pcmFile;void *buffer;uint8_t *out_buffer;void getPcmData(void **pcm)&#123; while(!feof(pcmFile)) &#123; int size = static_cast&lt;int&gt;(fread(out_buffer,1,44100 * 2 * 2,pcmFile)); if(out_buffer == NULL) &#123; LOGI("%s %d", "read end",size); break; &#125; else&#123; LOGI("%s %d", "reading",size); &#125; *pcm = out_buffer; break; &#125;&#125;void pcmBufferCallBack(SLAndroidSimpleBufferQueueItf bf, void * context)&#123; //assert(NULL == context); getPcmData(&amp;buffer); // for streaming playback, replace this test by logic to find and fill the next buffer if (NULL != buffer) &#123; SLresult result; // enqueue another buffer result = (*pcmBufferQueue)-&gt;Enqueue(pcmBufferQueue, buffer, 44100 * 2 * 2); // the most likely other result is SL_RESULT_BUFFER_INSUFFICIENT, // which for this code example would indicate a programming error &#125;&#125;extern "C"JNIEXPORT void JNICALLJava_com_example_zzw_androidopenslaudio_MainActivity_palypcm(JNIEnv *env, jobject instance, jstring url_) &#123; const char *url = env-&gt;GetStringUTFChars(url_, 0); // TODO //读取pcm文件 pcmFile = fopen(url, "r"); if(pcmFile == NULL) &#123; LOGE("%s", "fopen file error"); return; &#125; out_buffer = (uint8_t *) malloc(44100 * 2 * 2); SLresult result; //第一步------------------------------------------ // 创建引擎对象 slCreateEngine(&amp;engineObject, 0, 0, 0, 0, 0); (*engineObject)-&gt;Realize(engineObject, SL_BOOLEAN_FALSE); (*engineObject)-&gt;GetInterface(engineObject, SL_IID_ENGINE, &amp;engineEngine); //第二步------------------------------------------- // 创建混音器 const SLInterfaceID mids[1] = &#123;SL_IID_ENVIRONMENTALREVERB&#125;; const SLboolean mreq[1] = &#123;SL_BOOLEAN_FALSE&#125;; result = (*engineEngine)-&gt;CreateOutputMix(engineEngine, &amp;outputMixObject, 1, mids, mreq); (void)result; result = (*outputMixObject)-&gt;Realize(outputMixObject, SL_BOOLEAN_FALSE); (void)result; result = (*outputMixObject)-&gt;GetInterface(outputMixObject, SL_IID_ENVIRONMENTALREVERB, &amp;outputMixEnvironmentalReverb); if (SL_RESULT_SUCCESS == result) &#123; result = (*outputMixEnvironmentalReverb)-&gt;SetEnvironmentalReverbProperties( outputMixEnvironmentalReverb, &amp;reverbSettings); (void)result; &#125; SLDataLocator_OutputMix outputMix = &#123;SL_DATALOCATOR_OUTPUTMIX, outputMixObject&#125;; // 第三步-------------------------------------------- // 创建播放器 SLDataLocator_AndroidSimpleBufferQueue android_queue=&#123;SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE,2&#125;; SLDataFormat_PCM pcm=&#123; SL_DATAFORMAT_PCM,//播放pcm格式的数据 2,//2个声道（立体声） SL_SAMPLINGRATE_44_1,//44100hz的频率 SL_PCMSAMPLEFORMAT_FIXED_16,//位数 16位 SL_PCMSAMPLEFORMAT_FIXED_16,//和位数一致就行 SL_SPEAKER_FRONT_LEFT | SL_SPEAKER_FRONT_RIGHT,//立体声（前左前右） SL_BYTEORDER_LITTLEENDIAN//结束标志 &#125;; SLDataSource slDataSource = &#123;&amp;android_queue, &amp;pcm&#125;; SLDataSink audioSnk = &#123;&amp;outputMix, NULL&#125;; // SL_IID_BUFFERQUEUE:缓冲 SL_IID_VOLUME:音量 SL_IID_PLAYBACKRATE:微调功能 防止卡顿 微调功能 SL_IID_MUTESOLO:声道切换 const SLInterfaceID ids[4] = &#123;SL_IID_BUFFERQUEUE, SL_IID_VOLUME, SL_IID_PLAYBACKRATE, SL_IID_MUTESOLO&#125;; const SLboolean req[4] = &#123;SL_BOOLEAN_TRUE, SL_BOOLEAN_TRUE, SL_BOOLEAN_TRUE, SL_BOOLEAN_TRUE&#125;; result = (*engineEngine)-&gt;CreateAudioPlayer(engineEngine, &amp;pcmPlayerObject, &amp;slDataSource, &amp;audioSnk, 3, ids, req); // 初始化播放器 (*pcmPlayerObject)-&gt;Realize(pcmPlayerObject, SL_BOOLEAN_FALSE); //得到接口后调用 获取Player接口 (*pcmPlayerObject)-&gt;GetInterface(pcmPlayerObject, SL_IID_PLAY, &amp;pcmPlayerPlay); //第四步--------------------------------------- // 创建缓冲区和回调函数 (*pcmPlayerObject)-&gt;GetInterface(pcmPlayerObject, SL_IID_BUFFERQUEUE, &amp;pcmBufferQueue); //缓冲接口回调 (*pcmBufferQueue)-&gt;RegisterCallback(pcmBufferQueue, pcmBufferCallBack, NULL); //获取音量接口 (*pcmPlayerObject)-&gt;GetInterface(pcmPlayerObject, SL_IID_VOLUME, &amp;pcmPlayerVolume); //第五步---------------------------------------- // 设置播放状态 (*pcmPlayerPlay)-&gt;SetPlayState(pcmPlayerPlay, SL_PLAYSTATE_PLAYING); //第六步---------------------------------------- // 主动调用回调函数开始工作 pcmBufferCallBack(pcmBufferQueue, NULL); env-&gt;ReleaseStringUTFChars(url_, url);&#125; 暂停、继续、停止使用播放控制接口 SLPlayItf 123456789101112//暂停if (pcmPlayerPlay != NULL) &#123; (*pcmPlayerPlay)-&gt;SetPlayState(pcmPlayerPlay, SL_PLAYSTATE_PAUSED);&#125;//继续if (pcmPlayerPlay != NULL) &#123; (*pcmPlayerPlay)-&gt;SetPlayState(pcmPlayerPlay, SL_PLAYSTATE_PLAYING);&#125;//停止if (pcmPlayerPlay != NULL) &#123; (*pcmPlayerPlay)-&gt;SetPlayState(pcmPlayerPlay, SL_PLAYSTATE_STOPPED);&#125; 音量控制使用音量控制接口 SLVolumeItf 1234//初始化(*pcmPlayerObject)-&gt;GetInterface(pcmPlayerObject,SL_IID_VOLUME,&amp;pcmPlayerVolume);//设置音量(*pcmPlayerVolume)-&gt;SetVolumeLevel(pcmPlayerVolume, (100 - percent) * -50); 可用示例1234567891011121314151617181920212223242526272829303132333435363738394041void WlAudio::setVolume(int percent) &#123; volumePercent = percent; if(pcmVolumePlay != NULL) &#123; if(percent &gt; 30) &#123; (*pcmVolumePlay)-&gt;SetVolumeLevel(pcmVolumePlay, (100 - percent) * -20); &#125; else if(percent &gt; 25) &#123; (*pcmVolumePlay)-&gt;SetVolumeLevel(pcmVolumePlay, (100 - percent) * -22); &#125; else if(percent &gt; 20) &#123; (*pcmVolumePlay)-&gt;SetVolumeLevel(pcmVolumePlay, (100 - percent) * -25); &#125; else if(percent &gt; 15) &#123; (*pcmVolumePlay)-&gt;SetVolumeLevel(pcmVolumePlay, (100 - percent) * -28); &#125; else if(percent &gt; 10) &#123; (*pcmVolumePlay)-&gt;SetVolumeLevel(pcmVolumePlay, (100 - percent) * -30); &#125; else if(percent &gt; 5) &#123; (*pcmVolumePlay)-&gt;SetVolumeLevel(pcmVolumePlay, (100 - percent) * -34); &#125; else if(percent &gt; 3) &#123; (*pcmVolumePlay)-&gt;SetVolumeLevel(pcmVolumePlay, (100 - percent) * -37); &#125; else if(percent &gt; 0) &#123; (*pcmVolumePlay)-&gt;SetVolumeLevel(pcmVolumePlay, (100 - percent) * -40); &#125; else&#123; (*pcmVolumePlay)-&gt;SetVolumeLevel(pcmVolumePlay, (100 - percent) * -100); &#125; &#125;&#125; 声道控制 采用声道控制接口SLMuteSoloItf接口 1234567891011 SLMuteSoloItf pcmMutePlay = NULL;//初始化 (*pcmPlayerObject)-&gt;GetInterface(pcmPlayerObject, SL_IID_MUTESOLO, &amp;pcmMutePlay); // 设置声道： (*pcmPlayPlayerMuteSolo)-&gt;SetChannelMute( pcmPlayPlayerMuteSolo, 1, //0右声道1左声道 false //声道是否开启 ); 有效示例:123456789101112131415161718192021222324 SLMuteSoloItf pcmMutePlay = NULL; //初始化 ...void WlAudio::setMute(int mute) &#123; this-&gt;mute = mute; if(pcmMutePlay != NULL) &#123; if(mute == 0)//right &#123; (*pcmMutePlay)-&gt;SetChannelMute(pcmMutePlay, 1, false); (*pcmMutePlay)-&gt;SetChannelMute(pcmMutePlay, 0, true); &#125; else if(mute == 1)//left &#123; (*pcmMutePlay)-&gt;SetChannelMute(pcmMutePlay, 1, true); (*pcmMutePlay)-&gt;SetChannelMute(pcmMutePlay, 0, false); &#125; else if(mute == 2)//center &#123; (*pcmMutePlay)-&gt;SetChannelMute(pcmMutePlay, 1, false); (*pcmMutePlay)-&gt;SetChannelMute(pcmMutePlay, 0, false); &#125; &#125;&#125; 录音 有效示例:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;jni.h&gt;#include &lt;string&gt;#include "AndroidLog.h"#include "RecordBuffer.h"#include &lt;SLES/OpenSLES.h&gt;#include &lt;SLES/OpenSLES_Android.h&gt;bool finish = false;FILE *recodeFile = NULL;const static int RECORDER_BUFFER_SIZE = 4096;SLObjectItf engineObject = NULL;SLEngineItf engineItf = NULL;SLObjectItf recordObj = NULL;SLRecordItf recordItf = NULL;SLAndroidSimpleBufferQueueItf recorderBufferQueue = NULL;RecordBuffer *recordBuffer = NULL;// this callback handler is called every time a buffer finishes recordingvoid bqRecorderCallback(SLAndroidSimpleBufferQueueItf bq, void *context) &#123; fwrite(recordBuffer-&gt;getNowBuffer(), 1, RECORDER_BUFFER_SIZE * sizeof(short), recodeFile); if (finish) &#123; LOGE("录制完成"); //设置停止 (*recordItf)-&gt;SetRecordState(recordItf, SL_RECORDSTATE_STOPPED); fclose(recodeFile); //释放资源 (*recordObj)-&gt;Destroy(recordObj); recordObj = NULL; recordItf = NULL; (*engineObject)-&gt;Destroy(engineObject); engineObject = NULL; engineItf = NULL; delete (recordBuffer); &#125; else &#123; LOGE("正在录制"); // 入队 (*recorderBufferQueue)-&gt;Enqueue(recorderBufferQueue, recordBuffer-&gt;getRecordBuffer(), RECORDER_BUFFER_SIZE * sizeof(short)); &#125;&#125;extern "C"JNIEXPORT void JNICALLJava_com_zzw_openslesrecoder_MainActivity_startRecord(JNIEnv *env, jobject instance, jstring path_) &#123; const char *path = env-&gt;GetStringUTFChars(path_, 0); finish = false; recodeFile = fopen(path, "w+"); //1. 创建引擎对象 slCreateEngine(&amp;engineObject, 0, NULL, 0, NULL, NULL); //2. 实现引擎对象 (*engineObject)-&gt;Realize(engineObject, SL_BOOLEAN_FALSE); //3. 获取引擎接口 (*engineObject)-&gt;GetInterface(engineObject, SL_IID_ENGINE, &amp;engineItf); // configure audio source SLDataLocator_IODevice loc_dev = &#123;SL_DATALOCATOR_IODEVICE, SL_IODEVICE_AUDIOINPUT, SL_DEFAULTDEVICEID_AUDIOINPUT, NULL&#125;; SLDataSource audioSrc = &#123;&amp;loc_dev, NULL&#125;; // configure audio sink SLDataLocator_AndroidSimpleBufferQueue loc_bq = &#123;SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE, 2&#125;; SLDataFormat_PCM format_pcm = &#123;SL_DATAFORMAT_PCM, //PCM格式 2,//立体声 SL_SAMPLINGRATE_44_1,//44100HZ SL_PCMSAMPLEFORMAT_FIXED_16,// SL_PCMSAMPLEFORMAT_FIXED_16, SL_SPEAKER_FRONT_LEFT | SL_SPEAKER_FRONT_RIGHT, //左右声道 SL_BYTEORDER_LITTLEENDIAN&#125;;//小尾端 SLDataSink audioSnk = &#123;&amp;loc_bq, &amp;format_pcm&#125;; // (requires the RECORD_AUDIO permission) const SLInterfaceID id[1] = &#123;SL_IID_ANDROIDSIMPLEBUFFERQUEUE&#125;; const SLboolean req[1] = &#123;SL_BOOLEAN_TRUE&#125;; //4. 配置获取录音的引擎对象 (*engineItf)-&gt;CreateAudioRecorder(engineItf, &amp;recordObj, &amp;audioSrc, &amp;audioSnk, 1, id, req); //5. 实现录音的引擎对象 // realize the audio recorder (*recordObj)-&gt;Realize(recordObj, SL_BOOLEAN_FALSE); //6. 获取录音的引擎接口 //get the record interface (*recordObj)-&gt;GetInterface(recordObj, SL_IID_RECORD, &amp;recordItf); //7. 获取缓冲队列接口 //get the buffer queue interface (*recordObj)-&gt;GetInterface(recordObj, SL_IID_ANDROIDSIMPLEBUFFERQUEUE, &amp;recorderBufferQueue); //8. 设置录音回掉 (*recorderBufferQueue)-&gt;RegisterCallback(recorderBufferQueue, bqRecorderCallback, NULL); recordBuffer = new RecordBuffer(RECORDER_BUFFER_SIZE); //9. 入队 (*recorderBufferQueue)-&gt;Enqueue(recorderBufferQueue, recordBuffer-&gt;getRecordBuffer(), RECORDER_BUFFER_SIZE * sizeof(short)); //10. 设置状态开启录音 (*recordItf)-&gt;SetRecordState(recordItf, SL_RECORDSTATE_RECORDING); env-&gt;ReleaseStringUTFChars(path_, path);&#125;extern "C"JNIEXPORT void JNICALLJava_com_zzw_openslesrecoder_MainActivity_stopRecord(JNIEnv *env, jobject instance) &#123; finish = true;&#125; RecordBuffer.cpp: 123456789101112131415161718192021222324252627282930#include "RecordBuffer.h"RecordBuffer::RecordBuffer(int bufferSize) &#123; buffer = new short *[2]; for (int i = 0; i &lt; 2; i++) &#123; buffer[i] = new short[bufferSize]; &#125;&#125;short *RecordBuffer::getRecordBuffer() &#123; index++; if (index &gt; 1) &#123; index = 0; &#125; return buffer[index];&#125;RecordBuffer::~RecordBuffer() &#123; for (int i = 0; i &lt; 2; i++) &#123; delete buffer[i]; &#125; delete buffer;&#125;short *RecordBuffer::getNowBuffer() &#123; return buffer[index];&#125; RecordBuffer.h 12345678910111213141516class RecordBuffer &#123;public: short **buffer; int index = 0;public: RecordBuffer(int bufferSize); ~RecordBuffer(); short *getRecordBuffer(); short * getNowBuffer();&#125;;]]></content>
      <categories>
        <category>OpenSLES</category>
      </categories>
      <tags>
        <tag>音视频</tag>
        <tag>OpenSLES</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生产者消费者模型]]></title>
    <url>%2F%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B.html</url>
    <content type="text"><![CDATA[生产者消费者模型主要有以下函数和对象1234567891011121314151617181920212223242526272829//线程锁对象pthread_mutex_t mutex;//用于初始化pthread_mutex_t锁对象 pthread_mutex_init(&amp;mutex, NULL);//用于销毁pthread_mutex_t锁对象pthread_mutex_destroy(&amp;mutex)//线程条件对象pthread_cond_t cond;//用于初始化pthread_cond_t线程条件对象 pthread_cond_init(&amp;cond, NULL);//用于销毁pthread_cond_t线程条件对象 pthread_cond_destroy(&amp;cond);//用于上锁mutex,本线程上锁后的其他变量是不能被别的线程操作pthread_mutex_lock(&amp;mutex);//用于解锁mutex，解锁后的其他变量可以被其他线程操作pthread_mutex_unlock(&amp;mutex);//用于发出条件信号 pthread_cond_signal(&amp;cond);//用于线程阻塞等待，这个函数会解锁，直到pthread_cond_signal发出条件信号后才执行退出线程阻塞执行后面的操作才执行退出线程阻塞执行后面的操作pthread_cond_wait(&amp;cond, &amp;mutex); 示例代码如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include "pthread.h"#include "queue"#include "unistd.h"pthread_t produc;pthread_t custom;pthread_mutex_t mutex;pthread_cond_t cond;std::queue&lt;int&gt; queue;void *producCallback(void *data)&#123; while (1) &#123; pthread_mutex_lock(&amp;mutex); queue.push(1); LOGD("生产者生产一个产品，通知消费者消费， 产品数量为 %d", queue.size()); pthread_cond_signal(&amp;cond); pthread_mutex_unlock(&amp;mutex); sleep(5); &#125; pthread_exit(&amp;produc);&#125;void *customCallback(void *data)&#123; while (1) &#123; pthread_mutex_lock(&amp;mutex); if(queue.size() &gt; 0) &#123; queue.pop(); LOGD("消费者消费产品，产品数量还剩余 %d ", queue.size()); &#125; else&#123; LOGD("没有产品可以消费， 等待中..."); pthread_cond_wait(&amp;cond, &amp;mutex); &#125; pthread_mutex_unlock(&amp;mutex); usleep(500 * 1000); &#125; pthread_exit(&amp;custom); pthread_mutex_destroy(&amp;mutex); pthread_cond_destroy(&amp;cond);&#125;extern "C"JNIEXPORT void JNICALLJava_com_zzw_jnithread_ThreadDemo_mutexThread(JNIEnv *env, jobject instance) &#123; for(int i = 0; i &lt; 10; i++) &#123; queue.push(1); &#125; pthread_mutex_init(&amp;mutex, NULL); pthread_cond_init(&amp;cond, NULL); pthread_create(&amp;produc, NULL, producCallback, NULL); pthread_create(&amp;custom, NULL, customCallback, NULL);&#125;]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ffmpeg libswscale实现YUV转RGB]]></title>
    <url>%2Flibswscale%E5%AE%9E%E7%8E%B0YUV%E8%BD%ACRGB.html</url>
    <content type="text"><![CDATA[libswscale里面实现了各种图像像素格式的转换。 主要函数如下:123456//使用参数初始化SwsContext结构体sws_getContext()//转换一帧图像sws_scale()//释放SwsContext结构体sws_freeContext() 初始化函数: 123456//为SwsContext结构体分配内存sws_alloc_context()//设置SwsContext结构体的值av_opt_set()/av_opt_set_XXX()//初始化SwsContext结构体。sws_init_context() 这种复杂的方法可以配置一些sws_getContext()配置不了的参数。比如说设置图像的YUV像素的取值范围是JPEG标准（Y、U、V取值范围都是0-255）还是MPEG标准（Y取值范围是16-235，U、V的取值范围是16-240） 获取像素格式信息:1234//可以获得指定像素格式的AVPixFmtDescriptor结构体av_pix_fmt_desc_get()//通过AVPixFmtDescriptor获取值av_get_bits_per_pixel() //获取比特数（bpp） 图像拉伸: 1SWS_BICUBIC性能比较好；SWS_FAST_BILINEAR在性能和速度之间有一个比好好的平衡。 示例将通过yuv文件生成rgb文件，代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198#include "stdafx.h"extern "C" &#123; #include &lt;libswscale/swscale.h&gt; #include &lt;libavutil/opt.h&gt; #include &lt;libavutil/imgutils.h&gt;&#125;void p(const char * msg, int d = -1123) &#123; if (d == -1123) &#123; printf_s("%s\n", msg); &#125; else &#123; printf_s("%s %d \n", msg, d); &#125;&#125;int yuv2Rgb(FILE *yuvFile,FILE * rgbFile) &#123; SwsContext *img_convert_ctx = NULL; const AVPixelFormat srcPixelFormat = AV_PIX_FMT_YUV420P; const AVPixelFormat dstPixelFormat = AV_PIX_FMT_RGB24; const int srcW = 1080; const int srcH= 720; const int dstW = 540; const int dstH = 360; uint8_t *src_data[4]; int src_linesize[4]; uint8_t *dst_data[4]; int dst_linesize[4]; //1. 获得指定像素格式的AVPixFmtDescriptor结构体 const AVPixFmtDescriptor * pSrcPixFmtDes = av_pix_fmt_desc_get(srcPixelFormat); //2. 获得指定像素格式每个像素占用的比特数bpp（Bit Per Pixel） int srcBpp= av_get_bits_per_pixel(pSrcPixFmtDes); const AVPixFmtDescriptor * pDstPixFmtDes = av_pix_fmt_desc_get(dstPixelFormat); int dstBpp = av_get_bits_per_pixel(pDstPixFmtDes); //3. 根据宽高，像素格式分配buffer大小 if (av_image_alloc(src_data, src_linesize, srcW, srcH, srcPixelFormat, 1) &lt; 0) &#123; p("Could not allocate source image"); return -1; &#125; if (av_image_alloc(dst_data, dst_linesize, dstW, dstH, dstPixelFormat, 1) &lt; 0) &#123; p("Could not allocate source image"); return -1; &#125; //4. 为SwsContext结构体分配内存。 img_convert_ctx = sws_alloc_context(); //Show AVOption av_opt_show2(img_convert_ctx, stdout, AV_OPT_FLAG_VIDEO_PARAM, 0); //图像拉伸 SWS_BICUBIC性能比较好；SWS_FAST_BILINEAR在性能和速度之间有一个比好好的平衡。 //const int rescale_method = SWS_BICUBIC; //5. 设置值 av_opt_set_int(img_convert_ctx, "sws_flags", SWS_BICUBIC | SWS_PRINT_INFO, 0); av_opt_set_int(img_convert_ctx, "srcw", srcW, 0); av_opt_set_int(img_convert_ctx, "srch", srcH, 0); av_opt_set_int(img_convert_ctx, "src_format", srcPixelFormat, 0); //'0' for MPEG (Y:0-235);'1' for JPEG (Y:0-255) av_opt_set_int(img_convert_ctx, "src_range", 1, 0); av_opt_set_int(img_convert_ctx, "dstw", dstW, 0); av_opt_set_int(img_convert_ctx, "dsth", dstH, 0); av_opt_set_int(img_convert_ctx, "dst_format", dstPixelFormat, 0); av_opt_set_int(img_convert_ctx, "dst_range", 1, 0); sws_init_context(img_convert_ctx, NULL, NULL);//对SwsContext中的各种变量进行赋值 uint8_t *temp_buffer = (uint8_t *)malloc(srcW *srcH *srcBpp / 8); int frame_idx = 0; while (1)&#123; if (fread(temp_buffer, 1, srcW*srcH*srcBpp / 8, yuvFile) != srcW * srcH*srcBpp / 8) &#123; break; &#125; switch (srcPixelFormat) &#123; case AV_PIX_FMT_GRAY8: &#123; memcpy(src_data[0], temp_buffer, srcW*srcH); break; &#125; case AV_PIX_FMT_YUV420P: &#123; memcpy(src_data[0], temp_buffer, srcW*srcH); //Y memcpy(src_data[1], temp_buffer + srcW * srcH, srcW*srcH / 4); //U memcpy(src_data[2], temp_buffer + srcW * srcH * 5 / 4, srcW*srcH / 4); //V break; &#125; case AV_PIX_FMT_YUV422P: &#123; memcpy(src_data[0], temp_buffer, srcW*srcH); //Y memcpy(src_data[1], temp_buffer + srcW * srcH, srcW*srcH / 2); //U memcpy(src_data[2], temp_buffer + srcW * srcH * 3 / 2, srcW*srcH / 2); //V break; &#125; case AV_PIX_FMT_YUV444P: &#123; memcpy(src_data[0], temp_buffer, srcW*srcH); //Y memcpy(src_data[1], temp_buffer + srcW * srcH, srcW*srcH); //U memcpy(src_data[2], temp_buffer + srcW * srcH * 2, srcW*srcH); //V break; &#125; case AV_PIX_FMT_YUYV422: &#123; memcpy(src_data[0], temp_buffer, srcW*srcH * 2); //Packed break; &#125; case AV_PIX_FMT_RGB24: &#123; memcpy(src_data[0], temp_buffer, srcW*srcH * 3); //Packed break; &#125; default: &#123; printf("Not Support Input Pixel Format.\n"); break; &#125; &#125; sws_scale(img_convert_ctx, src_data, src_linesize, 0, srcH, dst_data, dst_linesize);//转换像素 printf("Finish process frame %5d\n", frame_idx); frame_idx++; switch (dstPixelFormat) &#123; case AV_PIX_FMT_GRAY8: &#123; fwrite(dst_data[0], 1, dstW*dstH, rgbFile); break; &#125; case AV_PIX_FMT_YUV420P: &#123; fwrite(dst_data[0], 1, dstW*dstH, rgbFile); //Y fwrite(dst_data[1], 1, dstW*dstH / 4, rgbFile); //U fwrite(dst_data[2], 1, dstW*dstH / 4, rgbFile); //V break; &#125; case AV_PIX_FMT_YUV422P: &#123; fwrite(dst_data[0], 1, dstW*dstH, rgbFile); //Y fwrite(dst_data[1], 1, dstW*dstH / 2, rgbFile); //U fwrite(dst_data[2], 1, dstW*dstH / 2, rgbFile); //V break; &#125; case AV_PIX_FMT_YUV444P: &#123; fwrite(dst_data[0], 1, dstW*dstH, rgbFile); //Y fwrite(dst_data[1], 1, dstW*dstH, rgbFile); //U fwrite(dst_data[2], 1, dstW*dstH, rgbFile); //V break; &#125; case AV_PIX_FMT_YUYV422: &#123; fwrite(dst_data[0], 1, dstW*dstH * 2, rgbFile); //Packed break; &#125; case AV_PIX_FMT_RGB24: &#123; fwrite(dst_data[0], 1, dstW*dstH * 3, rgbFile); //Packed break; &#125; default: &#123; p("Not Support Output Pixel Format.\n"); break; &#125; &#125; &#125; sws_freeContext(img_convert_ctx); free(temp_buffer); av_freep(&amp;src_data[0]); av_freep(&amp;dst_data[0]); return 0;&#125;int main() &#123; FILE* inFile; FILE* outFile; fopen_s(&amp;inFile,"F:/视频资源/gxsp.yuv", "rb"); fopen_s(&amp;outFile, "F:/视频资源/gxsp.rgb", "wb"); yuv2Rgb(inFile,outFile); fclose(inFile); fclose(outFile); getchar(); return 0;&#125; 参考链接:libswscale实现YUV转RGB 相关格式转换:视音频数据处理入门：RGB、YUV像素数据处理]]></content>
      <categories>
        <category>ffmpeg</category>
      </categories>
      <tags>
        <tag>音视频</tag>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ffmpeg 封装格式转换 MP4转AVI]]></title>
    <url>%2Fffmpeg%20%E5%B0%81%E8%A3%85%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2%20MP4%E8%BD%ACAVI.html</url>
    <content type="text"><![CDATA[格式转换直接将视音频压缩码流从一种封装格式文件中获取出来然后打包成另外一种封装格式的文件。因为不需要进行视音频的编码和解码，所以不会有视音频的压缩损伤。 主要步骤如下: 注册初始化 1av_register_all(); 打开输入文件，获取视频相关信息 12avformat_open_input()avformat_find_stream_info() 初始化输出文件的AVFormatContext并copy输入文件AVFormatContext的相关设置，打开输出文件 1234567//为输出格式分配AVFormatContextavformat_alloc_output_context2()//【关键步骤】 copy输入文件的设置到输出文件avcodec_copy_context()//打开输出文件avio_open() 写入数据到文件 123456789//将文件流头部数据写入文件avformat_write_header()//读取帧av_read_frame()//数据包写入文件av_interleaved_write_frame()//将文件流尾部数据写入文件并释放文件资源av_write_trailer() 回收 具体代码和步骤如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include &lt;stdio.h&gt;#include "stdafx.h"extern "C"&#123;#include &lt;libavformat/avformat.h&gt;&#125;;void log_ss(const char * msg, int d = -1123) &#123; if (d == -1123) &#123; printf_s("%s\n", msg); &#125; else &#123; printf_s("%s %d \n", msg, d); &#125;&#125;int main()&#123; AVOutputFormat *ofmt = NULL; //Input AVFormatContext and Output AVFormatContext AVFormatContext *ifmt_ctx = NULL, *ofmt_ctx = NULL; AVPacket pkt; int ret, i; int frame_index=0; const char * in_filename = "F:/视频资源/gxsp.mp4";//Input file URL const char * out_filename = "F:/视频资源/gxsp.avi";//Output file URL //1. 注册初始化 //H.264 bitstream malformed, no startcode found, use the video bitstream filte错误解决方法 第一步 AVBitStreamFilterContext *filter = av_bitstream_filter_init("h264_mp4toannexb"); if (NULL == filter) &#123; log_ss("filter init fail"); &#125; //av_register_bitstream_filter(filter-&gt;filter); av_register_all(); //2. 打开媒体文件与AVFormatContext关联 //Input if ((ret = avformat_open_input(&amp;ifmt_ctx, in_filename, 0, 0)) &lt; 0) &#123; log_ss( "Could not open input file."); goto end; &#125; //3. 获取视频流信息 if ((ret = avformat_find_stream_info(ifmt_ctx, 0)) &lt; 0) &#123;// log_ss( "Failed to retrieve input stream information"); goto end; &#125; log_ss("--------------- In File Information ----------------"); av_dump_format(ifmt_ctx, 0, in_filename, 0); log_ss("--------------- In File Information ----------------"); //4. 初始化输出视频码流的AVFormatContext，与输出文件相关联 avformat_alloc_output_context2(&amp;ofmt_ctx, NULL, NULL, out_filename); if (!ofmt_ctx) &#123; log_ss( "Could not create output context"); ret = AVERROR_UNKNOWN; goto end; &#125; //获取AVOutputFormat ofmt = ofmt_ctx-&gt;oformat; for (i = 0; i &lt; ifmt_ctx-&gt;nb_streams; i++) &#123; //Create output AVStream according to input AVStream AVStream *in_stream = ifmt_ctx-&gt;streams[i]; AVStream *out_stream = avformat_new_stream(ofmt_ctx, in_stream-&gt;codec-&gt;codec);// 初始化AVStream if (!out_stream) &#123; log_ss( "Failed allocating output stream\n"); ret = AVERROR_UNKNOWN; goto end; &#125; //5.【关键步骤】 copy输入文件的设置到输出文件 if (avcodec_copy_context(out_stream-&gt;codec, in_stream-&gt;codec) &lt; 0) &#123; log_ss( "Failed to copy context from input to output stream codec context\n"); goto end; &#125; out_stream-&gt;codec-&gt;codec_tag = 0; if (ofmt_ctx-&gt;oformat-&gt;flags &amp; AVFMT_GLOBALHEADER) out_stream-&gt;codec-&gt;flags |= CODEC_FLAG_GLOBAL_HEADER; &#125; log_ss("--------------- Out File Information ----------------"); av_dump_format(ofmt_ctx, 0, out_filename, 1); log_ss("--------------- Out File Information ----------------"); //6. 打开输出文件。 if (!(ofmt-&gt;flags &amp; AVFMT_NOFILE)) &#123; ret = avio_open(&amp;ofmt_ctx-&gt;pb, out_filename, AVIO_FLAG_WRITE); if (ret &lt; 0) &#123; log_ss( "Could not open output file"); log_ss( out_filename); goto end; &#125; &#125; //7. 写入头部到文件 if (avformat_write_header(ofmt_ctx, NULL) &lt; 0) &#123; log_ss( "Error occurred when opening output file\n"); goto end; &#125; //8. 写入数据到文件 while (1) &#123; AVStream *in_stream, *out_stream; //Get an AVPacket ret = av_read_frame(ifmt_ctx, &amp;pkt); if (ret &lt; 0) break; in_stream = ifmt_ctx-&gt;streams[pkt.stream_index]; out_stream = ofmt_ctx-&gt;streams[pkt.stream_index]; //H.264 bitstream malformed, no startcode found, use the video bitstream filte错误解决方法 第二步 if (pkt.stream_index == 0) &#123; AVPacket fpkt = pkt; int a = av_bitstream_filter_filter(filter, out_stream-&gt;codec, NULL, &amp;fpkt.data, &amp;fpkt.size, pkt.data, pkt.size, pkt.flags &amp; AV_PKT_FLAG_KEY); pkt.data = fpkt.data; pkt.size = fpkt.size; &#125; //Convert PTS/DTS pkt.pts = av_rescale_q_rnd(pkt.pts, in_stream-&gt;time_base, out_stream-&gt;time_base, (AVRounding)(AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX)); pkt.dts = av_rescale_q_rnd(pkt.dts, in_stream-&gt;time_base, out_stream-&gt;time_base, (AVRounding)(AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX)); pkt.duration = av_rescale_q(pkt.duration, in_stream-&gt;time_base, out_stream-&gt;time_base); pkt.pos = -1; //将AVPacket（存储视频压缩码流数据）写入文件 av_interleaved_write_frame将对 packet 进行缓存和 pts 检查，av_write_frame没有 if (av_interleaved_write_frame(ofmt_ctx, &amp;pkt) &lt; 0) &#123; log_ss( "Error muxing packets"); break; &#125; log_ss("Write frames to output file:",frame_index); av_packet_unref(&amp;pkt); frame_index++; &#125; //9. 写入文件尾部 //Write file trailer av_write_trailer(ofmt_ctx);end: avformat_close_input(&amp;ifmt_ctx); /* close output */ if (ofmt_ctx &amp;&amp; !(ofmt-&gt;flags &amp; AVFMT_NOFILE)) avio_close(ofmt_ctx-&gt;pb); avformat_free_context(ofmt_ctx); getchar(); return 0;&#125; 遇到的错误: 错误C4996 ‘xxxx’: 被申明已否决原因: 因为api已经过时解决: 建议换用新的api，或者在属性-&gt;c/c++-&gt;常规里面关闭SDL检查 H.264 bitstream malformed, no startcode found, use the video bitstream filte原因：主要是因为使用了mp4中的h264编码，而h264有两种封装：一种是annexb模式，传统模式，有startcode，SPS和PPS是在ES中；另一种是mp4模式，一般mp4、mkv、avi会没有startcode，SPS和PPS以及其它信息被封装在container中，每一个frame前面是这个frame的长度，很多解码器只支持annexb这种模式，因此需要将mp4做转换；在ffmpeg中用h264_mp4toannexb_filter可以做转换；所以需要使用-bsf h264_mp4toannexb来进行转换；解决：(1) 注册过滤器 123456AVBitStreamFilterContext *filter = av_bitstream_filter_init("h264_mp4toannexb"); if (NULL == filter) &#123; cout&lt;&lt;"filter init fail"&lt;&lt;endl; &#125; av_register_bitstream_filter(filter-&gt;filter); (2) 在获取第一帧的时候进行处理 12345678if (pkt.stream_index == 0) &#123; AVPacket fpkt = pkt; int a = av_bitstream_filter_filter(filter, out_stream-&gt;codec, NULL, &amp;fpkt.data, &amp;fpkt.size, pkt.data, pkt.size, pkt.flags &amp; AV_PKT_FLAG_KEY); pkt.data = fpkt.data; pkt.size = fpkt.size; &#125; 参考:ffmpeg实战教程（四）格式转换如MP4转MKV等H.264 bitstream malformed, no startcode found, use the video bitstream filte错误解决方法]]></content>
      <categories>
        <category>ffmpeg</category>
      </categories>
      <tags>
        <tag>音视频</tag>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[结合ffmpeg用SDL播放YUV实现简易播放器]]></title>
    <url>%2F%E7%BB%93%E5%90%88ffmpeg%E7%94%A8SDL%E6%92%AD%E6%94%BEYUV%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E6%92%AD%E6%94%BE%E5%99%A8.html</url>
    <content type="text"><![CDATA[通过解码之后得到的yuv视频数据我们直接可以进行播放，本篇使用SDL来实现视频播放。 SDL环境配置：https://blog.csdn.net/furzoom/article/details/53992124 SDL视频播放基础教程: https://blog.csdn.net/xuyankuanrong/article/details/77574152 有了上一篇文章的解码的基础，代码看着就很轻松了。 代码上写的很详细了，具体看代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250#include "stdafx.h"#include &lt;iostream&gt;// LNK2019 无法解析的外部符号 SDL_main，该符号在函数 main_utf8 中被引用#define SDL_MAIN_HANDLED //Refresh Event#define SFM_REFRESH_EVENT (SDL_USEREVENT + 1)#define SFM_BREAK_EVENT (SDL_USEREVENT + 2)extern "C" &#123; #include &lt;libavformat/avformat.h&gt; #include &lt;libavcodec/avcodec.h&gt; #include &lt;libavutil/imgutils.h&gt; #include &lt;libswscale/swscale.h&gt; #include &lt;libsdl/SDL.h&gt;&#125;void log_s(const char * msg, int d = -1123) &#123; if (d == -1123) &#123; printf_s("%s\n", msg); &#125; else &#123; printf_s("%s %d \n", msg, d); &#125;&#125;int thread_exit = 0;int thread_pause = 0;int sfp_refresh_thread(void *opaque) &#123; while (!thread_exit) &#123; if (!thread_pause) &#123; SDL_Event event; event.type = SFM_REFRESH_EVENT; SDL_PushEvent(&amp;event); &#125; SDL_Delay(10); &#125; thread_exit = 0; thread_pause = 0; //Break SDL_Event event; event.type = SFM_BREAK_EVENT; SDL_PushEvent(&amp;event); return 0;&#125;int play(const char* filePath) &#123; AVFormatContext * pFmtCtx = NULL; AVCodecContext *pCodecCtx = NULL; AVFrame *pFrame = NULL; AVFrame *pFrameYUV = NULL; uint8_t *outBuffer = NULL; AVPacket *pPacket = NULL; SwsContext *pSwsCtx = NULL; //SDL int screen_w, screen_h; SDL_Window *screen=NULL; SDL_Renderer* sdlRenderer = NULL; SDL_Texture* sdlTexture = NULL; SDL_Rect sdlRect; SDL_Thread *video_tid = NULL; SDL_Event event; //1. 初始化 av_register_all(); avformat_network_init(); //2. AVFormatContext获取 pFmtCtx = avformat_alloc_context(); //3. 打开文件 if (avformat_open_input(&amp;pFmtCtx, filePath, NULL, NULL) != 0) &#123; log_s("Couldn't open input stream.\n"); return -1; &#125; //4. 获取文件信息 if (avformat_find_stream_info(pFmtCtx, NULL)&lt;0) &#123; log_s("Couldn't find stream information."); return -1; &#125; //5. 获取视频的index int i = 0, videoIndex = -1; for (; i &lt; pFmtCtx-&gt;nb_streams; i++) &#123; if (pFmtCtx-&gt;streams[i]-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO) &#123; videoIndex = i; break; &#125; &#125; if (videoIndex == -1) &#123; log_s("Didn't find a video stream."); return -1; &#125; //6. 获取解码器并打开 pCodecCtx = avcodec_alloc_context3(NULL); if (avcodec_parameters_to_context(pCodecCtx, pFmtCtx-&gt;streams[videoIndex]-&gt;codecpar) &lt; 0) &#123; log_s("Didn't parameters to contex."); return -1; &#125; AVCodec *pCodec = avcodec_find_decoder(pCodecCtx-&gt;codec_id); if (pCodec == NULL) &#123; log_s("Codec not found."); return -1; &#125; if (avcodec_open2(pCodecCtx, pCodec, NULL)&lt;0) &#123;//打开解码器 log_s("Could not open codec."); return -1; &#125; //7. 解码播放开始准备工作 pFrame = av_frame_alloc(); pFrameYUV = av_frame_alloc(); //根据需要解码的类型，获取需要的buffer，不要忘记free outBuffer = (uint8_t *)av_malloc(av_image_get_buffer_size(AV_PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;height, 1) * sizeof(uint8_t)); //根据指定的图像参数和提供的数组设置数据指针和行数 ，数据填充到对应的pFrameYUV里面 av_image_fill_arrays(pFrameYUV-&gt;data, pFrameYUV-&gt;linesize, outBuffer, AV_PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;height, 1); pPacket = av_packet_alloc(); log_s("--------------- File Information ----------------"); av_dump_format(pFmtCtx, 0, filePath, 0); log_s("-------------------------------------------------"); //获取SwsContext pSwsCtx = sws_getContext(pCodecCtx-&gt;width, pCodecCtx-&gt;height, pCodecCtx-&gt;pix_fmt, pCodecCtx-&gt;width, pCodecCtx-&gt;height, AV_PIX_FMT_YUV420P, NULL, NULL, NULL, NULL); //---------------------------------------------------------------------------------------------------------------- // 8. SDL相关初始化 if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) &#123; log_s("Could not initialize SDL - "); log_s(SDL_GetError()); return -1; &#125; screen_w = pCodecCtx-&gt;width; screen_h = pCodecCtx-&gt;height; screen = SDL_CreateWindow("WS ffmpeg player", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, pCodecCtx-&gt;width/2, pCodecCtx-&gt;height/2, SDL_WINDOW_OPENGL); if (!screen) &#123; log_s("SDL: could not create window - exiting"); log_s(SDL_GetError()); return -1; &#125; sdlRenderer = SDL_CreateRenderer(screen, -1, 0); //IYUV: Y + U + V (3 planes) //YV12: Y + V + U (3 planes) sdlTexture = SDL_CreateTexture(sdlRenderer, SDL_PIXELFORMAT_IYUV, SDL_TEXTUREACCESS_STREAMING, pCodecCtx-&gt;width, pCodecCtx-&gt;height); sdlRect.x = 0; sdlRect.y = 0; sdlRect.w = screen_w; sdlRect.h = screen_h; video_tid = SDL_CreateThread(sfp_refresh_thread, NULL, NULL); //---------------------------------------------------------------------------------------------------------------- int count = 0; //9.读取数据播放 for (;;) &#123; //Wait SDL_WaitEvent(&amp;event); if (event.type == SFM_REFRESH_EVENT) &#123; if (av_read_frame(pFmtCtx, pPacket) == 0) &#123; if (pPacket-&gt;stream_index == videoIndex) &#123; if (avcodec_send_packet(pCodecCtx, pPacket) != 0) &#123;//解码一帧压缩数据 log_s("Decode end or Error."); break; &#125; else &#123;//处理解码数据 avcodec_receive_frame(pCodecCtx, pFrame); if (sws_scale(pSwsCtx, (const uint8_t* const*)pFrame-&gt;data, pFrame-&gt;linesize, 0, pCodecCtx-&gt;height, pFrameYUV-&gt;data, pFrameYUV-&gt;linesize) == 0) &#123; continue; &#125; count++; //SDL播放--------------------------- SDL_UpdateTexture(sdlTexture, NULL, pFrameYUV-&gt;data[0], pFrameYUV-&gt;linesize[0]); SDL_RenderClear(sdlRenderer); //SDL_RenderCopy( sdlRenderer, sdlTexture, &amp;sdlRect, &amp;sdlRect); SDL_RenderCopy(sdlRenderer, sdlTexture, &amp;sdlRect, NULL); SDL_RenderPresent(sdlRenderer); //SDL End----------------------- log_s("Succeed to play frame!", count); &#125; &#125; &#125;else &#123; //退出线程 thread_exit = 1; av_packet_unref(pPacket); &#125; &#125; else if (event.type == SDL_KEYDOWN) &#123; log_s("Pause"); //Pause if (event.key.keysym.sym == SDLK_SPACE) thread_pause = !thread_pause; &#125; else if (event.type == SDL_QUIT) &#123; log_s("quit"); thread_exit = 1; break; &#125; else if (event.type == SFM_BREAK_EVENT) &#123; log_s("break"); break; &#125; &#125; //sdl退出 SDL_Quit(); //回收 if (pSwsCtx != NULL) &#123; sws_freeContext(pSwsCtx); &#125; if (outBuffer != NULL) &#123; av_free(outBuffer); &#125; if (pFrameYUV != NULL) &#123; av_frame_free(&amp;pFrameYUV); &#125; if (pFrame != NULL) &#123; av_frame_free(&amp;pFrame); &#125; if (pCodecCtx != NULL) &#123; avcodec_close(pCodecCtx); &#125; if (pFmtCtx != NULL) &#123; avformat_close_input(&amp;pFmtCtx); &#125;&#125;int main()&#123; play("F:/视频资源/gxsp.mp4"); getchar(); return 0;&#125; 参考链接：https://blog.csdn.net/king1425/article/details/71171142]]></content>
      <categories>
        <category>ffmpeg</category>
      </categories>
      <tags>
        <tag>音视频</tag>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ffmpeg 视频解码h264和yuv]]></title>
    <url>%2Fffmpeg%20%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81h264%E5%92%8Cyuv.html</url>
    <content type="text"><![CDATA[之前学习 ffmpeg 在 android 平台上，发现很不方便，所以打算在 vs 上重新搭建环境，然后重新学习，之后如果需要用到的话在移植到其他平台。环境搭建参考的是: https://blog.csdn.net/weixinhum/article/details/37699025 环境 Microsoft Visual C++ 2017vs2017ffmpeg 3.4.2 步骤主要是以下几大步骤: 初始化 12av_register_all();avformat_network_init(); AVFormatContext获取和初始化 123456//AVFormatContext获取avformat_alloc_context()//打开文件，和AVFormatContext关联avformat_open_input()//获取文件流信息avformat_find_stream_info() 获取解码器 12345678//AVCodecContext获取avcodec_alloc_context3()//将AVCodecParameters转换为AVCodecContextavcodec_parameters_to_context()//获取解码器avcodec_find_decoder()//打开解码器avcodec_open2() 解码准备 12345678910//获取解码数据包装 AVFrameav_frame_alloc()//根据宽高，解码类型（yuv420）获取缓存buffer大小av_image_get_buffer_size()//根据指定的图像参数和提供的数组设置数据指针和行数 ，数据填充到对应的AVFrame里面av_image_fill_arrays()//获取编码数据 包装 AVPacketav_packet_alloc()//获取SwsContext 图片转换（宽高这些）需要用到sws_getContext() 读取数据源解码存储 12345678910//读取编码数据源到AVPacketav_read_frame()//发送数据源 avcodec_send_packet()//解码数据源 ,和avcodec_send_packet配合使用avcodec_receive_frame()//图像转换sws_scale()//写入文件fwrite() 回收 具体代码和步骤如下代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185#include &lt;iostream&gt;extern "C" &#123; #include &lt;libavformat/avformat.h&gt; #include &lt;libavcodec/avcodec.h&gt; #include &lt;libavutil/imgutils.h&gt; #include &lt;libswscale/swscale.h&gt;&#125;//初始化void init() &#123; av_register_all(); avformat_network_init();&#125;void log(const char * msg, int d=-1123) &#123; if (d == -1123) &#123; printf_s("%s\n", msg); &#125; else &#123; printf_s("%s %d \n", msg ,d); &#125;&#125; int video2YuvAndH264(const char * filePath,FILE * yuvFilePath, FILE * h264FilePath)&#123; AVFormatContext * pFmtCtx = NULL; AVCodecContext *pCodecCtx = NULL; AVFrame *pFrame = NULL; AVFrame *pFrameYUV = NULL; uint8_t *outBuffer = NULL; AVPacket *pPacket = NULL; SwsContext *pSwsCtx = NULL; //1. 初始化 init(); //2. AVFormatContext获取 pFmtCtx = avformat_alloc_context(); //3. 打开文件 if (avformat_open_input(&amp;pFmtCtx,filePath,NULL,NULL)!=0) &#123; log("Couldn't open input stream.\n"); return -1; &#125; //4. 获取文件信息 if (avformat_find_stream_info(pFmtCtx,NULL)&lt;0) &#123; log("Couldn't find stream information."); return -1; &#125; //5. 获取视频的index int i = 0,videoIndex =-1; for (; i &lt; pFmtCtx-&gt;nb_streams; i++) &#123; if (pFmtCtx-&gt;streams[i]-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO) &#123; videoIndex = i; break; &#125; &#125; if (videoIndex == -1) &#123; log("Didn't find a video stream."); return -1; &#125; //6. 获取解码器并打开 pCodecCtx = avcodec_alloc_context3(NULL); if (avcodec_parameters_to_context(pCodecCtx, pFmtCtx-&gt;streams[videoIndex]-&gt;codecpar) &lt; 0) &#123; log("Didn't parameters to contex."); return -1; &#125; AVCodec *pCodec = avcodec_find_decoder(pCodecCtx-&gt;codec_id); if (pCodec == NULL) &#123; log("Codec not found."); return -1; &#125; if (avcodec_open2(pCodecCtx, pCodec, NULL)&lt;0) &#123;//打开解码器 log("Could not open codec."); return -1; &#125; //7. 解码开始准备工作 pFrame = av_frame_alloc(); pFrameYUV = av_frame_alloc(); //根据需要解码的类型，获取需要的buffer，不要忘记free outBuffer = (uint8_t *)av_malloc(av_image_get_buffer_size(AV_PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;height, 1)*sizeof(uint8_t)); //根据指定的图像参数和提供的数组设置数据指针和行数 ，数据填充到对应的pFrameYUV里面 av_image_fill_arrays(pFrameYUV-&gt;data, pFrameYUV-&gt;linesize, outBuffer, AV_PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;height,1); pPacket = av_packet_alloc(); log("--------------- File Information ----------------"); av_dump_format(pFmtCtx, 0, filePath, 0); log("-------------------------------------------------"); //获取SwsContext pSwsCtx = sws_getContext(pCodecCtx-&gt;width, pCodecCtx-&gt;height, pCodecCtx-&gt;pix_fmt, pCodecCtx-&gt;width, pCodecCtx-&gt;height, AV_PIX_FMT_YUV420P, NULL, NULL, NULL, NULL); int count=0; //8. 读取数据 while (av_read_frame(pFmtCtx, pPacket) == 0) &#123;//读取一帧压缩数据 if (pPacket-&gt;stream_index == videoIndex) &#123; //写入H264数据到文件 fwrite(pPacket-&gt;data, 1, pPacket-&gt;size, h264FilePath); //把H264数据写入h264FilePath文件 //解码数据 //avcodec_decode_video2(pCodecCtx, pFrame, &amp;frameFinished, pPacket); if (avcodec_send_packet(pCodecCtx, pPacket) != 0) &#123;//解码一帧压缩数据 log("Decode end or Error.\n"); break; &#125;else &#123;//处理解码数据并写入文件 avcodec_receive_frame(pCodecCtx,pFrame); if (sws_scale(pSwsCtx, (const uint8_t* const*)pFrame-&gt;data, pFrame-&gt;linesize, 0, pCodecCtx-&gt;height, pFrameYUV-&gt;data, pFrameYUV-&gt;linesize) == 0) &#123; continue; &#125; count++; int y_size = pCodecCtx-&gt;width*pCodecCtx-&gt;height; fwrite(pFrameYUV-&gt;data[0], 1, y_size, yuvFilePath); //Y fwrite(pFrameYUV-&gt;data[1], 1, y_size / 4, yuvFilePath); //U fwrite(pFrameYUV-&gt;data[2], 1, y_size / 4, yuvFilePath); //V log("Succeed to decode frame!",count); &#125; &#125; av_packet_unref(pPacket); &#125; //flush decoder /*当av_read_frame()循环退出的时候，实际上解码器中可能还包含剩余的几帧数据。 因此需要通过“flush_decoder”将这几帧数据输出。 “flush_decoder”功能简而言之即直接调用avcodec_decode_video2()获得AVFrame，而不再向解码器传递AVPacket。*/ while (1) &#123; if (avcodec_send_packet(pCodecCtx, pPacket)!= 0) &#123; log("Decode end or Error.\n"); break; &#125; else &#123; avcodec_receive_frame(pCodecCtx, pFrame); sws_scale(pSwsCtx, (const unsigned char *const *)pFrame-&gt;data, pFrame-&gt;linesize, 0, pCodecCtx-&gt;height, pFrameYUV-&gt;data, pFrameYUV-&gt;linesize); int y_size = pCodecCtx-&gt;width * pCodecCtx-&gt;height; // yuv-&gt; 4:1:1 fwrite(pFrameYUV-&gt;data[0], 1, static_cast&lt;size_t&gt;(y_size), yuvFilePath); //Y fwrite(pFrameYUV-&gt;data[1], 1, static_cast&lt;size_t&gt;(y_size / 4), yuvFilePath); //U fwrite(pFrameYUV-&gt;data[2], 1, static_cast&lt;size_t&gt;(y_size / 4), yuvFilePath); //V log("Flush Decoder: Succeed to decode frame!", count); &#125; &#125; if (pSwsCtx != NULL) &#123; sws_freeContext(pSwsCtx); &#125; if (outBuffer != NULL) &#123; av_free(outBuffer); &#125; if (pFrameYUV != NULL) &#123; av_frame_free(&amp;pFrameYUV); &#125; if (pFrame != NULL) &#123; av_frame_free(&amp;pFrame); &#125; if (pCodecCtx != NULL) &#123; avcodec_close(pCodecCtx); &#125; if (pFmtCtx != NULL) &#123; avformat_close_input(&amp;pFmtCtx); &#125;&#125;int main()&#123; FILE * yuvFile; FILE * h264File; fopen_s(&amp; yuvFile,"F:/视频资源/gxsp.yuv", "wb+"); fopen_s(&amp; h264File,"F:/视频资源/gxsp.h264", "wb+"); video2YuvAndH264("F:/视频资源/gxsp.mp4", yuvFile, h264File); fclose(yuvFile); fclose(h264File); getchar(); return 0;&#125; 在Android上进行视频解码 参考链接: https://blog.csdn.net/king1425/article/details/71160339]]></content>
      <categories>
        <category>ffmpeg</category>
      </categories>
      <tags>
        <tag>音视频</tag>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ffmpeg android 推送RTMP]]></title>
    <url>%2Fffmpeg%20%20android%20%E6%8E%A8%E9%80%81RTMP.html</url>
    <content type="text"><![CDATA[Nginx 搭建RTMP服务器 android端代码以及步骤123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161static int publish_file_stream(const char *input, const char *output) &#123;//注意这里要写=NULL 不然会崩溃 AVFormatContext *pInAvFormatContext = NULL; AVFormatContext *pOutAvFormatContext = NULL; AVOutputFormat *pAvOutputFormat = NULL; int videoIndex = 0; //1. 注册 av_register_all(); LOGE("%s", output); //2. 获取输入的文件信息 //打开文件 if (avformat_open_input(&amp;pInAvFormatContext, input, NULL, NULL) != 0) &#123; LOGE("打开文件失败!"); return -1; &#125; //获取流信息 if (avformat_find_stream_info(pInAvFormatContext, NULL) &lt; 0) &#123; LOGE("获取文件流失败!"); return -1; &#125; //找到video的对应位置 int i = 0; for (; i &lt; pInAvFormatContext-&gt;nb_streams; i++) &#123; if (pInAvFormatContext-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO) &#123; videoIndex = i; break; &#125; &#125; //打印信息// av_dump_format(pAvFormatContext,0,input,0); //3. 输出设置 //初始化输出AVFormatContext获取 AVOutputFormat进行设置 avformat_alloc_output_context2(&amp;pOutAvFormatContext, NULL, "flv", output); if (!pOutAvFormatContext) &#123; LOGE("初始化输出AVFormatContext失败"); return -1; &#125; pAvOutputFormat = pOutAvFormatContext-&gt;oformat; i = 0; for (; i &lt; pInAvFormatContext-&gt;nb_streams; i++) &#123; AVStream *in_stream = pInAvFormatContext-&gt;streams[i]; AVStream *out_stream = avformat_new_stream(pOutAvFormatContext, in_stream-&gt;codec-&gt;codec); if (!out_stream) &#123; LOGE("初始化out_stream失败"); return -1; &#125; //复制AVCodecContext的设置（Copy the settings of AVCodecContext） if (avcodec_copy_context(out_stream-&gt;codec, in_stream-&gt;codec) != 0) &#123; LOGE("copy AVCodecContext设置失败"); return -1; &#125; out_stream-&gt;codec-&gt;codec_tag = 0; if (pOutAvFormatContext-&gt;oformat-&gt;flags &amp; AVFMT_GLOBALHEADER) out_stream-&gt;codec-&gt;flags |= CODEC_FLAG_GLOBAL_HEADER; &#125; //打印// av_dump_format(pOutAvFormatContext,0,output,0); //打开输出文件/url if (!(pAvOutputFormat-&gt;flags &amp; AVFMT_NOFILE)) &#123; int ret = avio_open(&amp;pOutAvFormatContext-&gt;pb, output, AVIO_FLAG_WRITE); if (ret &lt; 0) &#123; LOGE("打开输出文件或者url失败 %d", ret); return -1; &#125; &#125; //4.写入数据 //写文件头 if (avformat_write_header(pOutAvFormatContext, NULL) != 0) &#123; LOGE("写入头数据失败"); return -1; &#125; int64_t start_time = av_gettime(); AVPacket pkt; int frameIndex = 0; //写入数据源 while (av_read_frame(pInAvFormatContext, &amp;pkt) &gt;= 0) &#123; AVStream *in_stream, *out_stream; if (pkt.pts == AV_NOPTS_VALUE) &#123; //Write PTS AVRational time_base1 = pInAvFormatContext-&gt;streams[videoIndex]-&gt;time_base; //Duration between 2 frames (us) int64_t calc_duration = (double) AV_TIME_BASE / av_q2d(pInAvFormatContext-&gt;streams[videoIndex]-&gt;r_frame_rate); //Parameters pkt.pts = (double) (frameIndex * calc_duration) / (double) (av_q2d(time_base1) * AV_TIME_BASE); pkt.dts = pkt.pts; pkt.duration = (double) calc_duration / (double) (av_q2d(time_base1) * AV_TIME_BASE); &#125; //Important:Delay if (pkt.stream_index == videoIndex) &#123; AVRational time_base = pInAvFormatContext-&gt;streams[videoIndex]-&gt;time_base; AVRational time_base_q = &#123;1, AV_TIME_BASE&#125;; int64_t pts_time = av_rescale_q(pkt.dts, time_base, time_base_q); int64_t now_time = av_gettime() - start_time; if (pts_time &gt; now_time) av_usleep(pts_time - now_time); &#125; in_stream = pInAvFormatContext-&gt;streams[pkt.stream_index]; out_stream = pOutAvFormatContext-&gt;streams[pkt.stream_index]; /* copy packet */ //转换PTS/DTS（Convert PTS/DTS） pkt.pts = av_rescale_q_rnd(pkt.pts, in_stream-&gt;time_base, out_stream-&gt;time_base, (AVRounding) (AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX)); pkt.dts = av_rescale_q_rnd(pkt.dts, in_stream-&gt;time_base, out_stream-&gt;time_base, (AVRounding) (AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX)); pkt.duration = av_rescale_q(pkt.duration, in_stream-&gt;time_base, out_stream-&gt;time_base); pkt.pos = -1; //Print to Screen if (pkt.stream_index == videoIndex) &#123; LOGE("Send %8d video frames to output URL\n", frameIndex); frameIndex++; &#125; if (av_interleaved_write_frame(pOutAvFormatContext, &amp;pkt) &lt; 0) &#123; LOGE("Error muxing packet\n"); break; &#125; av_packet_unref(&amp;pkt); &#125; //写文件尾（Write file trailer） av_write_trailer(pOutAvFormatContext); avformat_close_input(&amp;pInAvFormatContext); /* close output */ if (pOutAvFormatContext &amp;&amp; !(pAvOutputFormat-&gt;flags &amp; AVFMT_NOFILE)) avio_close(pOutAvFormatContext-&gt;pb); avformat_free_context(pOutAvFormatContext); return 0;&#125;JNIEXPORT jint JNICALLJava_zzw_com_ffmpegdemo_VideoUtils_publish_1file_1stream(JNIEnv *env, jclass type, jstring input_, jstring output_) &#123; const char *input = env-&gt;GetStringUTFChars(input_, 0); const char *output = env-&gt;GetStringUTFChars(output_, 0); //input: /storage/emulated/0/aaaaa/dst.mp4 //output: rtmp://192.168.18.231:8082/live/room int ret = publish_file_stream(input, output); env-&gt;ReleaseStringUTFChars(input_, input); env-&gt;ReleaseStringUTFChars(output_, output); return ret;&#125; 参考连接： https://blog.csdn.net/leixiaohua1020/article/details/39803457]]></content>
      <categories>
        <category>ffmpeg</category>
      </categories>
      <tags>
        <tag>音视频</tag>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ffmpeg android音频解码]]></title>
    <url>%2Fffmpeg%20android%E9%9F%B3%E9%A2%91%E8%A7%A3%E7%A0%81.html</url>
    <content type="text"><![CDATA[音频解码就是将mp3 aac等格式这些文件解析为pcm格式的过程。和视频解码流程一样，只是有些函数不一样123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169#include "lang.h";#include &lt;string&gt;//封装格式//解码#include "log.h"extern "C" &#123;#include &lt;libswresample/swresample.h&gt;#include &lt;libavutil/imgutils.h&gt;#include &lt;libavutil/samplefmt.h&gt;#include &lt;libavutil/timestamp.h&gt;#include &lt;libavformat/avformat.h&gt;#include &lt;libswscale/swscale.h&gt;&#125;;#define MAX_AUDIO_FRAME_SIZE 192000 // 1 second of 48khz 32bit audiostatic int audio_decode_example(const char *input, const char *output) &#123; AVCodec *pCodec; AVCodecContext *pCodecContext; AVFormatContext *pFormatContext; struct SwrContext *au_convert_ctx; uint8_t *out_buffer; //1. 注册 av_register_all(); //2.打开解码器 &lt;-- 拿到解码器 &lt;-- 拿到id &lt;-- 拿到stream和拿到AVCodecContext &lt;-- 拿到AVFormatContext //2.1 拿到AVFormatContext pFormatContext = avformat_alloc_context(); //2.1.1 打开文件 if (avformat_open_input(&amp;pFormatContext, input, NULL, NULL) != 0) &#123; LOGE("打开文件失败!"); return -1; &#125; //2.2 拿到AVCodecContext //2.2.1 拿到流信息 if (avformat_find_stream_info(pFormatContext, NULL) &lt; 0) &#123; LOGE("AVFormatContext获取流信息失败!"); return -1; &#125; //打印信息// av_dump_format(pFormatContext, 0, input, false); //2.2.2 通过streams找到audio的索引下标 也就获取到了stream int audioStream = -1; int i = 0; for (; i &lt; pFormatContext-&gt;nb_streams; i++) if (pFormatContext-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_AUDIO) &#123; audioStream = i; break; &#125; if (audioStream == -1) &#123; LOGE("AVMEDIA_TYPE_AUDIO索引没找到!"); return -1; &#125; //2.2.3 获取到AVCodecContext pCodecContext = pFormatContext-&gt;streams[audioStream]-&gt;codec; //2.2.4 通过AVCodecContext拿到id ，拿到解码器 pCodec = avcodec_find_decoder(pCodecContext-&gt;codec_id); if (pCodec == NULL) &#123; LOGE("AVCodec获取失败!"); return -1; &#125; //2.2.5 打开解码器 if (avcodec_open2(pCodecContext, pCodec, NULL) &lt; 0) &#123; LOGE("打开解码器失败!"); return -1; &#125; //3. 解码 将解码数据封装在AVFrame &lt;-- 拿到编码的数据AVPacket &lt;-- 读取数据源 &lt;-- 解码文件参数设置 //3.1 AVPacket初始化 AVPacket *packet = (AVPacket *) av_malloc(sizeof(AVPacket)); av_init_packet(packet); //3.2 解码文件参数设置 uint64_t out_channel_layout = AV_CH_LAYOUT_STEREO; //nb_samples: AAC-1024 MP3-1152 //音频帧中每个声道的采样数 int out_nb_samples = pCodecContext-&gt;frame_size; //音频采样格式 量化精度 AVSampleFormat out_sample_fmt = AV_SAMPLE_FMT_S16; //采样率 int out_sample_rate = 44100; //声道 int out_channels = av_get_channel_layout_nb_channels(out_channel_layout); //获取到 缓冲大小 int out_buffer_size = av_samples_get_buffer_size(NULL, out_channels, out_nb_samples, out_sample_fmt, 1); out_buffer = (uint8_t *) av_malloc(MAX_AUDIO_FRAME_SIZE * 2); //3.3 初始化AVFrame AVFrame *pFrame = av_frame_alloc(); //3.4 获取到编码文件的参数信息 //声道 int64_t in_channel_layout = av_get_default_channel_layout(pCodecContext-&gt;channels); //3.5 参数设置 au_convert_ctx = swr_alloc(); au_convert_ctx = swr_alloc_set_opts(au_convert_ctx, out_channel_layout, out_sample_fmt, out_sample_rate, in_channel_layout, pCodecContext-&gt;sample_fmt, pCodecContext-&gt;sample_rate, 0, NULL); swr_init(au_convert_ctx); //4. 读取编码数据到AVPacket 然后将数据解码存储到AVFrame 转换存储数据 //4.1 读取编码数据到AVPacket int got_picture; int index = 0; FILE *outputFile = fopen(output, "wb"); while (av_read_frame(pFormatContext, packet) &gt;= 0) &#123; if (packet-&gt;stream_index == audioStream) &#123; //4.2 将数据解码存储到AVFrame if (avcodec_decode_audio4(pCodecContext, pFrame, &amp;got_picture, packet) &lt; 0) &#123; LOGE("解码失败"); return -1; &#125; if (got_picture &gt; 0) &#123; //4.3 转换音频数据 swr_convert(au_convert_ctx, &amp;out_buffer, MAX_AUDIO_FRAME_SIZE, (const uint8_t **) pFrame-&gt;data, pFrame-&gt;nb_samples); LOGE("index:%5d\t pts:%lld\t packet size:%d\n",index,packet-&gt;pts,packet-&gt;size); //4.4 存储数据 fwrite(out_buffer, 1, static_cast&lt;size_t&gt;(out_buffer_size), outputFile); index++; &#125; &#125; //5. 释放相关资源 av_packet_unref(packet); &#125; swr_free(&amp;au_convert_ctx); fclose(outputFile); av_free(out_buffer); // Close the codec avcodec_close(pCodecContext); // Close the video file avformat_close_input(&amp;pFormatContext); return 0;&#125;extern "C"JNIEXPORT jint JNICALLJava_zzw_com_ffmpegdemo_VideoUtils_audio_1decode(JNIEnv *env, jclass type, jstring input_, jstring output_) &#123; const char *input = env-&gt;GetStringUTFChars(input_, 0); const char *output = env-&gt;GetStringUTFChars(output_, 0); int flog = audio_decode_example(input, output); env-&gt;ReleaseStringUTFChars(input_, input); env-&gt;ReleaseStringUTFChars(output_, output); return flog;&#125; 参考地址:https://blog.csdn.net/leixiaohua1020/article/details/46890259]]></content>
      <categories>
        <category>ffmpeg</category>
      </categories>
      <tags>
        <tag>音视频</tag>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ffmpeg android视频解码]]></title>
    <url>%2Fffmpeg-android%E8%A7%86%E9%A2%91%E8%A7%A3%E7%A0%81.html</url>
    <content type="text"><![CDATA[解码流程: 获取文件信息,数据存储在AVFormatContext里面 根据AVFormatContext获取对应的AVCodecContext 解码原始数据AVPacket，解码为自己需要的数据AVFrame 释放相关资源 (图片来源于网络) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173#include "lang.h"#include &lt;string&gt;//封装格式//解码#include "log.h"extern "C" &#123;#include &lt;libavutil/imgutils.h&gt;#include &lt;libavutil/samplefmt.h&gt;#include &lt;libavutil/timestamp.h&gt;#include &lt;libavformat/avformat.h&gt;#include &lt;libswscale/swscale.h&gt;&#125;;static void video_decode_example(const char *outfilename, const char *filename) &#123; //1.注册 av_register_all(); AVFormatContext *pFormatCtx = NULL; //2. 打开文件 if (avformat_open_input(&amp;pFormatCtx, filename, NULL, NULL) != 0) &#123; LOGE ("打开文件失败"); return; &#125; //3. 获取流信息，数据封装在AVFormatContext里面 if (avformat_find_stream_info(pFormatCtx, NULL) &lt; 0) &#123; LOGE ("获取流信息失败"); return; &#125; //只输出输入文件的格式信息 av_dump_format(pFormatCtx, 0, filename, 0); int video_index = -1; //4. 从流中遍历获取video的index for (int i = 0; i &lt; pFormatCtx-&gt;nb_streams; i++) &#123; if (pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO) &#123; video_index = i; LOGE ("video_index = %d", video_index); break; &#125; &#125; if (video_index == -1) &#123; LOGE ("遍历获取video_index失败"); return; &#125; AVCodecContext *pCodecCtxOrg = NULL; AVCodecContext *pCodecCtx = NULL; AVCodec *pCodec = NULL; //5. 解码器获取 //5.1 根据video_index获取解码器上下文AVCodecContext pCodecCtxOrg = pFormatCtx-&gt;streams[video_index]-&gt;codec; // codec context //5.1 根据AVCodecContext获取解码器 pCodec = avcodec_find_decoder(pCodecCtxOrg-&gt;codec_id); if (!pCodec) &#123; LOGE ("解码器获取失败"); return; &#125; //6.获取一个AVCodecContext实例，并将第五步获取的AVCodecContext数据copy过来，解码的时候需要用这个 pCodecCtx = avcodec_alloc_context3(pCodec); if (avcodec_copy_context(pCodecCtx, pCodecCtxOrg) != 0) &#123; LOGE ("解码器上下文数据copy失败"); return; &#125; //7. 打开解码器 if (avcodec_open2(pCodecCtx, pCodec, NULL) &lt; 0) &#123; LOGE ("打开解码器失败"); return; &#125; //原始数据帧 AVFrame *pFrame = NULL; //yuv数据帧 AVFrame *pFrameYUV = NULL; //内存开辟 不要忘记free pFrame = av_frame_alloc(); pFrameYUV = av_frame_alloc(); int numBytes = 0; uint8_t *buffer = NULL; //根据需要解码的类型，获取需要的buffer，不要忘记free numBytes = av_image_get_buffer_size(AV_PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;height, 1); buffer = (uint8_t *) av_malloc(numBytes * sizeof(uint8_t)); //根据指定的图像参数和提供的数组设置数据指针和行数 ，数据填充到对应的pFrameYUV里面 av_image_fill_arrays(pFrameYUV-&gt;data, pFrameYUV-&gt;linesize, buffer, AV_PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;height, 1); //获取SwsContext struct SwsContext *sws_ctx = NULL; sws_ctx = sws_getContext(pCodecCtx-&gt;width, pCodecCtx-&gt;height, pCodecCtx-&gt;pix_fmt, pCodecCtx-&gt;width, pCodecCtx-&gt;height, AV_PIX_FMT_YUV420P, SWS_BICUBIC, NULL, NULL, NULL); FILE *pFile = fopen(outfilename, "wb+"); int ret; AVPacket packet; int frameFinished = 0; //8. 根据AVFormatContext 读取帧数据，读取的编码数据存储到AVPacket里面 while (av_read_frame(pFormatCtx, &amp;packet) &gt;= 0) &#123; if (packet.stream_index == video_index) &#123; //9. 将读取到的AVPacket，转换为AVFrame ret = avcodec_decode_video2(pCodecCtx, pFrame, &amp;frameFinished, &amp;packet); if (ret &lt; 0) &#123; LOGE("解码失败"); return; &#125; if (frameFinished) &#123; //10. 将原始的AVFrame数据转换为自己需要的YUV AVFrame数据 sws_scale(sws_ctx, (uint8_t const *const *) pFrame-&gt;data, pFrame-&gt;linesize, 0, pCodecCtx-&gt;height, pFrameYUV-&gt;data, pFrameYUV-&gt;linesize); //11. 根据YUV AVFrame数据保存文件 if (pFile == NULL) return; int y_size = pCodecCtx-&gt;width * pCodecCtx-&gt;height; //yuv420 存储为4:1:1 fwrite(pFrame-&gt;data[0], 1, static_cast&lt;size_t&gt;(y_size), pFile); //y fwrite(pFrame-&gt;data[1], 1, static_cast&lt;size_t&gt;(y_size / 4), pFile);//u fwrite(pFrame-&gt;data[2], 1, static_cast&lt;size_t&gt;(y_size / 4), pFile);//v &#125; &#125; av_packet_unref(&amp;packet); &#125; //flush decoder //FIX: Flush Frames remained in Codec //12. 刷新解码器 while (1) &#123; ret = avcodec_decode_video2(pCodecCtx, pFrame, &amp;frameFinished, &amp;packet); if (ret &lt; 0) break; if (!frameFinished) break; sws_scale(sws_ctx, (const unsigned char *const *) pFrame-&gt;data, pFrame-&gt;linesize, 0, pCodecCtx-&gt;height, pFrameYUV-&gt;data, pFrameYUV-&gt;linesize); int y_size = pCodecCtx-&gt;width * pCodecCtx-&gt;height; fwrite(pFrameYUV-&gt;data[0], 1, static_cast&lt;size_t&gt;(y_size), pFile); //Y fwrite(pFrameYUV-&gt;data[1], 1, static_cast&lt;size_t&gt;(y_size / 4), pFile); //U fwrite(pFrameYUV-&gt;data[2], 1, static_cast&lt;size_t&gt;(y_size / 4), pFile); //V LOGE("Flush Decoder: Succeed to decode 1 frame!\n"); &#125; //release resource sws_freeContext(sws_ctx); fclose(pFile); av_free(buffer); av_frame_free(&amp;pFrameYUV); av_frame_free(&amp;pFrame); avcodec_close(pCodecCtx); avcodec_close(pCodecCtxOrg); avformat_close_input(&amp;pFormatCtx);&#125;extern "C"JNIEXPORT jint JNICALLJava_zzw_com_ffmpegdemo_VideoUtils_decode(JNIEnv *env, jclass type, jstring input_, jstring output_) &#123; const char *input_file_name = env-&gt;GetStringUTFChars(input_, 0); const char *output_file_name = env-&gt;GetStringUTFChars(output_, 0); video_decode_example(output_file_name, input_file_name); env-&gt;ReleaseStringUTFChars(input_, input_file_name); env-&gt;ReleaseStringUTFChars(output_, output_file_name); return 0;&#125; 总结: 要解码，我们需要获取解码器AVCodec,解码器我们需要通过codec_id获取，codec_id我们需要通过AVStream获取，AVStream我们需要通过AVCodecContext获取，AVCodecContext我们要根据AVFormatContext获取,解码的时候我们要通过AVFormatContext读取，解码数据存储在AVFrame里面,编码数据存储在AVPacket里面。 参考:https://blog.csdn.net/leixiaohua1020/article/details/46889389https://blog.csdn.net/u011913612/article/details/53419986]]></content>
      <categories>
        <category>ffmpeg</category>
      </categories>
      <tags>
        <tag>音视频</tag>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ffmpeg编译]]></title>
    <url>%2Fffmpeg%E7%BC%96%E8%AF%91.html</url>
    <content type="text"><![CDATA[环境 云主机 Centos 7 x86_64 bbr系统 ffmpeg-3.0.11库 android-ndk-r13b ndk安装1234//下载wget https://dl.google.com/android/repository/android-ndk-r13b-linux-x86_64.zip//解压unzip android-ndk-r13b-linux-x86_64.zip ndk个版本下载地址选择：https://blog.csdn.net/shuzfan/article/details/52690554 2.配置环境变量并为ndk授权 12345678910111213141516//进入当前用户根目录cd ~ //编辑vim ~/.bashrc//编辑 ndk为例export NDKROOT=/usr/ndk/android-ndk-r13bexport PATH=$NDKROOT:$PATH//更新环境变量source ~/.bashrc//授权chmod 777 -R /usr/ndk 3.下载ffmpge，解压授权123456//下载wget http://ffmpeg.org/releases/ffmpeg-3.0.11.tar.gz//解压tar zxvf ffmpeg-3.0.11.tar.gz//授权chmod 777 -R /usr/zzw/ffmpeg-3.0.11 ffmpeg各版本下载地址:http://ffmpeg.org/download.html 根目录创建ffmpegtemp文件夹，配置脚本build_android.sh,config我是windows+xftp的方式4.1 在windows上新建build_android.sh,并书写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#!/bin/bashexport TMPDIR=/usr/zzw/ffmpeg-3.0.11/ffmpegtempNDK=/usr/ndk/android-ndk-r13bPLATFORM=$NDK/platforms/android-14/arch-arm/TOOLCHAIN=$NDK/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64function build_one&#123;./configure \ --prefix=$PREFIX \ --target-os=linux \ --cross-prefix=$TOOLCHAIN/bin/arm-linux-androideabi- \ --arch=arm \ --sysroot=$PLATFORM \ --extra-cflags=&quot;-I$PLATFORM/usr/include&quot; \ --cc=$TOOLCHAIN/bin/arm-linux-androideabi-gcc \ --nm=$TOOLCHAIN/bin/arm-linux-androideabi-nm \ --enable-shared \ --enable-runtime-cpudetect \ --enable-gpl \ --enable-small \ --enable-cross-compile \ --disable-debug \ --disable-static \ --disable-doc \ --disable-asm \ --disable-ffmpeg \ --disable-ffplay \ --disable-ffprobe \ --disable-ffserver \ --disable-postproc \ --disable-avdevice \ --disable-symver \ --disable-stripping \ $ADDITIONAL_CONFIGURE_FLAGsed -i &apos;&apos; &apos;s/HAVE_LRINT 0/HAVE_LRINT 1/g&apos; config.hsed -i &apos;&apos; &apos;s/HAVE_LRINTF 0/HAVE_LRINTF 1/g&apos; config.hsed -i &apos;&apos; &apos;s/HAVE_ROUND 0/HAVE_ROUND 1/g&apos; config.hsed -i &apos;&apos; &apos;s/HAVE_ROUNDF 0/HAVE_ROUNDF 1/g&apos; config.hsed -i &apos;&apos; &apos;s/HAVE_TRUNC 0/HAVE_TRUNC 1/g&apos; config.hsed -i &apos;&apos; &apos;s/HAVE_TRUNCF 0/HAVE_TRUNCF 1/g&apos; config.hsed -i &apos;&apos; &apos;s/HAVE_CBRT 0/HAVE_CBRT 1/g&apos; config.hsed -i &apos;&apos; &apos;s/HAVE_RINT 0/HAVE_RINT 1/g&apos; config.hmake cleanmake -j4make install&#125;# arm v7vfpCPU=armv7-aOPTIMIZE_CFLAGS=&quot;-mfloat-abi=softfp -mfpu=vfp -marm -march=$CPU &quot;PREFIX=./android/$CPU-vfpADDITIONAL_CONFIGURE_FLAG=build_one# CPU=armv# PREFIX=$(pwd)/android/$CPU# ADDI_CFLAGS=&quot;-marm&quot;# build_one#arm v6#CPU=armv6#OPTIMIZE_CFLAGS=&quot;-marm -march=$CPU&quot;#PREFIX=./android/$CPU #ADDITIONAL_CONFIGURE_FLAG=#build_one#arm v7vfpv3# CPU=armv7-a# OPTIMIZE_CFLAGS=&quot;-mfloat-abi=softfp -mfpu=vfpv3-d16 -marm -march=$CPU &quot;# PREFIX=./android/$CPU# ADDITIONAL_CONFIGURE_FLAG=# build_one#arm v7n#CPU=armv7-a#OPTIMIZE_CFLAGS=&quot;-mfloat-abi=softfp -mfpu=neon -marm -march=$CPU -mtune=cortex-a8&quot;#PREFIX=./android/$CPU #ADDITIONAL_CONFIGURE_FLAG=--enable-neon#build_one#arm v6+vfp#CPU=armv6#OPTIMIZE_CFLAGS=&quot;-DCMP_HAVE_VFP -mfloat-abi=softfp -mfpu=vfp -marm -march=$CPU&quot;#PREFIX=./android/$&#123;CPU&#125;_vfp #ADDITIONAL_CONFIGURE_FLAG=#build_one 注意”\“后面不要放空格 4.2 使用xftp传输到云主机的ffmpeg解压根目录，并将该文件改为linux的编码12345vim build_android.sh#vim下执行:set ff=unix:wq 4.3 修改configure 12345678910111213#这段脚本的作用是使生成的静态库为.so为后缀，生成的库是这种格式:libavcodec-57.so ... #不加的话生成的库是这种格式:libavcodec.so.57 ...等等 #注释以下内容#SLIBNAME_WITH_MAJOR=&apos;$(SLIBNAME).$(LIBMAJOR)&apos;#LIB_INSTALL_EXTRA_CMD=&apos;$$(RANLIB) &quot;$(LIBDIR)/$(LIBNAME)&quot;&apos;#SLIB_INSTALL_NAME=&apos;$(SLIBNAME_WITH_VERSION)&apos;#SLIB_INSTALL_LINKS=&apos;$(SLIBNAME_WITH_MAJOR) $(SLIBNAME)&apos;#增加以下内容SLIBNAME_WITH_MAJOR=&apos;$(SLIBPREF)$(FULLNAME)-$(LIBMAJOR)$(SLIBSUF)&apos;LIB_INSTALL_EXTRA_CMD=&apos;$$(RANLIB)&quot;$(LIBDIR)/$(LIBNAME)&quot;&apos;SLIB_INSTALL_NAME=&apos;$(SLIBNAME_WITH_MAJOR)&apos;SLIB_INSTALL_LINKS=&apos;$(SLIBNAME)&apos; 执行脚本1./build_android.sh 6.上面生成的是so动态库，生成.a静态库只需在build_android.sh修改如下:12--enable-static \--disable-shared \ 7.生成一个库,在第6步生成静态库.a文件下，在build_android.sh的函数build_one添加如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#!/bin/bashexport TMPDIR=/usr/zzw/ffmpeg-3.0.11/ffmpegtempNDK=/usr/ndk/android-ndk-r13bPLATFORM=$NDK/platforms/android-14/arch-arm/TOOLCHAIN=$NDK/toolchains/arm-linux-androideabi-4.9/prebuilt/linux-x86_64function build_one&#123;./configure \ --prefix=$PREFIX \ --target-os=linux \ --cross-prefix=$TOOLCHAIN/bin/arm-linux-androideabi- \ --arch=arm \ --sysroot=$PLATFORM \ --extra-cflags=&quot;-I$PLATFORM/usr/include&quot; \ --cc=$TOOLCHAIN/bin/arm-linux-androideabi-gcc \ --nm=$TOOLCHAIN/bin/arm-linux-androideabi-nm \ --enable-static \ --enable-runtime-cpudetect \ --enable-gpl \ --enable-small \ --enable-cross-compile \ --disable-debug \ --disable-shared \ --disable-doc \ --disable-asm \ --disable-ffmpeg \ --disable-ffplay \ --disable-ffprobe \ --disable-ffserver \ --disable-postproc \ --disable-avdevice \ --disable-symver \ --disable-stripping \$ADDITIONAL_CONFIGURE_FLAGsed -i &apos;&apos; &apos;s/HAVE_LRINT 0/HAVE_LRINT 1/g&apos; config.hsed -i &apos;&apos; &apos;s/HAVE_LRINTF 0/HAVE_LRINTF 1/g&apos; config.hsed -i &apos;&apos; &apos;s/HAVE_ROUND 0/HAVE_ROUND 1/g&apos; config.hsed -i &apos;&apos; &apos;s/HAVE_ROUNDF 0/HAVE_ROUNDF 1/g&apos; config.hsed -i &apos;&apos; &apos;s/HAVE_TRUNC 0/HAVE_TRUNC 1/g&apos; config.hsed -i &apos;&apos; &apos;s/HAVE_TRUNCF 0/HAVE_TRUNCF 1/g&apos; config.hsed -i &apos;&apos; &apos;s/HAVE_CBRT 0/HAVE_CBRT 1/g&apos; config.hsed -i &apos;&apos; &apos;s/HAVE_RINT 0/HAVE_RINT 1/g&apos; config.hmake cleanmake -j4make install# 增加的内容$TOOLCHAIN/bin/arm-linux-androideabi-ld \-rpath-link=$PLATFORM/usr/lib \-L$PLATFORM/usr/lib \-L$PREFIX/lib \-soname libffmpeg.so -shared -nostdlib -Bsymbolic --whole-archive --no-undefined -o \$PREFIX/libffmpeg.so \ libavcodec/libavcodec.a \ libavfilter/libavfilter.a \ libswresample/libswresample.a \ libavformat/libavformat.a \ libavutil/libavutil.a \ libswscale/libswscale.a \ -lc -lm -lz -ldl -llog --dynamic-linker=/system/bin/linker \ $TOOLCHAIN/lib/gcc/arm-linux-androideabi/4.9.x/libgcc.a \&#125;# arm v7vfpCPU=armv7-aOPTIMIZE_CFLAGS=&quot;-mfloat-abi=softfp -mfpu=vfp -marm -march=$CPU &quot;PREFIX=./android/$CPU-vfpADDITIONAL_CONFIGURE_FLAG=build_one# CPU=armv# PREFIX=$(pwd)/android/$CPU# ADDI_CFLAGS=&quot;-marm&quot;# build_one#arm v6#CPU=armv6#OPTIMIZE_CFLAGS=&quot;-marm -march=$CPU&quot;#PREFIX=./android/$CPU #ADDITIONAL_CONFIGURE_FLAG=#build_one#arm v7vfpv3# CPU=armv7-a# OPTIMIZE_CFLAGS=&quot;-mfloat-abi=softfp -mfpu=vfpv3-d16 -marm -march=$CPU &quot;# PREFIX=./android/$CPU# ADDITIONAL_CONFIGURE_FLAG=# build_one#arm v7n#CPU=armv7-a#OPTIMIZE_CFLAGS=&quot;-mfloat-abi=softfp -mfpu=neon -marm -march=$CPU -mtune=cortex-a8&quot;#PREFIX=./android/$CPU #ADDITIONAL_CONFIGURE_FLAG=--enable-neon#build_one#arm v6+vfp#CPU=armv6#OPTIMIZE_CFLAGS=&quot;-DCMP_HAVE_VFP -mfloat-abi=softfp -mfpu=vfp -marm -march=$CPU&quot;#PREFIX=./android/$&#123;CPU&#125;_vfp #ADDITIONAL_CONFIGURE_FLAG=#build_one 8.具体要编译哪个库，自己设置。 通过1./configure --help 命令查看怎么设置，通过打开configure文件查看所对应的库之间的依赖等。 依赖关系1234567891011# libraries, in linking orderavcodec_deps=&quot;avutil&quot;avcodec_select=&quot;null_bsf&quot;avdevice_deps=&quot;avformat avcodec avutil&quot;avfilter_deps=&quot;avutil&quot;avformat_deps=&quot;avcodec avutil&quot;avformat_suggest=&quot;network&quot;avresample_deps=&quot;avutil&quot;postproc_deps=&quot;avutil gpl&quot;swresample_deps=&quot;avutil&quot;swscale_deps=&quot;avutil&quot; 通过这个就可以知道在android里面的so库加载顺序12345678910static &#123; System.loadLibrary(&quot;avutil-55&quot;); System.loadLibrary(&quot;swresample-2&quot;); System.loadLibrary(&quot;avcodec-57&quot;); System.loadLibrary(&quot;avformat-57&quot;); System.loadLibrary(&quot;swscale-4&quot;); System.loadLibrary(&quot;avfilter-6&quot;); //自己实现逻辑编译的库 System.loadLibrary(&quot;native-lib&quot;); &#125; 也可以通过查看生成的lib/pkgconfig里面对应的pc文件查看具体的依赖关系 比如libavfilter.pc1234567891011121314prefix=./android/armv7-a-vfpexec_prefix=$&#123;prefix&#125;libdir=$&#123;prefix&#125;/libincludedir=$&#123;prefix&#125;/includeName: libavfilterDescription: FFmpeg audio/video filtering libraryVersion: 6.31.100Requires: Requires.private: libswscale &gt;= 4.0.100, libavformat &gt;= 57.25.100, libavcodec &gt;= 57.24.102, libswresample &gt;= 2.0.101, libavutil &gt;= 55.17.103Conflicts:Libs: -L$&#123;libdir&#125; -lavfilter Libs.private: -lm -lz -pthreadCflags: -I$&#123;includedir&#125;]]></content>
      <categories>
        <category>ffmpeg</category>
      </categories>
      <tags>
        <tag>音视频</tag>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jni小细节操作]]></title>
    <url>%2Fjni%20%E5%B0%8F%E7%BB%86%E8%8A%82%E6%93%8D%E4%BD%9C.html</url>
    <content type="text"><![CDATA[数组的细节处理1234567891011121314151617181920212223242526272829303132#include &lt;jni.h&gt;#include &lt;string&gt;#include &lt;stdlib.h&gt;int compare(const jint *a, const jint *b) &#123; return *a - *b;&#125;extern "C"JNIEXPORT void JNICALLJava_com_zzw_jnidemo_ArrayUtils_sort(JNIEnv *env, jclass type, jintArray array_) &#123; jint *intArray = env-&gt;GetIntArrayElements(array_, NULL); jsize length = env-&gt;GetArrayLength(array_); //排序 //void *ptr 指向待排序的数组的指针 //size_t count 数组的元素数目 //size_t size 数组每个元素的字节大小 // int (*comp)(const void *, const void *) 比较函数。若首个参数小于第二个，则返回负整数值，若首个参数大于第二个， // 则返回正整数值，若两参数相等，则返回零。// void qsort( void *ptr, size_t count, size_t size,int (*comp)(const void *, const void *) ); qsort(intArray, static_cast&lt;size_t&gt;(length), sizeof(int), reinterpret_cast&lt;int (*)(const void *, const void *)&gt;(compare)); //mode = //0 表示 既要同步数据给jArray，又要释放intArray //JNI_COMMIT : copy content, do not free buffer ,会同步数据给jArray,但是不会释放intArray //JNI_ABORT : free buffer w/o copying back ,不会同步数据给jArray,但是会释放intArray env-&gt;ReleaseIntArrayElements(array_, intArray, JNI_ABORT);&#125; 2.局部引用和全局引用 123456789101112131415161718192021222324252627282930313233//局部变量extern "C"JNIEXPORT void JNICALLJava_com_zzw_jnidemo_ArrayUtils_localRef(JNIEnv *env, jclass type) &#123; //在Native层侯建的Java对象，不用了该怎么管理? 需要手动回收 //在Java层开辟的内存由谁管理(JavaGC管理)，能开辟多大内存? //字符串截取 jclass str_clz = env-&gt;FindClass("java/lang/String"); jmethodID init_str = env-&gt;GetMethodID(str_clz, "&lt;init&gt;", "()V"); jobject j_str = env-&gt;NewObject(str_clz, init_str); //..... //jobject不使用了，需要回收。删除了就不能使用了 env-&gt;DeleteLocalRef(j_str);&#125;//全局变量,需要在合适的时机去释放 env-&gt;DeleteGlobalRef(globalStr);删除之后不能使用jstring globalStr;extern "C"JNIEXPORT void JNICALLJava_com_zzw_jnidemo_ArrayUtils_saveGlobalRef(JNIEnv *env, jclass type, jstring str_) &#123; globalStr = static_cast&lt;jstring&gt;(env-&gt;NewGlobalRef(str_));&#125;extern "C"JNIEXPORT jstring JNICALLJava_com_zzw_jnidemo_ArrayUtils_getStrGlobalRef(JNIEnv *env, jclass type) &#123; return globalStr;&#125; 3.静态缓存策略12345678910111213141516171819202122232425262728293031323334//局部静态缓存extern "C"JNIEXPORT void JNICALLJava_com_zzw_jnidemo_ArrayUtils_staticLcalCache(JNIEnv *env, jclass type, jstring name_) &#123;// jfieldID f_id =NULL; static jfieldID f_id = NULL;//局部缓存 ,这个方法会被多次调用，不需要反复去获取jfieldID if (!f_id) &#123; f_id = env-&gt;GetStaticFieldID(type, "name", "Ljava/lang/String;"); &#125; else &#123; LOGE("f_id不为null");//加上static将会缓存 &#125; env-&gt;SetStaticObjectField(type, f_id, name_);&#125;//全局静态缓存static jfieldID jfieldID1;static jfieldID jfieldID2;static jfieldID jfieldID3;//一般初始化的时候调用extern "C"JNIEXPORT void JNICALLJava_com_zzw_jnidemo_ArrayUtils_initStatic(JNIEnv *env, jclass type) &#123; jfieldID1 = env-&gt;GetStaticFieldID(type, "name", "Ljava/lang/String;"); jfieldID2 = env-&gt;GetStaticFieldID(type, "name1", "Ljava/lang/String;"); jfieldID3 = env-&gt;GetStaticFieldID(type, "name2", "Ljava/lang/String;");&#125;//如果反复调用设置值得函数，那么将不会每次都获取idvoid setData(JNIEnv *env, jclass jclazz, jobject object) &#123; env-&gt;SetStaticObjectField(jclazz, jfieldID1, object); env-&gt;SetStaticObjectField(jclazz, jfieldID2, object); env-&gt;SetStaticObjectField(jclazz, jfieldID3, object);&#125; 4.异常处理12345678910111213141516171819202122232425262728293031323334353637383940extern "C"JNIEXPORT void JNICALLJava_com_zzw_jnidemo_ArrayUtils_exception2(JNIEnv *env, jclass cls) &#123; jthrowable exc = NULL; jmethodID mid = env-&gt;GetStaticMethodID(cls, "exceptionCallback", "()V"); if (mid != NULL) &#123; env-&gt;CallStaticVoidMethod(cls, mid); &#125; LOGE("In C: Java_com_zzw_jnidemo_ArrayUtils_exception2--&gt;called!!!!"); //这种也是可以检测的// exc = env-&gt;ExceptionOccurred(); // 返回一个指向当前异常对象的引用// if (exc) &#123; if (env-&gt;ExceptionCheck()) &#123; // 检查JNI调用是否有引发异常 env-&gt;ExceptionDescribe();//打印错误信息 env-&gt;ExceptionClear(); // 清除引发的异常，在Java层不会打印异常的堆栈信息 env-&gt;ThrowNew(env-&gt;FindClass("java/lang/Exception"), "JNI抛出的异常！"); return; &#125; //补救 。。。 mid = env-&gt;GetStaticMethodID(cls, "normalCallback", "()V"); if (mid != NULL) &#123; env-&gt;CallStaticVoidMethod(cls, mid); &#125;&#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); try &#123; ArrayUtils.exception(); &#125; catch (Exception e) &#123; e.printStackTrace();//打印抛出的异常 &#125; &#125; c++调用java: 这里需要分为在主线程调用还是在子线程调用，在主线程调用就直接通过函数的env调用即可，在子线程调用则需要JavaVM -&gt;AttachCurrentThread拿到env然后调用。 123456789101112131415161718192021222324252627282930313233343536373839404142#include "JavaListener.h"JavaVM *jvm;JavaListener *javaListener;pthread_t chidlThread;void *childCallback(void *data)&#123; JavaListener *javaListener1 = (JavaListener *) data; //子线程调用 javaListener1-&gt;onError(0, 101, "c++ call java meid from child thread!"); pthread_exit(&amp;chidlThread);&#125;extern "C"JNIEXPORT void JNICALLJava_com_zzw_jnithread_ThreadDemo_callbackFromC(JNIEnv *env, jobject instance) &#123; javaListener = new JavaListener(jvm, env, env-&gt;NewGlobalRef(instance)); //主线程调用 //javaListener-&gt;onError(1, 100, "c++ call java meid from main thread!"); //子线程调用 pthread_create(&amp;chidlThread, NULL, childCallback, javaListener);&#125;JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void* reserved)&#123; JNIEnv *env; jvm = vm; if(vm-&gt;GetEnv((void **) &amp;env, JNI_VERSION_1_6) != JNI_OK) &#123; return -1; &#125; return JNI_VERSION_1_6;&#125; JavaListener.h1234567891011121314151617181920212223242526272829303132#include "jni.h"#ifndef JNITHREAD_JAVALISTENER_H#define JNITHREAD_JAVALISTENER_Hclass JavaListener &#123;public: JavaVM *jvm; _JNIEnv *jenv; jobject jobj; jmethodID jmid;public: JavaListener(JavaVM *vm, _JNIEnv *env, jobject obj); ~JavaListener(); /** * 1:主线程 * 0：子线程 * @param type * @param code * @param msg */ void onError(int type, int code, const char *msg);&#125;;#endif //JNITHREAD_JAVALISTENER_H JavaListener.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243#include "JavaListener.h"void JavaListener::onError(int type, int code, const char *msg) &#123; if(type == 0) &#123; JNIEnv *env; jvm-&gt;AttachCurrentThread(&amp;env, 0); jstring jmsg = env-&gt;NewStringUTF(msg); env-&gt;CallVoidMethod(jobj, jmid, code, jmsg); env-&gt;DeleteLocalRef(jmsg); jvm-&gt;DetachCurrentThread(); &#125; else if(type == 1) &#123; jstring jmsg = jenv-&gt;NewStringUTF(msg); jenv-&gt;CallVoidMethod(jobj, jmid, code, jmsg); jenv-&gt;DeleteLocalRef(jmsg); &#125;&#125;JavaListener::JavaListener(JavaVM *vm, _JNIEnv *env, jobject obj) &#123; jvm = vm; jenv = env; jobj = obj; jclass clz = env-&gt;GetObjectClass(jobj); if(!clz) &#123; return; &#125; jmid = env-&gt;GetMethodID(clz, "onError", "(ILjava/lang/String;)V"); if(!jmid) return;&#125; ThreadDemo.java1234567891011121314151617181920212223242526272829public class ThreadDemo &#123; static &#123; System.loadLibrary("native-lib"); &#125; private OnErrerListener onErrerListener; public void setOnErrerListener(OnErrerListener onErrerListener) &#123; this.onErrerListener = onErrerListener; &#125; public void onError(int code, String msg) &#123; if(onErrerListener != null) &#123; onErrerListener.onError(code, msg); &#125; &#125; public interface OnErrerListener &#123; void onError(int code, String msg); &#125; public native void callbackFromC();&#125;]]></content>
      <categories>
        <category>jni</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>jni</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jni基础]]></title>
    <url>%2Fjni%E5%9F%BA%E7%A1%80.html</url>
    <content type="text"><![CDATA[JNI 的一般开发流程 1 定义好本地的 native 方法2 javah 命令生成 .h 头文件3 拷贝 xxx.h、jni_md.h、jni.h 到 VS 的工程目录并添加依赖进来4 实现我们头文件中的 native 方法5 生成 dll 动态，java 引入 dll 动态库运行即可 生成的 .h 文件参数详解12345678910111213141516171819202122/* DO NOT EDIT THIS FILE - it is machine generated */#include "jni.h"// "" 引入自己工程的头文件 &lt;&gt; 引入系统的头文件/* Header for class com_darren_ndk12_NdkSimple */// 用来打一个标记，c在编译的时候会把头文件 copy 到你引入的地方，不管是重复引用还是相互引用都只会 copy 一次#ifndef _Included_com_darren_ndk12_NdkSimple#define _Included_com_darren_ndk12_NdkSimple#ifdef __cplusplus // 相当于 if 语句 c++ // 不管是 c 还是 c++ 统一都是采用 c 的编译方式，因为在c里面是不允许函数重载的,但是在 c++ 里面可以extern "C" &#123;#endif/* * Class: com_darren_ndk12_NdkSimple * Method: getSingnaturePassword * Signature: ()Ljava/lang/String; */JNIEXPORT jstring JNICALL Java_com_darren_ndk12_NdkSimple_getSingnaturePassword (JNIEnv *, jobject);#ifdef __cplusplus&#125;#endif#endif 实现类详解1234567891011121314// 实现我们的 native 方法#include "com_darren_ndk12_NdkSimple.h"// JNIEXPORT JNI 一个关键字，不能少（编译能通过），标记为该方法可以被外部调用// jstring : 代表 java 中的 String // JNICALL: 也是一个关键字，可以少的 jni call// JNIEnv: 这个是 c 和 java 相互调用的桥梁，所有 function 搞清// jobject: java传递下来的对象，就是本项目中 JniSimple java 对象// jclass: 静态函数的时候java传递下来的 class 对象，就是本项目中的 JniSimple.class JNIEXPORT jstring JNICALL Java_com_darren_ndk12_NdkSimple_getSingnaturePassword(JNIEnv * env, jobject jobj)&#123; // JNIEnv * 其实已经是一个二级指针了，所以 -&gt; 调用的情况下必须是一级指针 *取值 return (*env)-&gt;NewStringUTF(env,"940223");&#125; JNIEnv是什么 在jni.h里面有如下代码123456789101112131415161718192021/* * JNI Native Method Interface. */struct JNINativeInterface_;struct JNIEnv_;#ifdef __cplusplus //如果是c++就是JNIEnv_对象 JNIEnv_对象里面其实也是通过JNINativeInterface_调用typedef JNIEnv_ JNIEnv;#else //如果是c的话就是JNINativeInterface_指针typedef const struct JNINativeInterface_ *JNIEnv;#endifstruct JNIEnv_ &#123; const struct JNINativeInterface_ *functions; // .... &#125; 在实现的函数里面12345JNIEXPORT jstring JNICALL Java_com_darren_ndk12_NdkSimple_getSingnaturePassword(JNIEnv * env, jobject jobj)&#123; // JNIEnv * 其实已经是一个二级指针了，所以 -&gt; 调用的情况下必须是一级指针 *取值 return (*env)-&gt;NewStringUTF(env,"940223");&#125; 所以为什么在c里面调用函数需要用(*env)-&gt; ，而c++只需要用env-&gt; JNIEnv流程 手写JNIEnv流程123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;// 定义一个结构体指针的别名typedef const struct JNINativeInterface *JNIEnv;// 模拟一个结构体struct JNINativeInterface&#123; // 结构体的方法指针 char*(*NewStringUTF)(JNIEnv*,char*);&#125;;char* NewStringUTF(JNIEnv* env, char* c_str)&#123; // c_str -&gt; jstring return c_str;&#125;char* Java_com_darren_getSingnaturePassword(JNIEnv * env)&#123; // JNIEnv * 其实已经是一个二级指针了，所以 -&gt; 调用的情况下必须是一级指针 *取值 return (*env)-&gt;NewStringUTF(env, "940223");&#125;void main()&#123; // 构建 JNIEnv* 对象 struct JNINativeInterface nativeInterface; // 给结构方法指针进行复制(实现) nativeInterface.NewStringUTF = NewStringUTF; // 传给 Java_com_darren_ndk12_NdkSimple_getSingnaturePassword 的参数是 JNIEnv* JNIEnv env = &amp;nativeInterface;// 一级指针 JNIEnv* jniEnv = &amp;env;// 二级指针 // 把 jniEnv 对象传给 Java_com_darren_ndk12_NdkSimple_getSingnaturePassword char* jstring = Java_com_darren_getSingnaturePassword(jniEnv); // jstring 通过 JNIEnv 传给 java 层 printf("jstring = %s",jstring); getchar();&#125;]]></content>
      <categories>
        <category>jni</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>jni</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++基础语法]]></title>
    <url>%2Fc%2B%2B%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html</url>
    <content type="text"><![CDATA[c和c++联系 c++代码可以混编c代码,既可以写c也可以调用c c++面向对象,c面向过程 开源框架大部分都是基于c++写的 打印12345678910#include "stdio.h"#include &lt;iostream&gt;using namespace std;void main() &#123; //打印 //cout &lt;&lt; "hello world " &lt;&lt; endl;//换行 cout &lt;&lt; "hello world " ;//不换行&#125; 常量123456789void main() &#123; //常量 const int number = 0; //在c文件，这里可以通过指针修改值，但是在c++中不能通过地址修改值，一般编译器编译不能通过，但是某一些编译器可以，但是也不能修改值 //int *number_p = &amp;number; //*number_p = 20; getchar(); &#125; 引用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include "stdio.h"#include &lt;iostream&gt;using namespace std;//通过指针来变换void swap(int *num1,int* num2) &#123; int temp = 0; temp = *num1; *num1 = *num2; *num2 = temp;&#125;//通过引用来变换void swap(int &amp;num1, int&amp; num2) &#123; cout &lt;&lt; "number1p = " &lt;&lt; &amp;num1 &lt;&lt; " number2p = " &lt;&lt; &amp;num2 &lt;&lt; endl;//number1p = 00BBFA08 number2p = 00BBF9FC int temp = 0; temp = num1; num1 =num2; num2 = temp;&#125;void main() &#123; //引用:四驱模型值的拷贝，引用其实是地址赋值，可以看成同一块内存的另外一个变量 //交换值 int number1 = 10; int number2 = 20; //通过指针 //swap(&amp;number1,&amp;number2); //通过引用 cout &lt;&lt; " number1p = " &lt;&lt; &amp;number1 &lt;&lt; " number2p = " &lt;&lt; &amp;number2 &lt;&lt;endl; // number1p = 00BBFA08 number2p = 00BBF9FC swap(number1,number2); cout &lt;&lt; "number1 = " &lt;&lt; number1 &lt;&lt; " number2 = " &lt;&lt; number2 &lt;&lt; endl;// number1 = 20 number2 = 10 //加深理解 int a = 10; int b = a; //赋值 b 和 a分别指向不同的内存 cout &lt;&lt; "ap = " &lt;&lt; &amp;a &lt;&lt; " bp = " &lt;&lt; &amp;b &lt;&lt; endl;// ap = 010FF730 bp = 010FF724 int&amp; c = a;//引用 a和c都指向一块地址 cout &lt;&lt; "ap = " &lt;&lt; &amp;a &lt;&lt; " cp = " &lt;&lt; &amp;c &lt;&lt; endl;// ap = 010FF730 cp = 010FF730 c = 20; cout &lt;&lt; "a = " &lt;&lt; a &lt;&lt; " c = " &lt;&lt; c &lt;&lt; endl;//a = 20 c = 20 getchar(); &#125; 常量引用 123456789101112131415161718192021222324#include "stdio.h"#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;typedef struct &#123; char name[20]; int age;&#125; Student;//常量引用 const Student &amp; stu只能读，不能修改void insertStudent(/* const */ Student &amp; stu) &#123; //stu.name = "李四"; //不能修改 strcpy_s(stu.name, "李四"); //这样的话就修改了值，如果不想修改stu，就在参数加上const 变为只读&#125;void main() &#123; Student stu = &#123;"张三" ,45&#125;; insertStudent(stu); cout &lt;&lt; "stu.name = " &lt;&lt; stu.name &lt;&lt; " stu.age = " &lt;&lt; stu.age &lt;&lt; endl; getchar(); &#125; 重载 :c不支持重载 ,c++支持1234567891011121314151617181920212223242526272829303132333435#include "stdio.h"#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;//重载//int add(int number1, int number2) &#123;//// return number1 + number2;//&#125;int add(int number1, int number2,bool cache = false) &#123; cout &lt;&lt; cache &lt;&lt; endl; return number1 + number2;&#125;int add(int number1, int number2,int number3) &#123; return number1 + number2 + number3;&#125;void main() &#123; int number1 = 10; int number2 = 20; int number3 = 30; int sum1 = add(number1, number2); int sum2 = add(number1, number2 , number3); printf("%d , %d", sum1, sum2); getchar(); &#125; 类 JAVA里的Class12345678910111213141516171819202122232425262728293031323334353637383940414243#include "stdio.h"#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;class Student&#123;private: // 私有 包装，影响下面所有的属性或者方法 char * name; int age;public://影响下面所有的方法或者属性 void setAge(int age)&#123; this-&gt;age = age; &#125; void setName(char*name) &#123; this-&gt;name = name; &#125; int getAge() &#123; return this-&gt;age; &#125; char * getName() &#123; return this-&gt;name; &#125;&#125;;void main() &#123; Student stu; stu.setAge(25); cout &lt;&lt; stu.getAge() &lt;&lt; endl; Student *student = new Student(); student-&gt;setAge(24); cout &lt;&lt; student-&gt;getAge() &lt;&lt; endl; getchar(); &#125; 注意:在开发过程中，cpp或者c会被编译为dll或者so供其调用者使用，一般把public的函数定义到h文件，不然调用者都不知道有哪些函数。 构造函数12345678910111213141516171819202122232425262728293031323334353637383940414243class Student&#123;public: //1. Student() &#123;&#125;; //2. Student(char * name):age(0) &#123; // 相当于thix-&gt;age = 0 this-&gt;name = name; &#125;; //3. //构造函数相互调用 先调用两个参数的，在调用一个参数的 Student(char*name) :Student(name,0) &#123; // 相当于thix-&gt;age = 0 &#125;; //4. Student(char*name,int age) &#123; this-&gt;name = name; this-&gt;age = age; &#125;;private: char * name; int age;public: void setAge(int age)&#123; this-&gt;age = age; &#125; void setName(char*name) &#123; this-&gt;name = name; &#125; int getAge() &#123; return this-&gt;age; &#125; char * getName() &#123; return this-&gt;name; &#125;&#125;; 析构函数12345678910111213141516171819202122232425262728293031323334353637383940class Student&#123;public: Student() &#123;&#125;; Student(char*name,int age) &#123; this-&gt;name = (char*)malloc(sizeof(char)*100); strcpy(this-&gt;name,name); this-&gt;age = age; &#125;; //析构函数:对象被回收的时候会被调用，只能有一个，不能有参数 ~Student() &#123; //释放内存 这里name使用malloc举个例子 free(this-&gt;name); &#125;private: char * name; int age;public: void setAge(int age)&#123; this-&gt;age = age; &#125; void setName(char*name) &#123; this-&gt;name = name; &#125; int getAge() &#123; return this-&gt;age; &#125; char * getName() &#123; return this-&gt;name; &#125;&#125;; malloc free new delete区别 malloc/free一起用 new/delete一起用 malloc/free不会调用构造函数和析构函数，new/delete会调用构造函数和析构函数 如果用了new，一定要记得delete释放内存 拷贝构造函数1234Class(const Class&amp; C) &#123; //..赋值 &#125; https://blog.csdn.net/lwbeyond/article/details/6202256 可变参数 java的Object…1234567891011121314151617181920212223242526#include "stdio.h"#include &lt;stdarg.h&gt;#include &lt;iostream&gt;using namespace std;//可变参数int sum(int count,...) &#123; va_list vp; //可变参数指定开始 count代表从哪里开始 va_start(vp,count); int sum = 0; for (int i = 0; i &lt; count; i++) &#123; sum += va_arg(vp, int); &#125; va_end(vp); return sum;&#125;int main()&#123; cout&lt;&lt;sum(3, 2, 3, 4)&lt;&lt;endl; getchar(); return 0;&#125; static1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include "stdio.h"#include &lt;stdarg.h&gt;#include &lt;iostream&gt;using namespace std;class Student&#123;public: char * name; int age; static int tag; Student() &#123; tag = 10; &#125; static void change() &#123; tag += 20; &#125; void change2() &#123; tag += 20; &#125;&#125;;//静态属性 在c++中必须初始化，初始化必须这么写int Student::tag =15;int main()&#123; cout &lt;&lt; Student::tag &lt;&lt; endl;//15 Student stu; cout &lt;&lt; Student::tag &lt;&lt; endl;//10 Student::change(); //静态函数调用静态变量 cout &lt;&lt; Student::tag &lt;&lt; endl;//30 stu.change2(); //非静态函数调用静态变量 cout &lt;&lt; Student::tag &lt;&lt; endl;//50 getchar(); return 0;&#125;// 1. 调用使用 双冒号 ::// 2. 静态属性 必须初始化// 2. 静态函数只能操作静态的相关函数和属性 const函数12345678910111213141516171819202122232425262728293031323334353637#include "stdio.h"#include &lt;stdarg.h&gt;#include &lt;iostream&gt;using namespace std;class C&#123;public: int age;public: const void change() &#123; this-&gt;age += 12; &#125; //const 在()之后主要用来限制this关键字 void change2() const &#123; //this-&gt;age += 12; //不能对类的属性进行修改 &#125; C(int age) &#123; this-&gt;age = age; &#125;&#125;;int main()&#123; C *c = new C(15); c-&gt;change(); cout &lt;&lt; c-&gt;age &lt;&lt; endl; getchar(); return 0;&#125; 友元函数12345678910111213141516171819202122232425262728293031323334353637383940414243#include "stdio.h"#include &lt;stdarg.h&gt;#include &lt;iostream&gt;using namespace std;class Person&#123;public: Person(int age) &#123; this-&gt;age = age; &#125;; int getAge() &#123; return this-&gt;age; &#125; //友元函数 申明之后，friend_change就可以调用私有属性 friend void friend_change(Person * person, int age);private: int age = 0;&#125;;void friend_change(Person * person, int age) &#123; //age private修饰，在类的内部才能访问私有函数。如果非要访问，就得用到友元函数 //如果该方法设置为友元函数，那么在外部可以访问其私有属性 person-&gt;age = age;&#125;int main()&#123; Person person = Person(24); friend_change(&amp;person,20); cout &lt;&lt; person.getAge() &lt;&lt; endl;//20 getchar(); return 0;&#125; 构造函数，析构函数，拷贝构造函数，普通函数，静态函数，友元函数实现 Student.h1234567891011121314151617181920212223242526272829303132333435363738#include "stdafx.h"class Student&#123;private: int age; int time;public: //静态属性的申明 static int tag;public: //构造函数 Student(); Student(int age); Student(int time, int age); //析构函数 ~Student(); //拷贝构造函数 Student(const Student &amp;student );public: void setAge(int age); void setTime(int time); int getAge(); int getTime(); void print() const; //静态函数 static void changeTag(int tag_replease); //友元函数 friend void changeAge(Student* stu,int age);&#125;; 实现类 Student.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include "stdafx.h"#include "Student.h"#include &lt;iostream&gt;//实现类,不一定都要全部实现//静态属性的申明int Student::tag = 0;//构造函数Student::Student()&#123; &#125;;Student::Student(int age):time(200) &#123; //time默认赋值 this-&gt;age = age;&#125;Student::Student(int age,int time) &#123; this-&gt;age = age; this-&gt;time = time;&#125;//析构函数Student::~Student() &#123; //资源回收&#125;//拷贝构造函数Student::Student(const Student&amp; student) &#123;&#125;//普通方法void Student::setAge(int age) &#123; this-&gt;age = age;&#125;void Student::setTime(int time) &#123; this-&gt;time = time;&#125;int Student::getAge() &#123; return this-&gt;age;&#125;int Student::getTime() &#123; return this-&gt;time;&#125;// const函数void Student::print() const &#123; //this-&gt;age = 20;//不能操作this std::cout &lt;&lt; this-&gt;age &lt;&lt; " " &lt;&lt; this-&gt;time &lt;&lt; " "&lt;&lt; tag &lt;&lt; std::endl;&#125;//静态函数void Student::changeTag(int tag_replease) &#123; tag = tag_replease;&#125;//友元函数 不需要加 Student::void changeAge(Student* stu, int age) &#123; stu-&gt;age = age;&#125; demo:12345678910111213141516171819202122#include "stdafx.h"#include "Student.h"void main() &#123; Student* stu = new Student(24, 1000); //调用const函数 stu-&gt;print(); //调用静态函数 Student::changeTag(36); stu-&gt;print(); //调用友元函数 changeAge(stu, 37); stu-&gt;print(); delete(stu); getchar();&#125; 友元类 ：java的反射获取属性可以理解为就是有一个Class类的友元类123456789101112131415161718192021222324252627282930class ImageView &#123; public: //申明Class是ImageView 的友元类 friend class Class; private: int age;&#125;; class Class&#123; public: void changeAge(int age) &#123; //正常情况下这是不能直接用的，申明友元类就可以用了 aObj.age = age; &#125; int getAge() &#123; //正常情况下这是不能直接用的，申明友元类就可以用了 return aObj.age; &#125; private : ImageView aObj; &#125;; void main() &#123; Class b; b.changeAge(10); std::cout &lt;&lt; b.getAge() &lt;&lt; std::endl; // 10 getchar(); &#125; 操作运算符 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include &lt;iostream&gt;using namespace std;class Vector&#123;public: Vector(int x, int y)&#123; this-&gt;x = x; this-&gt;y = y; &#125; Vector(const Vector &amp;vector)&#123; this-&gt;x = vector.x; this-&gt;y = vector.y; cout &lt;&lt; "拷贝构造函数" &lt;&lt; endl; &#125;private: int x; int y;public: void setX(int x)&#123; this-&gt;x = x; &#125; void setY(int y)&#123; this-&gt;y = y; &#125; int getX()&#123; return this-&gt;x; &#125; int getY()&#123; return this-&gt;y; &#125; // 重载减号运算符 // 为什么要用引用，为了防止重复创建对象 // const 关键常量，为了防止去修改值 Vector operator - (const Vector &amp;vector)&#123; int x = this-&gt;x - vector.x; int y = this-&gt;y - vector.y; Vector res(x, y); return res;// 不建议返回引用 &#125; // 自增减运算符 void operator ++ ()&#123;// ++X this-&gt;x = this-&gt;x++; this-&gt;y = this-&gt;y++; &#125; void operator ++ (int)&#123;// X++ this-&gt;x = this-&gt;x++; this-&gt;y = this-&gt;y++; &#125; // 自减 // 输出运算符 friend ostream &amp; operator &lt;&lt; (ostream &amp;_Ostr, const Vector &amp;vector)&#123; _Ostr &lt;&lt; vector.x &lt;&lt; "," &lt;&lt; vector.y &lt;&lt; endl; return _Ostr; &#125; // 条件运算符 bool operator == (const Vector &amp;vector)&#123; return (this-&gt;x == vector.x &amp;&amp; this-&gt;y == vector.y); &#125;&#125;;// 定义在类的外面，一般来讲我们定义在类的里面// 重载运算 + ：operator +Vector operator + (Vector vector1, const Vector vector2)&#123; int x = vector1.getX() + vector2.getX(); int y = vector1.getY() + vector2.getY(); Vector vector(x,y); return vector;&#125;void main()&#123; Vector vector1(2, 3); Vector vector2(2, 3); // java 中 string + string // char* str = "123" + "456"; // 重载运算符 + // Vector vector = vector1 - vector2; // Vector vector(1, 2); // vector++; // ++vector; // cout &lt;&lt; vector.getX() &lt;&lt; " , " &lt;&lt; vector.getY() &lt;&lt; endl; // cout &lt;&lt; vector &lt;&lt; vector; bool isEqual = vector1 == vector2; cout &lt;&lt; isEqual &lt;&lt; endl; // 可以重载加其他对象 Person getchar();&#125;// 括号运算符class Array&#123;public: Array(int size)&#123; this-&gt;size = size; this-&gt;array = (int*)malloc(sizeof(int)*size); &#125; ~Array()&#123; if (this-&gt;array)&#123; free(this-&gt;array); this-&gt;array = NULL; &#125; &#125; Array(const Array&amp; array)&#123; this-&gt;size = array.size; this-&gt;array = (int*)malloc(sizeof(int)*array.size); // 值的赋值 for (int i = 0; i &lt; array.size; i++) &#123; this -&gt; array[i] = array.array[i]; &#125; &#125;private: int size; int* array;public: void set(int index,int value)&#123; array[index] = value; &#125; int get(int index)&#123; return this-&gt;array[index]; &#125; int getSize()&#123; return this-&gt;size; &#125; // 操作符[] int operator[](int index)&#123; return this-&gt;array[index]; &#125;&#125;;void printfArray(Array array)&#123; for (int i = 0; i &lt; array.getSize(); i++) &#123; cout &lt;&lt; array[i] &lt;&lt; endl; &#125;&#125;void main()&#123; Array *array = new Array(5); array-&gt;set(0,0); array-&gt;set(1, 1); array-&gt;set(2, 2); printfArray(*array); delete(array); getchar();&#125; 类的继承 : 类继承，构造函数调用顺序:先父类 -&gt; 再子类 ,析构函数调用顺序 : 先子类 -&gt; 再父类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 初始化属性class Person&#123; // 变量修饰符public:// 本类中使用 // protected ：子类中能使用 （默认） // public ：公开，任何地方都可以 char* name; int age;public: Person(char* name, int age)&#123; this-&gt;name = name; this-&gt;age = age; cout &lt;&lt; "Person 构造函数" &lt;&lt; endl; &#125;public: void print()&#123; cout &lt;&lt; this-&gt;name &lt;&lt; " , " &lt;&lt; this-&gt;age &lt;&lt; endl; &#125;&#125;;class Student : public Person&#123;private: char* courseName;public: // : Person(name,age) 调用构造函数初始化父类的属性 // 不光可以给父类初始化属性，还可以给本类的属性进行初始化，用 , 隔开即可 Student(char* name, int age, char* courseName) :Person(name, age), courseName(courseName)&#123;// 调用父类构造函数 cout &lt;&lt; "Student 构造函数" &lt;&lt; endl; &#125; void print()&#123; cout &lt;&lt; "courseName: " &lt;&lt; courseName &lt;&lt; endl; &#125;&#125;;class Teacher: public Person&#123;public: Teacher(char*name,int age):Person(name,age)&#123; &#125;&#125;;void main()&#123; Student stu("张三",24,"语文"); stu.print(); getchar();&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;class Person &#123;protected: char* name; int age;public: Person(char* name, int age)&#123; this-&gt;name = name; this-&gt;age = age; &#125;&#125;;class Course&#123;private:// java String string name;public: Course(string name)&#123; this-&gt;name = name; &#125;public: string _name()&#123; return this-&gt;name; &#125;&#125;;class Student : public Person&#123;private: Course course;public: Student(char* name, int age, string courseName) : Person(name, age), course(courseName)&#123; // 初始化父类的属性 &#125; void print()&#123; cout &lt;&lt; name &lt;&lt; "," &lt;&lt; age &lt;&lt; "," &lt;&lt; course._name().c_str() &lt;&lt; endl; &#125;&#125;; 多继承1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;class Person&#123;private: char * name;public: Person(char * name)&#123; this-&gt;name = name; &#125; char* _name()&#123; return this-&gt;name; &#125;&#125;;class Child&#123; int age;public: Child(int age)&#123; this-&gt;age = age; &#125; int _age()&#123; return this-&gt;age; &#125;&#125;;// 多继承，在 java 里面是不允许多继承 ， c++ 是可以的，但是你也不能有二义性（歧义）class Student : public Person, public Child // 多继承 , 并没有实现(接口)&#123;public: Student(char* name,int age):Person(name),Child(age)&#123; &#125;&#125;; 虚继承：解决二义性 1234567891011121314151617class A&#123;public: char* name;&#125;;class B : virtual public A&#123; // virtual 确保继承过来的相同属性或者函数，只存在一份拷贝&#125;; class C :virtual public A&#123;&#125;;class D : public B ,public C&#123;&#125;; 多态:c++里面分为动态多态(子父类 需要virtual修饰)，静态多态（函数的重载）,区别是编译过程确定性。 12345678910111213141516171819202122232425262728293031323334353637383940414243class Activity&#123;public: virtual void onCreate()&#123; // 支持多态，虚函数 cout &lt;&lt; &quot;Activity 中的 onCreate&quot; &lt;&lt; endl; &#125;&#125;;class MainActivity : public Activity&#123;public: void onCreate()&#123; cout &lt;&lt; &quot;MainActivity 中的 onCreate&quot; &lt;&lt; endl; &#125;&#125;;class WelcomeActivity : public Activity&#123;public: void onCreate()&#123; cout &lt;&lt; &quot;WelcomeActivity 中的 onCreate&quot; &lt;&lt; endl; &#125;&#125;;void startActivity(Activity* activity)&#123; activity-&gt;onCreate();&#125;void main()&#123; Activity *activity1 = new MainActivity();// 父类 = new 子类对象 Activity *activity2 = new WelcomeActivity(); // activity-&gt;onCreate(); // c++ 中的多态是怎样的，默认情况下不存在 // 父类指向子类的引用，重写 ，里氏替换原则 // 程序在编译期间并不知晓运行的状态（我需要运行那个函数），只要在真正运行的过程中才会去找需要运行的方法 startActivity(activity1);//如果Activity里面onCreate不加virtual，那么将会执行Activity的onCreate不会执行MainActivity的onCreate startActivity(activity2); // c++ 多态：动态多态(子父类)，静态多态（函数的重载）（编译过程确定性的区别） getchar();&#125; 抽象类,抽象函数 12345678910111213141516171819202122232425262728293031323334353637// java 中类似的 抽象类，接口 纯虚函数class BaseActivity // 跟 java 中的抽象类一个概念&#123;public: void onCreate()&#123;// 普通函数 initView(); initData(); &#125; // 子类必须要实现 virtual void initData() = 0;// 虚函数，没有实现的，类似于 java 中的抽象方法，如果子类不实现会报错 virtual void initView() = 0;&#125;;// 如果不实现父类的纯虚函数，那么 MainActivity 也会变成抽象类，抽象类不允许实例化class MainActivity : public BaseActivity &#123;public: void initData()&#123; cout &lt;&lt; "initData" &lt;&lt; endl; &#125; void initView()&#123; cout &lt;&lt; "initView" &lt;&lt; endl; &#125;&#125;;void main()&#123; BaseActivity *m_a = new MainActivity(); m_a-&gt;onCreate(); getchar();&#125; 接口 1234567891011121314151617181920212223class ClickListener&#123;// 所有的函数都是虚函数，那么就可以认为是接口public: virtual void click() = 0;&#125;;class ImageClickListener : public ClickListener&#123;public : void click()&#123; cout &lt;&lt; "图片点击" &lt;&lt; endl; &#125;&#125;;void main()&#123; // 函数指针的时候：回调可以用 指针函数作为回调，纯虚函数类进行回调（接口） // ClickListener *listener = new ImageClickListener(); //直接调用 // listener-&gt;click(); getchar();&#125; 模板函数 ： java 中的泛型 123456789101112131415161718192021// 模板函数的定义template &lt;typename T&gt; T add(T number1, T number2)&#123; return number1 + number2;&#125;void main()&#123; int sum1 = add(1,2); cout &lt;&lt; sum1 &lt;&lt; endl; int sum2 = add(1.0, 2.0); cout &lt;&lt; sum2 &lt;&lt; endl; int sum3 = add(1.0f, 2.0f); cout &lt;&lt; sum3 &lt;&lt; endl; getchar();&#125; 模板类 1234567891011121314151617181920212223242526272829template &lt;typename T&gt; class Callback&#123;public: void onError()&#123; &#125; void onSucceed(T result)&#123; cout &lt;&lt; result &lt;&lt; endl; &#125;&#125;;// 模板类继承 ，子类如果也是模板类// 如果子类不是模板类class HttpCallback : public Callback&lt;int&gt;&#123; &#125;;template &lt;class T&gt;class HttpCallback : public Callback&lt;T&gt;&#123;&#125;;void main()&#123; HttpCallback&lt;int&gt; *callback = new HttpCallback&lt;int&gt;(); callback-&gt;onSucceed(12); getchar();&#125; 如果开发中涉及到模板类，申明和实现要写在同一个类里面: hpp = h + cpp/c (编译) 例如:c++实现ArrayList ArrayList.hpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;malloc.h&gt;//------------------类的定义-------------------//template&lt;class E&gt;class ArrayList &#123;public: // 数组头指针 E *array = NULL; // 数组长度 int len = 0; // 数据大小 int index = 0;public: ArrayList(); ArrayList(int len); ~ArrayList(); ArrayList(const ArrayList &amp;list);public: bool add(E e); int size(); E get(int index); E remove(int index);private: void ensureCapacityInternal(int i); void grow(int capacity);&#125;;//------------------类的实现-------------------//template&lt;class E&gt;ArrayList&lt;E&gt;::ArrayList() &#123;&#125;template&lt;class E&gt;ArrayList&lt;E&gt;::ArrayList(int len) &#123; if (len == 0) &#123; return; &#125; this-&gt;len = len; this-&gt;array = (E *) malloc(sizeof(E) * len);&#125;template&lt;class E&gt;ArrayList&lt;E&gt;::~ArrayList() &#123; if (this-&gt;array) &#123; free(this-&gt;array); this-&gt;array = NULL; &#125;&#125;template&lt;class E&gt;ArrayList&lt;E&gt;::ArrayList(const ArrayList &amp;list) &#123; this-&gt;index = list.index; this-&gt;len = list.len; // 深拷贝 this-&gt;array = (E *) malloc(sizeof(E) * len); memcpy(this-&gt;array,list.array,sizeof(E) * len);&#125;template&lt;class E&gt;E ArrayList&lt;E&gt;::get(int index) &#123; return this-&gt;array[index];&#125;template&lt;class E&gt;int ArrayList&lt;E&gt;::size() &#123; return this-&gt;index;&#125;template&lt;class E&gt;E ArrayList&lt;E&gt;::remove(int index) &#123; E old_value = this-&gt;array[index]; // 计算出需要逻动的个数 int numMoved = this-&gt;index - index - 1; // 从前面不断的逻动 for (int i = 0; i &lt; numMoved; ++i) &#123; array[index + i] = array[index + i + 1]; &#125; this-&gt;index -= 1; return old_value;&#125;template&lt;class E&gt;bool ArrayList&lt;E&gt;::add(E e) &#123; ensureCapacityInternal(index + 1); this-&gt;array[index++] = e; return true;&#125;// 是否需要调整当前数组大小template&lt;class E&gt;void ArrayList&lt;E&gt;::ensureCapacityInternal(int minCapacity) &#123; // 当前数组是不是空，或者 len 是不是 0 if (this-&gt;array == NULL) &#123; minCapacity = 10;// 第一次初始化大小 &#125; // 判断要不要扩容 if (minCapacity - len &gt; 0) &#123; grow(minCapacity); &#125;&#125;// 扩容创建新的数组template&lt;class E&gt;void ArrayList&lt;E&gt;::grow(int capacity) &#123; // 计算新数组大小的长度 int new_len = len + (len &gt;&gt; 1); if (capacity - new_len &gt; 0) &#123; new_len = capacity; &#125; // 创建新的数组 E *new_arr = (E *) malloc(sizeof(E) * new_len); if (this-&gt;array) &#123; // 拷贝数据 memcpy(new_arr, array, sizeof(E) * index); // 释放原来的内存 free(this-&gt;array); &#125; array = new_arr; len = new_len;&#125; 使用的时候引入ArrayList.hpp1234567891011121314151617181920212223242526#include "ArrayList.hpp"#include &lt;jni.h&gt;#include &lt;string&gt;#include &lt;android/log.h&gt;#include "ArrayList.hpp"extern "C"JNIEXPORT voidJNICALLJava_com_zzw_demo_MainActivity_test( JNIEnv *env, jobject /* this */) &#123; ArrayList&lt;int&gt; *list = new ArrayList&lt;int&gt;();// for (int i = 0; i &lt; 100; ++i) &#123; list-&gt;add(i); &#125; for (int i = 0; i &lt; list-&gt;size(); ++i) &#123; __android_log_print(ANDROID_LOG_ERROR,"TAG","i = %d",list-&gt;get(i)); &#125; delete(list);&#125; 异常处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Exception&#123;public: string msg;public: Exception(string msg)&#123; this-&gt;msg = msg; &#125;public: const char *what()&#123; return this-&gt;msg.c_str(); &#125;&#125;;// 异常的处理void main()&#123; // c++ 中有自己一套异常的体系，不要去强记 // 但是 c++ 可以抛任何数据类型 try&#123;&#125;catch(数据类型 变量名)&#123;&#125; // throw 抛异常 try&#123; int i = -1; if (i == 0)&#123; throw Exception("出异常了"); &#125; if (i&lt; 0)&#123; throw 12.5f; &#125; &#125; catch (int number)&#123; cout &lt;&lt; "捕捉到异常" &lt;&lt;number &lt;&lt; endl; &#125; catch (Exception exception)&#123; cout &lt;&lt; "捕捉到异常:" &lt;&lt; exception.what() &lt;&lt; endl; &#125; catch (...)&#123; cout &lt;&lt; "捕捉到其他异常:" &lt;&lt; endl; &#125; getchar();&#125; 字符串常见操作 创建 123456789101112131415161718192021222324void main()&#123; string str1 = "123"; string str2("123"); string str3(5, 'A');// 5 个 A = AAAAA string *str4 = new string("123"); // cout &lt;&lt; str1.c_str() &lt;&lt;endl; // cout &lt;&lt; str2.c_str() &lt;&lt; endl; // cout &lt;&lt; str3.c_str() &lt;&lt; endl; // cout &lt;&lt; str4-&gt;c_str() &lt;&lt; endl; // string 与 char* 相互之间转换 c_str() // const char* c_str1 = str1.c_str(); // cout &lt;&lt; c_str1 &lt;&lt; endl; // char* -&gt; string char* c_str = "张三"; string str(c_str);// 对象 cout &lt;&lt; str.c_str() &lt;&lt; endl; getchar();&#125; 遍历 123456789101112131415161718192021222324252627282930313233void main()&#123; string str("1234567"); // 1. 字符串的遍历 for (int i = 0; i &lt; str.length(); i++) &#123; cout &lt;&lt; str[i] &lt;&lt; endl; &#125; // 迭代器遍历 for (string::iterator it = str.begin(); it &lt; str.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; endl; &#125; try&#123; for (int i = 0; i &lt; str.length()+2; i++) &#123; cout &lt;&lt; str.at(i) &lt;&lt; endl;// 如果越界会抛异常 &#125; for (int i = 0; i &lt; str.length()+2; i++) &#123; cout &lt;&lt; str[i] &lt;&lt; endl;// 会导致程序宕机，AS里面是可以的 &#125; &#125; catch (...)&#123; cout &lt;&lt; "异常了" &lt;&lt; endl; &#125; getchar();&#125; 添加 1234567891011121314void main()&#123; // 添加 string str1 = "123"; string str2 = "456"; // str1 = str1 + str2; // str1.append(str2); cout &lt;&lt; str1.c_str() &lt;&lt; endl; getchar();&#125; 删除 1234567891011121314151617void main()&#123; // 删除 string str1 = "123 abc 123 abc 123"; // str1.erase(0,3);// 第一个参数：从哪里开始 ； 第二个参数：删除几个（默认值，字符串的结尾） // 迭代器删除 2 bc 123 abc 123 解释 第一次删除第一个位置1，变为23 abc.... ，第二次删除第二个位置3,变为2 abc.... ,第三次删除第三个位置a，就是2 bc .... for (string::iterator it = str1.begin(); it&lt;str1.begin()+3; it++)// 删除一个字后都会从头开始计算 &#123; str1.erase(it); &#125; cout &lt;&lt; str1.c_str() &lt;&lt; endl; getchar();&#125; 替换 123456789101112void main()&#123; string str1 = "123 abc 123 abc 123"; // 第一个参数：从哪里开始 // 第二个参数：替换几个 // 第三个参数：替换成谁 str1.replace(0,6,"1234"); cout &lt;&lt; str1.c_str() &lt;&lt; endl; getchar();&#125; 查找 12345678910111213void main()&#123; string str1 = "123 abc 123 abc 123"; // 查找谁，从哪里开始 // int position = str1.find("123",0); // 从后面往前面查 int position = str1.rfind("123"); cout &lt;&lt; position &lt;&lt; endl; getchar();&#125; 大小写转换 123456789101112void main()&#123; string str1 = "AAA abc BBB abc 123"; // 转换成大写 // transform(str1.begin(), str1.end(), str1.begin(), toupper); transform(str1.begin(), str1.end(), str1.begin(), tolower); cout &lt;&lt; str1.c_str() &lt;&lt; endl; getchar();&#125; STL标准模板库 : 容器+迭代+算法 思想:集合，迭代器，算法 进行分离 vector容器（数组） https://zh.cppreference.com/w/cpp/container/vector123456789101112131415161718192021222324252627容量 向量大小： vec.size(); 向量真实大小： vec.capacity(); 向量判空： vec.empty();修改 末尾添加元素： vec.push_back(); 末尾删除元素： vec.pop_back(); 任意位置插入元素： vec.insert(); 任意位置删除元素： vec.erase(); 清空向量元素： vec.clear();迭代器 开始指针：vec.begin(); 末尾指针：vec.end(); //指向最后一个元素的下一个位置 指向常量的末尾指针： vec.cend();元素的访问 下标访问： vec[1]; //并不会检查是否越界 at方法访问： vec.at(1); //以上两者的区别就是at会检查是否越界，是则抛出out of range异常 访问第一个元素： vec.front(); 访问最后一个元素： vec.back(); stack容器（链表，数组）https://zh.cppreference.com/w/cpp/container/stack queue容器（数组，链表）https://zh.cppreference.com/w/cpp/container/queue list容器(链表)https://zh.cppreference.com/w/cpp/container/list set容器(红黑树，元素不重复)https://zh.cppreference.com/w/cpp/container/set multiset容器(元素可重复)https://zh.cppreference.com/w/cpp/container/multiset map容器(key不能重复)https://zh.cppreference.com/w/cpp/container/map multimap容器(以key分组)https://zh.cppreference.com/w/cpp/container/multimap 对象添加到容器需要注意的: java 中把对象添加到了集合,c++ 中会调用对象的拷贝构造函数，存进去的是另一个对象 在c++中将对象加入到容器，需要有默认的构造函数 析构函数也可能回调用多次，如果说在析构函数中释放内存，需要在拷贝构造函数中进行深拷贝 仿函数 123456789101112131415161718192021222324class Compare&#123; // 重载了括号运算符public: void operator()()&#123; cout &lt;&lt; "仿函数" &lt;&lt; endl; &#125;&#125;;void compare1()&#123; cout &lt;&lt; "普通函数" &lt;&lt; endl;&#125;// 函数对象（仿函数） 一元谓词，二元谓词void main()&#123; Compare compare; // 跟函数非常类似 compare();//打印“仿函数” // 普通函数调用 compare1(); getchar();&#125; 谓词 一元谓词 12345678910111213141516171819202122232425262728293031323334353637// 一元谓词void print(int number)&#123; cout &lt;&lt; number &lt;&lt; endl;&#125;// 仿函数 - 一元谓词 （能够记录状态）class PrintObj&#123;public: int count = 0;public: void operator()(int number)&#123; cout &lt;&lt; number &lt;&lt; endl; count++; &#125;&#125;;// 回调函数和仿函数的区别void main() &#123; set&lt;int&gt; set1; set1.insert(1); set1.insert(2); set1.insert(3); set1.insert(4); // for_each 迭代器 ,非常重要的一点就是：仿函数如果要保存记录状态，要确保对象一致，可以用返回值 // for_each(set1.begin(),set1.end(),print);//会打印 PrintObj printObj; //for_each(set1.begin(), set1.end(), printObj); //cout &lt;&lt; "个数：" &lt;&lt; printObj.count &lt;&lt; endl; //个数：0 ,要确保对象一致 printObj = for_each(set1.begin(), set1.end(), printObj); cout &lt;&lt; "个数：" &lt;&lt; printObj.count &lt;&lt; endl; //个数：4 ,对象一致 getchar();&#125; 二元谓词 123456789101112131415161718192021222324252627282930#include &lt;set&gt;#include &lt;iostream&gt;using namespace std;class CompareObj&#123;public: int count = 0;public: bool operator()(const string str1, const string str2) &#123; return str1 &gt; str2; &#125;&#125;;void main() &#123; // 二元谓词的仿函数 set&lt;string, CompareObj&gt; set1; set1.insert("aaa"); set1.insert("aAa"); set1.insert("ccc"); set1.insert("ddd"); // 是否包含 aaa , 遍历比较 ， 找方法 for (set&lt;string&gt;::iterator it = set1.begin(); it != set1.end(); it++) &#123; cout &lt;&lt; (*it).c_str() &lt;&lt; endl; &#125; //ddd ccc aaa aAa getchar();&#125; 预定义函数对象(自定义重载 () 运算符),函数适配器 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;functional&gt;#include&lt;algorithm&gt;using namespace std;// 自定义重载 () 运算符//预定义函数对象void main()&#123; // c/c++ 提供了很多定义好的函数对象 // 常见的几个 less ，greater，plus，equal_to plus&lt;string&gt; strAdd; string str = strAdd("aaa","bbb"); // cout &lt;&lt; str.c_str() &lt;&lt; endl; set&lt;string, greater&lt;string&gt;&gt; set1; set1.insert("aaa"); set1.insert("bbb"); set1.insert("ccc"); // 判断是不是包含 aaa // 怎么写仿函数，一定要确定好你的仿函数的参数 // bind2nd 函数适配器 , aaa 相当于 equal_to 中的 right set&lt;string, greater&lt;string&gt;&gt;::iterator find_it = find_if(set1.begin(), set1.end(),bind2nd(equal_to&lt;string&gt;(),"aaa")); if (find_it != set1.end())&#123; cout &lt;&lt; "找到了" &lt;&lt; (*find_it).c_str() &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "没有找到" &lt;&lt; endl; &#125; getchar();&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;functional&gt;#include&lt;algorithm&gt;using namespace std;class Equal&#123;private: int equal_number;public: Equal(int equal_number) &#123; this-&gt;equal_number = equal_number; &#125;public: bool operator()(const int&amp; number) &#123; return number == equal_number; &#125;&#125;;void main() &#123; vector&lt;int&gt; vector1; vector1.push_back(1); vector1.push_back(2); vector1.push_back(3); vector1.push_back(2); vector1.push_back(4); vector1.push_back(2); // 找集合中 等于 2 的个数 int count = count_if(vector1.begin(), vector1.end(), Equal(2)); cout &lt;&lt; "count = " &lt;&lt; count &lt;&lt; endl; // 预定义好的函数对象 + 函数适配器 count = count_if(vector1.begin(), vector1.end(), bind2nd(equal_to&lt;int&gt;(), 2)); cout &lt;&lt; "count = " &lt;&lt; count &lt;&lt; endl; getchar();&#125; foreach，transform 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;functional&gt;#include&lt;algorithm&gt;using namespace std;void print(int number) &#123; cout &lt;&lt; number &lt;&lt; endl;&#125;// 进行修改int transform_print(int number) &#123; // cout &lt;&lt; number &lt;&lt; endl; return number + 3;&#125;// foreach，transform，find，find_if，count，count_if，megre，sort，random_shuffle，copy，replace// 常用预定义算法 循环，增，删，改， void main() &#123; vector&lt;int&gt; vector1; vector1.push_back(1); vector1.push_back(2); vector1.push_back(3); vector1.push_back(4); //for_each循环 // for_each(vector1.begin(), vector1.end(),print); //1234 vector&lt;int&gt; vector2; vector2.resize(vector1.size()); //变换和循环 transform(vector1.begin(), vector1.end(), vector2.begin(), transform_print);//4567 for_each(vector2.begin(), vector2.end(), print); getchar();&#125; find，find_if 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;functional&gt;#include&lt;algorithm&gt;using namespace std;void print(int number) &#123; cout &lt;&lt; number &lt;&lt; endl;&#125;// 进行修改int transform_print(int number) &#123; // cout &lt;&lt; number &lt;&lt; endl; return number + 3;&#125;// foreach，transform，find，find_if，count，count_if，megre，sort，random_shuffle，copy，replace// 常用预定义算法 循环，增，删，改， void main() &#123; vector&lt;int&gt; vector1; vector1.push_back(1); vector1.push_back(2); vector1.push_back(3); vector1.push_back(4); vector&lt;int&gt;::iterator find_it = find(vector1.begin(), vector1.end(), 2); if (find_it != vector1.end())&#123; cout &lt;&lt; "包含" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "不包含" &lt;&lt; endl; &#125; // 有没有大于2的，自定义函数对象，预定义函数对象+函数适配器，省略... //findif() //上面有 getchar();&#125; count，count_if 1234567891011121314151617181920212223void main()&#123; vector&lt;int&gt; vector1; vector1.push_back(1); vector1.push_back(2); vector1.push_back(3); vector1.push_back(2); vector1.push_back(4); int number = count(vector1.begin(), vector1.end(), 2); cout &lt;&lt; "等于2的个数:" &lt;&lt; number &lt;&lt; endl; number = count_if(vector1.begin(), vector1.end(), bind2nd(less&lt;int&gt;(), 2)); cout &lt;&lt; "小于2的个数:" &lt;&lt; number &lt;&lt; endl; number = count_if(vector1.begin(), vector1.end(), bind2nd(greater&lt;int&gt;(), 2)); cout &lt;&lt; "大于2的个数:" &lt;&lt; number &lt;&lt; endl; getchar();&#125; megre: 两个有序数组进行合并 - 归并排序 1234567891011121314151617181920212223242526272829using namespace std;void print(int number) &#123; cout &lt;&lt; number &lt;&lt; endl;&#125;// megre，sort，random_shuffle，copy，replacevoid main() &#123; // 两个有序数组进行合并 - 归并排序 vector&lt;int&gt; vector1; vector1.push_back(1); vector1.push_back(2); vector1.push_back(3); vector&lt;int&gt; vector2; vector1.push_back(4); vector1.push_back(5); vector1.push_back(6); vector&lt;int&gt; vector3; vector3.resize(6); merge(vector1.begin(), vector1.end(), vector2.begin(), vector2.end(), vector3.begin()); for_each(vector3.begin(), vector3.end(), print); getchar();&#125; soft，random_shuffle 123456789101112131415161718192021222324void print(int number) &#123; cout &lt;&lt; number &lt;&lt; endl;&#125;// sort，random_shufflevoid main() &#123; vector&lt;int&gt; vector1; vector1.push_back(1); vector1.push_back(3); vector1.push_back(2); vector1.push_back(4); sort(vector1.begin(), vector1.end(), less&lt;int&gt;()); for_each(vector1.begin(), vector1.end(), print); cout &lt;&lt; "循环结束" &lt;&lt; endl; // 打乱循序 random_shuffle(vector1.begin(), vector1.end()); for_each(vector1.begin(), vector1.end(), print); getchar();&#125; copy，replace 123456789101112131415161718192021222324void print(int number) &#123; cout &lt;&lt; number &lt;&lt; endl;&#125;//copy，replacevoid main() &#123; vector&lt;int&gt; vector1; vector1.push_back(1); vector1.push_back(2); vector1.push_back(3); vector1.push_back(4); vector&lt;int&gt; vector2; vector2.resize(2); copy(vector1.begin(), vector1.begin() + 2, vector2.begin()); for_each(vector2.begin(), vector2.end(), print); replace(vector1.begin(), vector1.end(), 2, 22); for_each(vector1.begin(), vector1.end(), print); getchar();&#125;]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语法进阶]]></title>
    <url>%2Fc%E8%AF%AD%E6%B3%95%E8%BF%9B%E9%98%B6.html</url>
    <content type="text"><![CDATA[数组参数传递 我们先看个例子，main入口 ，同样的代码打印的信息不一样。12345678910111213141516171819202122232425262728293031323334353637#include "stdafx.h"#include "stdio.h"void print2(int* arr) &#123; int len = sizeof(arr) / sizeof(int); printf("len =%d\n", len);//len = 1 int i = 0; for (; i &lt; len; i++) &#123; printf("%d\n", arr[i]); &#125;&#125;void print(int arr[]) &#123; int len = sizeof(arr) / sizeof(int); printf("len =%d\n", len);//len = 1 int i = 0; for (; i &lt; len; i++) &#123; printf("%d\n", arr[i]); &#125;&#125;int main()&#123; int arr[] = &#123; 1,2,3,4,5 &#125;; int len = sizeof(arr) / sizeof(int); printf("len =%d\n", len);//len = 5 print(arr); printf("===================\n"); print2(arr); printf("===================\n"); getchar(); return 0;&#125; 从这demo我们可以看到，数组作为参数传递的时候为什么获取不到长度？ 数组作为参数传递，会退化成为一个指针，传递的是首地址 （高效） 数据类型剖析 数据类型本质: 一块连续大小的内存空间demo112int a; //告诉c和c++编译器开辟一块连续大小的4字节的内存空间a =32; demo21234567891011121314151617181920212223int main()&#123; int arr[] = &#123; 1,2,3,4,5 &#125;;//内存大小空间 4x5=20 printf("%d , %d,%d ,%d", arr,arr+1,&amp;arr,&amp;arr+1);// 17758788 ,17758792,17758788 ,17758808 getchar(); return 0;&#125;``` 2. 数据类型别名```c/* Primitive types that match up with Java equivalents. */typedef uint8_t jboolean; /* unsigned 8 bits */typedef int8_t jbyte; /* signed 8 bits */typedef uint16_t jchar; /* unsigned 16 bits */typedef int16_t jshort; /* signed 16 bits */typedef int32_t jint; /* signed 32 bits */typedef int64_t jlong; /* signed 64 bits */typedef float jfloat; /* 32-bit IEEE 754 */typedef double jdouble; /* 64-bit IEEE 754 *//* "cardinal indices and sizes" */typedef jint jsize; void* 代表任意的数据类型的指针 变量的本质 变量的本质：固定内存块大小(一块连续大小的内存空间)的别名,通过变量去操作一块内存上的数据 变量的三要素：内存大小，名称，作用域 内存四驱模型 程序运行流程 操作系统会将物理磁盘上的代码load到内存 加载到内存后会将c代码分为4个区 后系统找到main程序入口运行 四驱模型 栈区: 由编译器自动分配的，存放一些局部变量和函数，内存会自动进行回收。 堆区: 一般由开发者自己开辟的，内存需要手动释放 malloc–&gt;free new–&gt;delete等。 全局区（数据区）: 静态的一些常量，字符串等。 程序代码区: 存放函数的二进制代码。 1234567891011121314151617181920212223242526272829303132333435363738struct Student&#123; int age;&#125;;typedef Student _Student;void change(int number) &#123; number = 300; printf("%p\n", &amp;number);//00B3F928&#125;void change(int* p_number) &#123; *p_number = 300; printf("%p\n", p_number);//00B3F9FC&#125;void chanegStudentAge(_Student student) &#123; student.age = 20; printf("%p\n", &amp;student);//0135F74C&#125;void main() &#123; int a = 10; a = 20; change(a);//把a的值复制给了number printf("a =%d\n",a); //a = 20 change(&amp;a);//直接操作a的地址 printf("a =%d\n", a); //a = 300 _Student student = _Student(); student.age = 5; printf("student =%d\n", &amp;student); //student =20314144 chanegStudentAge(student); printf("age = %d", student.age); getchar();&#125; 不管是基本数据类型还是结构体，c都是值传递，和java不同的是，java基本数据类型是值传递，对象是引用传递。所以在c当中一般都是指针传递 change(int number)changep(int* p_number) 栈的开口方向12345int a=5;//先入栈int buffer[]=&#123;1,2,3&#125;;int b=7;fprint("%p , %p",&amp;a,&amp;b); 如果地址a&gt;b(debug)，说明开口向下。a&lt;b(release)开口向上。buffer数据类型的方向和栈的开口方向没关系，都是向上。&amp;buffer[0]&gt;&amp;buffer[1] 指针强化 指针也是一种数据类型，虽然占用四个字节，但是有数据类型。 野指针1234567891011121314151617181920212223struct Student&#123; int age;&#125;;void main() &#123; Student* student =(Student*)malloc(sizeof(Student)); //释放的时候记得判断为NULL if (student != NULL) &#123; free(student);//这个时候student变为野指针 //我们不需要的话最好置为NULL student = NULL; &#125; //释放的时候记得判断为NULL,这个时候就不会去free，从而避免错误 if (student != NULL) &#123; free(student); &#125; getchar();&#125; NULL NULL也是一个内存指针，指针指向00000000，只不过我们不能进行操作。12printf("NULL=%p", NULL); //NULL=00000000 字符串和 buffer 强化 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465void main() &#123; char buffer[100] = &#123;'1','2','3'&#125;;//后面3-99 都是默认值0 //长度 printf(" strlen(buffer) = %d\n", strlen(buffer));//strlen(buffer) = 3 根据\0结束计算 //内存 printf(" sizeof(buffer) = %d\n", sizeof(buffer));//sizeof(buffer) = 100 //内容 printf("%d %d %d \n",buffer[0], buffer[3], buffer[75]);//49 0 0 printf("-------------------------------\n"); char buffer1[] = &#123; '1','2','3' &#125;; //长度 printf(" strlen(buffer1) = %d\n", strlen(buffer1));//strlen(buffer1) = 15 根据\0结束计算 //内存 printf(" sizeof(buffer1) = %d\n", sizeof(buffer1));//sizeof(buffer1) = 3 //内容 printf("%d %d %d \n", buffer1[0], buffer1[3], buffer1[8]);//49 -52 -52 //char buffer2[2] = &#123; '1','2','3' &#125;; 这个直接就报错了 编译不通过 printf("-------------------------------\n"); char buffer3[100] = &#123; '1','2','\0', '2' &#125;;//后面4-99 都是默认值0 //长度 printf(" strlen(buffer3) = %d\n", strlen(buffer3));//strlen(buffer3) = 2 根据\0结束计算 //内存 printf(" sizeof(buffer3) = %d\n", sizeof(buffer3));//sizeof(buffer3) = 100 //内容 printf("%d %d %d %d %d \n", buffer3[0], buffer3[1], buffer3[2], buffer3[3], buffer3[8]);//49 50 0 50 0 printf("-------------------------------\n"); char buffer4[100] = &#123; '0' &#125;;//把数据初始化为0 //长度 printf(" strlen(buffer4) = %d\n", strlen(buffer4));//strlen(buffer4) = 1 根据\0结束计算 //内存 printf(" sizeof(buffer4) = %d\n", sizeof(buffer4));//sizeof(buffer4) = 100 //内容 printf("%d %d %d %d %d \n", buffer4[0], buffer4[1], buffer4[2], buffer4[3], buffer4[8]);//48 0 0 0 0 printf("-------------------------------\n"); char buffer5[100] ; //数据全部默认为-52 //长度 printf(" strlen(buffer5) = %d\n", strlen(buffer5));//strlen(buffer5) = 109 根据\0结束计算 //内存 printf(" sizeof(buffer5) = %d\n", sizeof(buffer5));//sizeof(buffer5) = 100 //内容 printf("%d %d %d %d %d \n", buffer5[0], buffer5[1], buffer5[2], buffer5[3], buffer5[8]);//-52 -52 -52 -52 -52 printf("-------------------------------\n"); //char *buffer6 = "hello"; //和下面一样的 char buffer6[] = "hello"; // 相当于"hello\0" //char * ,char[],malloc区别:前两个都是在栈里开辟内存，字符串放在常量区，数组定义的是将常量区的数据copy过来到char[]里面(这样的话栈里也有了数据)，char*是直接指针指向常量，malloc的方式是在堆里面开辟内存，存储数据到堆里 //长度 printf(" strlen(buffer6) = %d\n", strlen(buffer6));//strlen(buffer6) = 5 根据\0结束计算 //内存 printf(" sizeof(buffer6) = %d\n", sizeof(buffer6));//sizeof(buffer6) = 6 //内容 printf("%d %d %d %d %d \n", buffer6[0], buffer6[1], buffer6[2], buffer6[3], buffer6[8]);//104 101 108 108 -52 getchar();&#125; char * ,char[],malloc区别:前两个都是在栈里开辟内存，字符串放在常量区，数组定义的是将常量区的数据copy过来到char[]里面(这样的话栈里也有了数据)，char*是直接指针指向常量，malloc的方式是在堆里面开辟内存，存储数据到堆里。从而可以知道，字符串可以在任何区域开辟内存。如图，栈中从上往下依次是char[],char*,malloc() 开发模型强化 确定参数，传递指针 一定要考略健壮性 异常错误，抛出说明 不要直接轻易的去改变调用者传递给你的指针，如需必要可以先考略临时的变量操作。可以加上const修饰参数强制不可修改。 123456789101112131415161718192021222324252627282930313233343536struct AndroidBitmapInfo&#123; int width; int height; int format;&#125;;int androidBitmapGetInfo(AndroidBitmapInfo * pAndroidBitmapInfo) &#123; //2. 健壮性考略 if (pAndroidBitmapInfo == NULL) &#123; printf("pAndroidBitmapInfo is null"); //3. 异常错误，抛出说明 return -1; &#125; //4. 不要直接轻易的去改变调用者传递给你的指针 //pAndroidBitmapInfo = &amp;AndroidBitmapInfo(); pAndroidBitmapInfo-&gt;height = 1920; pAndroidBitmapInfo-&gt;width = 1080; return 0;&#125;void main() &#123; //1. 确定参数，传递指针 AndroidBitmapInfo androidBitmapInfo; int ret =androidBitmapGetInfo(&amp;androidBitmapInfo); if (ret == 0) &#123; printf("w=%d,h=%d", androidBitmapInfo.width, androidBitmapInfo.height); &#125; getchar(); &#125; 结构体强化 在c中=是赋值操作。 12345678910111213typedef struct &#123; char name[50]; int age;&#125;Student;void main() &#123; Student stu1 = &#123;"张三",35&#125;; Student stu2; stu2 = stu1; printf("%p , %p \n", &amp;stu1, &amp;stu2);//007CFD7C , 007CFD3C printf("%s , %d \n", stu2.name, stu2.age);//张三 , 35 getchar(); &#125; 在结构体里面套指针 1234567891011121314151617181920212223242526272829303132#include "stdafx.h"#include "stdio.h"#include &lt;string.h&gt;#include &lt;Windows.h&gt;//结构体套指针，必须要对结构体指针进行初始化（赋值）//指针可以指向任何地址，但是它的大小永远是4字节typedef struct &#123; char* name;// 定义了一个name指针 int age;&#125;Student;void main() &#123; Student stu; // 1. //stu.name = "李四"; // 将指针指向常量区的"李四" //2. //往stu.name里面copy数据 "李四" 不能直接copy //strcpy(stu.name, "李四"); //3. //首先把char* name 指向堆区开辟的内存 ，然后把常量区的数据"李四" copy到堆里面 stu.name =(char*) malloc(100); strcpy(stu.name, "李四"); stu.age = 35; printf("%s , %d \n", stu.name, stu.age);//李四 , 35 getchar(); &#125; 深copy和浅copy 12345678910111213141516171819202122232425262728293031323334353637383940414243typedef struct &#123; char *name; int age;&#125;Student;void copyToP(Student* from, Student *to) &#123; //浅copy *to = *from; //深copy to-&gt;name = (char*)malloc(100);//开辟内存 strcpy(to-&gt;name, from-&gt;name);//copy值&#125;;void main() &#123; char * name =(char*) malloc(100); Student stu = &#123;name,25&#125;; strcpy(stu-&gt;name, "张三"); stu.age = 35; printf("%s , %d \n", stu.name, stu.age);//张三 , 35 Student stu2 = &#123;"李四",15&#125;; copyToP(&amp;stu2,&amp;stu); printf("%s , %d \n", stu2.name, stu2.age);//张三 , 35 if (stu.name) &#123; free(stu.name); stu.name = NULL; &#125; if (stu2.name) &#123;//如果是浅copy会释放出错，因为stu.name和stu2.name指向一个位置 stu.name已经free了 free(stu2.name); stu2.name = NULL; &#125; getchar(); &#125; 结构体的偏移量 ：见c基础的结构体内存开辟以及内存计算]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c基础]]></title>
    <url>%2Fc%E5%9F%BA%E7%A1%80.html</url>
    <content type="text"><![CDATA[基本数据类型以及打印 1234567891011121314151617void main() &#123; int i = 100; double d = 200; float f = 200; long l = 200; short s = 100; char c = 'D'; // 字符串 char * printf("i = %d\n" ,i); printf("d = %lf\n" ,d); printf("f = %f\n" ,f); printf("l = %ld\n" ,l); printf("s = %d\n" ,s); printf("c = %c\n" ,c); getchar();//&#125; 指针123456789101112131415161718192021222324252627// 指针（变量）地址：任何的数据 （变量）都会有地址（住址门牌号） // &amp;+变量名就是地址 // *+地址就是取值 void main() &#123; int i = 100; //获取地址 printf("i的地址是: %p\n", &amp;i);//xxxxxx printf("i的值是: %d\n", i);//100 //获取地址的值 printf("i的值是: %d\n", *&amp;i);//100 //指针(地址)变量：指针存放（指向）的就是变量的地址 int* p = &amp;i; //取值 printf("i的值是: %d\n", *p) //100 double d = 200; double* p1 = &amp;d; //通过指针修改值 *p = 200; printf("i的值是: %d\n", i) // 200 getchar();&#125; 指针为什么要有类型？ 指针其实就是一块地址而且值都差不多，为什么要有类型？ 1.取值的时候我要知道怎么取？int 4个字节取 double8个字节取 2.取值的偏移？int偏4个字节 double偏8个字节 常量指针 指针常量123常量变量：被常量修饰的变量，不能再次被赋值 （Java）常量指针：const 在 * 之前，指针的地址是可以被再次赋值的（可以修改的），指针地址上面的值（变量）是不能被修改的，常量指针的常量是不能被改变的。指针常量：const 在 * 之后，指针的地址是不可以被再次赋值的（不可以修改的），指针地址上面的值（变量）能被修改的，指针常量的指针地址是不能被改变的。 基本数据类型所占字节数 123456void main() &#123; printf("int 数据类型所占字节数: %d\n",sizeof(int));//4 printf("double 数据类型所占字节数: %d\n", sizeof(double));//8 printf("char 数据类型所占字节数: %d\n", sizeof(char));//1 getchar();&#125; 二级指针 123456789void main() &#123; int num = 142; int* p = &amp;num; int** s_p = &amp;p; printf("p = %p, s_p = %p", p, s_p); printf("num = %d ", **s_p); //142 getchar();&#125; 数组与数组指针12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//数组与数组指针void main() &#123; int arr[] = &#123; 1, 2, 3, 4 &#125;; //arr的值=arr取地址的值 ， arr地址的值 = arr[0]的地址的值（首地址） 他们三个是一个地址 printf("arr = %p\n", arr); // arr = 000000137F6FFAA8 printf("arr&amp; = %p\n", &amp;arr);// arr&amp; = 000000137F6FFAA8 printf("arr[0]&amp; = %p\n", &amp;arr[0]);// arr[0]&amp; = 000000137F6FFAA8 //如何获取数组的指针（首地址） int* arr_p = arr; printf("%d \n", *arr_p); // 1 //对数组指针++ arr_p++; printf("%d \n", *arr_p); // 2 arr_p += 2; printf("%d \n", *arr_p); // 4 arr_p ++; printf("%d \n", *arr_p); // -858993460 这里因为已经超出数组长度了 //遍历 int arr2[] = &#123; 5, 8, 9, 4 &#125;;// for (i = 0; i &lt; 4; i++) &#123;// printf("%d\n", arr2[i]);// &#125;//注意for循环的写法，要写成下面这个 写成java的那种，可能会造成操作系统（Linux）不一样而编译不了 //c拿不到arr长度 int i = 0; for (; i &lt; 4; i++) &#123; printf("%d\n", arr2[i]); &#125; //通过指针来循环遍历 int* arr2_p = arr2; int j = 0; for (; j &lt; 4; j++) &#123; arr2_p++; printf("%d\n", *arr2_p); &#125; //数组指定长度 int arr3[4]; int* arr3_p = arr3; int k = 0; for (; k &lt; 4; k++) &#123; *(arr3_p + k) = k*10; &#125; k = 0; for (; k&lt; 4; k++) &#123; printf("%d\n", arr3_p[k]); &#125; getchar();&#125; 数组指针操作的常用几种方式12345678910111213//数组指针操作的常用几种方式void main() &#123; int arr[] = &#123; 1,3,5,7 &#125;; int i = 0; for (; i &lt; 4; i++) &#123; //第一种 printf("位置%d的值是:%d\n", i, *(arr + i)); //第二种 printf("位置%d的值是:%d\n", i, arr[i]); //.... &#125; getchar();&#125; 函数指针(回调)12345678910111213141516171819202122232425262728293031//函数指针void main() &#123; //方法的返回类型(*方法的名称)（方法的参数） void(*add_p)(int, int) = add;// void(*add_p)(int, int) = &amp;add; //这个一样的 //正常调用 add(1, 2); //指针调用 (*add_p)(1, 2); opeate(add, 1, 2); opeate(mins, 1, 2); getchar();&#125;void add(int num1, int num2) &#123; printf("num1+num2=%d\n", num1 + num2);&#125;void mins(int num1, int num2) &#123; printf("num1-num2=%d\n", num1 - num2);&#125;//方法的返回类型(*方法的名称)（方法的参数）void opeate(void(*method)(int, int), int num1, int num2) &#123; method(num1, num2);&#125; 内存开辟123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;//静态开辟内存 方法结束会自动回收void staticlloc() &#123; int arr[5]; int i = 0; for (; i &lt; 5; i++) &#123; arr[i] = i; printf("%d %p\n", *(arr + i),arr+i); &#125;&#125;//动态开辟内存 方法结束不会自动回收void dynamiclloc() &#123; //malloc申请需要的内存返回void* 这里强转成你需要的指针类型 int* arr = (int*)malloc(10 * 1024 * 1024 * sizeof(int));//40M&#125;//动态开辟内存 方法结束不会自动回收 手动释放void dynamiclloc2free() &#123; //malloc 申请需要的内存返回void* 这里强转成你需要的指针类型 int* arr = (int*)malloc(10 * 1024 * 1024 * sizeof(int));//40M //手动释放 free(arr);&#125;//内存开辟void main()&#123; //Stack overflow 栈溢出 // int arr[10*1024*1024];//占用内存？数组大小10M，int占用4字节，40M的内存空间 //c里面有四驱模型 //栈:占用的内存空间大小 ,开辟内存的方式是静态内存开辟 int arr[10*1024*1024]，方法结束会自动回收 //堆:占用内存空间最大值 80% ，开辟内存的方式是动态内存开辟，方法结束不会自动回收，需要手动回收 //静态开辟内存,函数结束会自动回收 内存开辟后不可变 /* //这里运行 内存不会上升，staticlloc()函数结束会自动回收 while (true)&#123; Sleep(100); staticlloc(); &#125; */ //动态内存开辟 内存开辟后可变 /* //这里运行 内存会持续上升 while (true) &#123; Sleep(100); dynamiclloc(); &#125; */ //这里运行 内存不会持续上升，因为手动释放了 while (true) &#123; Sleep(100); dynamiclloc2free(); &#125; getchar();&#125; 内存开辟使用场景 12345678910111213141516171819202122232425262728293031323334#include&lt;stdio.h&gt;#include&lt;Windows.h&gt;//使用场景void main() &#123; //假设我们现在需要接受用户所输入的数，然后进行排序 int num; printf("请输入数的个数: "); //获取用户输入的值 scanf_s("%d",&amp;num); //定义一个数组来存放用户的数据 //int arr[num]; 静态开辟 int* arr =(int*) malloc(sizeof(int) * num); int print_num; int i = 0; for (; i &lt; num; i++) &#123; printf("请输入第%d个的值: ", i); scanf_s("%d", &amp;print_num); arr[i] = print_num;//arr[i] = *(arr+i); &#125; //对arr排序 //.... //回收动态开辟的内存 free(arr); getchar();&#125; 改变内存大小 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//改变内存空间大小void main() &#123; int num; printf("请输入数的个数: \n"); //获取用户输入的值 scanf_s("%d", &amp;num); int* arr = (int*)malloc(sizeof(int) * num); printf("arr的指针: %p \n",arr); int print_num; int i = 0; for (; i &lt; num; i++) &#123; arr[i] = i;//arr[i] = *(arr+i); &#125; int new_num; //在加点内存 printf("请输入新增的个数： \n"); //获取用户输入的值 scanf_s("%d", &amp;new_num); //改变内存大小空间 int new_size = sizeof(int)* (num + new_num); //ptr - 指向需要重新分配的内存区域的指针 //new_size - 数组的新大小（字节数） //tip1. 这里默认new_arr的指针和arr的指针是同一个，后面赋值可以接着后面的赋值 //tip2. 如果连续内存不足的话返回的话可能是新的指针,那么将要全部重新赋值 //tip3. 新增内存有可能会失败（内存被系统占用或者内存不够用了），失败的时候返回的是 NULL //tip4. realloc的arr 释放的时候也务必要进行判断NULL，释放完我们最好把指针致为NULL //tip5. 不要反复去释放 int* new_arr =(int*) realloc(arr, new_size); printf("new_arr的指针: %p \n", new_arr); if (new_arr) &#123;// if(new_arr!=NULL) //tip 1. 这里默认new_arr的指针和arr的指针是同一个，后面赋值可以接着后面的赋值 for (; i &lt; num + new_num; i++) &#123; arr[i] = i;//arr[i] = *(arr+i); &#125; //tip 2. 如果连续内存不足的话返回的话可能是新的指针,那么将要全部重新赋值 i = 0; for (; i &lt; num + new_num; i++) &#123; arr[i] = i;//arr[i] = *(arr+i); &#125; i = 0; for (; i &lt; num + new_num; i++) &#123; printf("%d \n", arr[i]); &#125; &#125; getchar(); if (new_arr) &#123; //这里arr将不手动回收 //free(arr); free(new_arr); new_arr = NULL; &#125;else &#123; free(arr); &#125; getchar();&#125; 字符串定义 1234567891011121314void main() &#123; //第一种 字符串数组 char str[] = &#123;'a','b','c','d','\0'&#125;; printf("%s", str);//字符串结尾是 '\0' //第二种 常用的 const char *str1 = "abcde"; printf("%s", str1); //区别 前者能修改 后面不能修改 // str[1] = 'x'; // strstr11] = 'x'; //报错 getchar();&#125; 字符串基本api123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;ctype.h&gt;//自己实现 获取字符串长度int strlen_(const char *str) &#123; int len = 0; while (*str != '\0') &#123; len++; str++; &#125; return len;&#125;//大小写转换void lower(char* dest,const char* source) &#123; while (*source!='\0') &#123; //当前字符串 char ch = *source; //转完复制给dest *dest = tolower(ch); source++; dest++; &#125; *dest = '\0';&#125;//字符串截取 动态内存开辟 用了需要free ndk使用需要静态开辟char* substr(const char* str, int startIndex, int endIndex) &#123; //开辟一个内存来存数据 ndk里面使用静态开辟内存 这里vs编辑器会报错所以动态开辟了 //char* subStr[endIndex - startIndex + 1]; int len = endIndex - startIndex; //这里要注意free char* subStr = (char*)malloc(len * sizeof(char) + 1); //赋值 int i = 0; str += startIndex; for (; i &lt; len; i++) &#123; subStr[i] = *str; str++; &#125; subStr[len] = '\0';//标记字符串结尾，否则printf无法判断结尾 return subStr;&#125;const char* replace(const char*oldChar, const char*newChar,const char*source) &#123; //1. 有没有oldChar const char* pos = strstr(source, oldChar); if (!pos) &#123; return source; &#125; //2. 计算新的数组大小 int newArraySize = strlen(source) - strlen(oldChar) + strlen(newChar); //vs不能这样 as最好用静态的 //char result[newArraySize]; char* result = (char*)malloc(sizeof(char)*newArraySize); //3. 进行拼接 int startIndex= pos - source; char* start = substr(source,0, startIndex); char* end = substr(source, startIndex + strlen(oldChar), strlen(source)); strcpy(result,start); strcat(result, newChar); strcat(result, end); //释放资源 free(start); free(end); //全部替换 while或者递归 return replace(oldChar, newChar, result);&#125;void main() &#123; //字符串长度获取 const char *str = "HelloGirl\0"; //#include &lt;string.h&gt; printf("len = %d \n", strlen(str)); // len = 9 printf("len_ = %d \n", strlen_(str)); // len_ = 9 //字符串转换 const char *intStr = "5"; //#include &lt;stdlib.h&gt; //int num = 0 如果不能转换为int的就会返回0，后面如果不是数字的会被干掉 “12xxx”-&gt; 12 printf("int num = %d \n", atoi(str)); printf("int num = %d \n", atoi(intStr));//int num = 5 const char *floatStr = "0.012"; //#include &lt;stdlib.h&gt; //float num = 0.000000 如果不能转换为float的就会返回0.000000，后面如果不是数字的会被干掉 “0.012xx”-&gt; 0.012000 printf("float num = %f \n", atof(str)); printf("float num = %f \n", atof(floatStr));//float num = 0.012000 //strol strod ... //字符串比较 const char *str1 = "Hello"; const char *str2 = "hello"; //区分大小写比较 int rc = strcmp(str1,str2); if (rc == 0) &#123; printf("相等\n"); &#125;else &#123; printf("不相等\n"); // 不相等 &#125; //不区分大小写比较 rc = _strcmpi(str1,str2); // c-&gt;strcmpi c++-&gt;_strcmpi android ndk -&gt; strcasecmp if (rc == 0) &#123; printf("相等\n");//相等 &#125;else &#123; printf("不相等\n"); &#125; //比较前几个 const char *str11 = "Hello"; const char *str21 = "Hello girl"; rc = strncmp(str11, str21,5);//5-&gt;_MaxCount 代表的是比较字符串前几个是否相等 if (rc == 0) &#123; printf("相等\n");//相等 &#125; else &#123; printf("不相等\n"); &#125; //字符串查找 计算位置 const char *str0 = "Hello"; const char *subStr0 = "e"; const char* s= strstr(str0, subStr0);//返回字符串第一次出现的位置（位置指针），如果没有返回NULL int pos = s - str0; if (s) &#123;//代表包含 printf("%s 第一次位置在%d\n ", s, pos);// ello 第一次位置在1 &#125;else &#123; printf("%s", "没有找到"); &#125; //copy const char * strh = "hello"; //char dst[strlen(strh)+1]; //不知道为什么要报错 在as里面可以的 char dst[6]; // error C4996 : 'strcpy' : This function or variable may be unsafe.Consider using strcpy_s instead.To disable deprecation, use _CRT_SECURE_NO_WARNINGS.See online help for details. strcpy(dst, strh); printf("%s\n", dst); //hello //拼接 const char *str001 = "Gril"; strcat(dst,str001); printf("%s\n", dst); //helloGril //截取 char *subStr = substr(dst,1,4); printf("%s\n", subStr); //ell free(subStr); //大小写转换 const char *hello = "HELLO"; char helloLower[6]; lower(helloLower, hello); printf("%s\n", helloLower);//hello //字符串替换 const char* rs= replace("LL","AA","HELLOLL"); printf("%s", rs); // HEAAOAA //free(rs); getchar();&#125; 结构体 java的class12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;stdio.h&gt;#include &lt;string.h&gt;//第一种方式struct Worker &#123;//定义一个结构体 相当于java的class char name[10]; int age; double salary;&#125;;//第二种方式，可以直接取名字struct Worker2 &#123;//定义一个结构体 相当于java的class char name[10]; int age; double salary;&#125;zhangsan, lisi = &#123;"李四",25,20&#125;;struct Work&#123; char name[10]; char grade[10];&#125;;//第三种方式，结构体的嵌套struct Worker3&#123; char name[10]; int age; double salary; Work work;&#125;;//第四种方式，结构体的嵌套,直接在内部定义 java内部类 这种不测了 一样的道理struct Worker4 &#123; char name[10]; int age; double salary; Work work; struct Work &#123; //... &#125;work; //struct Work&#123; // //... //&#125;work;&#125;;//第一种方式void test1() &#123; // struct Worker worker;//第一种方式没有初始化的情况下，里面的属性都没有初始值的 struct Worker worker = &#123; "张三",25,120 &#125;; printf("name = %s,age = %d ,salary = %lf \n", worker.name, worker.age, worker.salary);//name = 张三,age = 25 ,salary = 120.000000 //赋值 worker.age = 85; // worker.name = "李四"; strcat_s(worker.name, "李四"); printf("修改之后了name = %s,age = %d ,salary = %lf", worker.name, worker.age, worker.salary);//修改之后了name = 张三李四,age = 85 ,salary = 120.000000&#125;//第二种方式void test2() &#123;//这种方式有默认的初始值 printf("name = %s,age = %d ,salary = %lf \n", zhangsan.name, zhangsan.age, zhangsan.salary);//name = ,age = 0 ,salary = 0.000000 strcat_s(zhangsan.name, "张三"); zhangsan.age = 50; printf("修改之后了name = %s,age = %d ,salary = %lf \n", zhangsan.name, zhangsan.age, zhangsan.salary);//修改之后了name = 张三,age = 50 ,salary = 0.000000 printf("name = %s,age = %d ,salary = %lf \n", lisi.name, lisi.age, lisi.salary);// name = 李四,age = 25 ,salary = 0.000000&#125;void test3() &#123; struct Worker3 worker = &#123; "张三",50,10000,&#123; "Android","mid"&#125;&#125;; //name = 张三,age = 50 ,salary = 10000.000000 ,worker.name = Android,worker.grade = mid printf("name = %s,age = %d ,salary = %lf ,worker.name = %s,worker.grade = %s \n", worker.name, worker.age, worker.salary, worker.work.name,worker.work.grade);&#125;void main() &#123; // test1();// test2(); test3(); getchar();&#125; 结构体指针123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;struct Worker&#123; char name[10]; int age;&#125;;//第一种方式void test1()&#123; struct Worker worker = &#123; "张三",56 &#125;; Worker* worker_p = &amp;worker; //结构体一般用worker.name ="" 指针一般用worker_p-&gt;name ="" worker_p-&gt;age = 24; strcpy(worker_p-&gt;name, "李四"); printf("name = %s,age= %d \n", worker_p-&gt;name, worker_p-&gt;age);//name = 李四,age= 24&#125;//第二种方式 比较常用 void test2() &#123; Worker *worker_p =(Worker*) malloc(sizeof(Worker)); strcpy(worker_p-&gt;name, "李四"); worker_p-&gt;age = 24; printf("name = %s,age= %d \n", worker_p-&gt;name, worker_p-&gt;age);//name = 李四,age= 24 //释放 if (worker_p) &#123; free(worker_p); worker_p = NULL; &#125;&#125;int main() &#123;// test1(); test2(); getchar(); return 0;&#125; 结构体内存开辟以及内存计算内存大小参考123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;struct Worker&#123; char name[10]; int age; //计算大小: //1. char name[10] -&gt; sizeof(char) = 1 * 10 =10; //2. int age -&gt; sizeof(char) = 4 之前的偏移是10，不是4的整数，偏移两个单位到12 然后+4 = 16 //3. 16是 结构体里面基本数据类型最大int 4的整数，所以最终结果为16&#125;;//静态开辟void test1() &#123; Worker worker[10] = &#123; &#123;"张三",35&#125; &#125;;//静态开辟 worker[9] = &#123;"lisi",25&#125;; printf("name0 = %s ,age0 = %d \n",worker[0].name,worker[0].age);//name0 = 张三 ,age0 = 35 printf("name9 = %s ,age9 = %d \n",worker[9].name,worker[9].age);//name9 = lisi ,age9 = 25&#125;//动态开辟 void test2() &#123; Worker* worker =(Worker*) malloc(sizeof(Worker) * 10); strcpy(worker-&gt;name,"张三"); worker-&gt;age = 25; printf("name= %s ,age = %d \n",worker-&gt;name,worker-&gt;age);//name= 张三 ,age = 25 //对第9个数做操作 worker += 9; strcpy(worker-&gt;name, "李四"); worker-&gt;age = 35; printf("name= %s ,age = %d \n", worker-&gt;name, worker-&gt;age);//name= 李四 ,age = 35&#125;//内存怎么计算的? void test3() &#123; //计算规则 //1. 每个成员的偏移量都必须是当前成员所占内存大小的整数倍如果不是编译器会在成员之间加上填充字节。 //2. 当所有成员大小计算完毕后，编译器判断当前结构体大小是否是结构体中最宽的成员变量大小的整数倍 如果不是会在最后一个成员后做字节填充。 int size = sizeof(Worker); printf("size = %d",size);//size = 16&#125;struct date //12&#123; int year; int month; int day; // 都是4 3*4 = 12；&#125;;struct student&#123; int number;//4 char sex;//1 int gae;//4 char name[10];//10 struct date birthday;//12 //1. int number = 4 //2. char sex; 4+1=5; //3. int age;之前的偏移量是5,不是int 4字节的整数，所以偏移到8，然后+4 =12 //4. char name[10] 12+10=22 //5. 12+22 = 34 //6. 34不是这里面最大基本数据类型int 4的整数，所以最终结果是36 &#125;;void test4() &#123; int size = sizeof(date); printf("date size = %d\n", size);//size = 12 size = sizeof(student); printf("student size = %d\n", size);//size = 36&#125;int main() &#123;// test1();// test2();// test3(); test4(); getchar(); return 0;&#125; 结构体或结构体指针别名123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;struct Worker&#123; char name[10]; int age;&#125;;//对结构体指定别名//别名typedef Worker Worker_, Person;void test1() &#123; Worker_ worker = &#123;"李四",24&#125;; printf("name = %s ,age = %d \n",worker.name,worker.age);//name = 李四 ,age = 24 Person person = &#123; "张三",25 &#125;; printf("name = %s ,age = %d \n ", person.name, person.age);//name = 张三 ,age = 25&#125;//对结构体指针指定别名 typedef Worker* Worker_P;void test2() &#123; Worker_P worker_p =(Worker*)malloc(sizeof(Worker)); worker_p-&gt;age = 25; printf("age = %d \n ", worker_p-&gt;age);//age = 25&#125;int main() &#123; //test1(); test2(); getchar(); return 0;&#125; 联合体定义以及大小计算123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;string.h&gt;//定义联合体，和结构体定义一样，联合体只能存在一个属性，这里要么是name，要么是age，设置值以最后为主//大小计算 取最大值即可，然后判断是否整除该联合体里面最大基本数据类型长度，不够偏移到整除为止。union Person&#123; char name[10]; int age; //计算: name是10 age是4 找最大值 ，然后10不能整除最大的基本数据类型int 4，所以为12&#125;;int main() &#123; //Person person = &#123;"李四"&#125;; Person person; person.age = 25; strcpy_s(person.name,"zhangsan"); printf("person.name = %s , person.age = %d\n",person.name,person.age); // person.name = zhangsan , person.age = 1851877498 strcpy_s(person.name, "zhangsan"); person.age = 25; printf("person.name = %s , person.age = %d\n", person.name, person.age); // person.name =  , person.age = 25 printf("size = %d \n", sizeof(Person));//12 getchar(); return 0;&#125; 枚举的定义 123456789101112131415#include &lt;stdio.h&gt;//枚举的定义 ,如果中途有定义值得话，后面累加，前面还是从0开始enum CommentType &#123; TEXT,IMAGE,TEXT_IMAGE&#125;;void main() &#123; CommentType commentType = TEXT; CommentType commentType1 = IMAGE; CommentType commentType2 = TEXT_IMAGE; printf("%d , %d , %d",commentType, commentType1, commentType2);//0 , 1 , 2 getchar();&#125; 文件读写 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;int main() &#123; const char * fileName = "C:/Users/Administrator/Desktop/a.txt"; //打开文件 打开方式r，w具体看文档 FILE* afile_p = fopen(fileName,"r"); if (!afile_p) &#123; printf("文件打开失败！"); getchar(); return -1; &#125; //fputs 写入 需要拥有写的模式 char buffer[10]; //缓冲区buffer ,长度10 ，文件指针 while (fgets(buffer, 10, afile_p)) &#123; printf("%s", buffer); &#125; //关闭文件 fclose(afile_p); getchar(); return 1;&#125; 文件复制12345678910111213141516171819202122232425#include &lt;stdio.h&gt;int main() &#123; const char * srcFileName = "C:/Users/Administrator/Desktop/ee.png"; const char * copyFileName = "C:/Users/Administrator/Desktop/ee2.png"; //打开文件 打开方式r，w具体看文档 FILE* afile_p = fopen(srcFileName, "rb"); FILE* copyfile_p = fopen(copyFileName, "wb"); if (!afile_p) &#123; printf("文件打开失败！"); getchar(); return -1; &#125; int buffer[512]; int len; while ((len = fread(buffer, sizeof(int), 512, afile_p))!=0) &#123; fwrite(buffer, sizeof(int), len, copyfile_p); // fflush(copyfile_p); &#125; //关闭文件 fclose(afile_p); fclose(copyfile_p); return 1; &#125; 获取文件大小123456789101112131415161718192021222324#include &lt;stdio.h&gt;void main() &#123; //获取文件大小 const char * srcFileName = "C:/Users/Administrator/Desktop/ee.png"; FILE* afile_p = fopen(srcFileName, "rb"); if (!afile_p) &#123; printf("文件打开失败！"); getchar(); return; &#125; //将文件的指针移动到最后，然后再去计算偏移量 fseek(afile_p,0,SEEK_END); long fileSize = ftell(afile_p); printf("原文件大小:%d", fileSize); fclose(afile_p); getchar();&#125; 文件加密解密12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;//文件加密解密void main() &#123; const char * srcFileName = "C:/Users/Administrator/Desktop/ee.png"; const char * encrpyFileName = "C:/Users/Administrator/Desktop/encrpyee.png"; FILE* afile_p = fopen(srcFileName, "rb"); FILE* encrpyfile_p = fopen(encrpyFileName, "wb"); if (!afile_p) &#123; printf("文件打开失败！"); getchar(); return; &#125; //思路，把每一个字节都拿出来，对每一个字节都处理；把某一部分字节拿出来进行处理 // 加密 10^5 异或 // 1010 // ^0101 // 1111 int c; while ((c = fgetc(afile_p)) != EOF) &#123; fputc(c^5, encrpyfile_p); &#125; fclose(afile_p); fclose(encrpyfile_p); //解密 异或 // 1111 // ^0101 // 1010 FILE* encrpySrcFile_p = fopen(encrpyFileName, "rb"); const char * deFileName = "C:/Users/Administrator/Desktop/deee.png"; FILE* defile_p = fopen(deFileName, "wb"); while ((c = fgetc(encrpySrcFile_p)) != EOF) &#123; fputc(c ^ 5, defile_p); &#125; fclose(encrpySrcFile_p); fclose(defile_p);&#125; 文件分割1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;//类似断点下载//文件的切割void main() &#123; const char * srcFileName = "C:/Users/Administrator/Desktop/ee.png"; FILE* srcFile_p = fopen(srcFileName, "rb"); int file_number = 3; //二维数组内存开辟 char** file_names =(char**) malloc(sizeof(char*)*file_number); //进行数组内存开辟 int i = 0; for ( ; i &lt; file_number; i++) &#123; file_names[i] =(char*) malloc(sizeof(char)*100); char *fileName = file_names[i]; sprintf(fileName, "C:/Users/Administrator/Desktop/image%d.png",i); printf("%s\n", fileName); &#125; int file_size = getFileSize(srcFileName); if (file_size == -1) &#123; return; &#125; int preFileSize = file_size / file_number; //往切割文件中写入数据 i = 0; for (; i &lt; file_number; i++) &#123; FILE* cur_file_p = fopen(file_names[i],"wb"); int start = i * preFileSize; int end = (i + 1)*preFileSize; if (i == file_number-1) &#123; end = file_size; &#125; int index = start; printf("\ni=%d,start=%d,end=%d,name=%s", i, start, end, file_names[i]); for (; index &lt; end; index++) &#123; fputc(fgetc(srcFile_p),cur_file_p); &#125; fclose(cur_file_p); // free(file_names[i]); &#125; fclose(srcFile_p); free(file_names); getchar();&#125;]]></content>
      <categories>
        <category>c/c++</category>
      </categories>
      <tags>
        <tag>c/c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Glide v3.7源码分析(3)------GenericRequestBuilder.into（时序图）]]></title>
    <url>%2FGlide%20v3.7%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(3)------GenericRequestBuilder.into%EF%BC%88%E6%97%B6%E5%BA%8F%E5%9B%BE%EF%BC%89.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>源码</tag>
        <tag>glide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Glide v3.7源码分析(2)-----RequestManager.load]]></title>
    <url>%2FGlide%20%20v3.7%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(2)-----RequestManager.load.html</url>
    <content type="text"><![CDATA[代码如下:1234567891011121314151617181920212223242526private &lt;T&gt; DrawableTypeRequest&lt;T&gt; loadGeneric(Class&lt;T&gt; modelClass) &#123; //1. 获取streamModelLoader ModelLoader&lt;T, InputStream&gt; streamModelLoader = Glide.buildStreamModelLoader(modelClass, context); //2. 获取fileDescriptorModelLoader ModelLoader&lt;T, ParcelFileDescriptor&gt; fileDescriptorModelLoader = Glide.buildFileDescriptorModelLoader(modelClass, context); if (modelClass != null &amp;&amp; streamModelLoader == null &amp;&amp; fileDescriptorModelLoader == null) &#123; throw new IllegalArgumentException("Unknown type " + modelClass + ". You must provide a Model of a type for" + " which there is a registered ModelLoader, if you are using a custom model, you must first call" + " Glide#register with a ModelLoaderFactory for your custom model class"); &#125; //3. 获取DrawableTypeRequest return optionsApplier.apply( new DrawableTypeRequest&lt;T&gt;(modelClass, streamModelLoader, fileDescriptorModelLoader, context, glide, requestTracker, lifecycle, optionsApplier));&#125;public DrawableTypeRequest&lt;String&gt; load(String string) &#123; //4. load return (DrawableTypeRequest&lt;String&gt;) fromString().load(string);&#125;public DrawableTypeRequest&lt;String&gt; fromString() &#123; return loadGeneric(String.class);&#125; 流程图如下: buildModelLoader: 根据请求的model和需要解析的model获取到对应的ModelLoader Glide.buildModelLoader() 123456789101112public static &lt;T, Y&gt; ModelLoader&lt;T, Y&gt; buildModelLoader(Class&lt;T&gt; modelClass, Class&lt;Y&gt; resourceClass, Context context) &#123; if (modelClass == null) &#123; if (Log.isLoggable(TAG, Log.DEBUG)) &#123; Log.d(TAG, "Unable to load null model, setting placeholder only"); &#125; return null; &#125; //详见【1.1】 Glide.get 详见【1.2】 buildModelLoader return Glide.get(context).getLoaderFactory().buildModelLoader(modelClass, resourceClass); &#125; 1.1 Glide.get()：module配置解析，初始化Glide对象 12345678910111213141516171819202122232425public static Glide get(Context context) &#123; if (glide == null) &#123; synchronized (Glide.class) &#123; if (glide == null) &#123; Context applicationContext = context.getApplicationContext(); //解析Manifest配置的GlideModule 详见【1.1.1】 List&lt;GlideModule&gt; modules = new ManifestParser(applicationContext).parse(); GlideBuilder builder = new GlideBuilder(applicationContext); //遍历module，完成赋值 for (GlideModule module : modules) &#123; module.applyOptions(applicationContext, builder); &#125; //初始化Glide 详见【1.1.2】 glide = builder.createGlide(); //遍历module，完成注册 for (GlideModule module : modules) &#123; module.registerComponents(applicationContext, glide); &#125; &#125; &#125; &#125; return glide; &#125; 1.1.1 ManifestParser.parser()：解析AndroidManifest.xml配置的module123456789101112131415161718192021222324252627282930313233343536373839404142public List&lt;GlideModule&gt; parse() &#123; List&lt;GlideModule&gt; modules = new ArrayList&lt;GlideModule&gt;(); try &#123; ApplicationInfo appInfo = context.getPackageManager().getApplicationInfo( context.getPackageName(), PackageManager.GET_META_DATA); if (appInfo.metaData != null) &#123; for (String key : appInfo.metaData.keySet()) &#123; if (GLIDE_MODULE_VALUE.equals(appInfo.metaData.get(key))) &#123; modules.add(parseModule(key)); &#125; &#125; &#125; &#125; catch (PackageManager.NameNotFoundException e) &#123; throw new RuntimeException("Unable to find metadata to parse GlideModules", e); &#125; return modules; &#125; private static GlideModule parseModule(String className) &#123; Class&lt;?&gt; clazz; try &#123; clazz = Class.forName(className); &#125; catch (ClassNotFoundException e) &#123; throw new IllegalArgumentException("Unable to find GlideModule implementation", e); &#125; Object module; try &#123; //初始化module module = clazz.newInstance(); &#125; catch (InstantiationException e) &#123; throw new RuntimeException("Unable to instantiate GlideModule implementation for " + clazz, e); &#125; catch (IllegalAccessException e) &#123; throw new RuntimeException("Unable to instantiate GlideModule implementation for " + clazz, e); &#125; if (!(module instanceof GlideModule)) &#123; throw new RuntimeException("Expected instanceof GlideModule, but found: " + module); &#125; return (GlideModule) module; &#125; 1.1.2 GlideBuilder.createGlide():Glide初始化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118Glide createGlide() &#123; if (sourceService == null) &#123; //根据cpu获取核心加载数量 final int cores = Math.max(1, Runtime.getRuntime().availableProcessors()); //具有优先级顺序的线程池 sourceService = new FifoPriorityThreadPoolExecutor(cores); &#125; if (diskCacheService == null) &#123; diskCacheService = new FifoPriorityThreadPoolExecutor(1); &#125; //缓存计算类 MemorySizeCalculator calculator = new MemorySizeCalculator(context); if (bitmapPool == null) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) &#123; int size = calculator.getBitmapPoolSize(); //位图池 bitmapPool = new LruBitmapPool(size); &#125; else &#123; bitmapPool = new BitmapPoolAdapter(); &#125; &#125; //内存缓存 if (memoryCache == null) &#123; memoryCache = new LruResourceCache(calculator.getMemoryCacheSize()); &#125; //磁盘缓存 if (diskCacheFactory == null) &#123; diskCacheFactory = new InternalCacheDiskCacheFactory(context); &#125; //负责启动request load和管理内存的引擎类 if (engine == null) &#123; engine = new Engine(memoryCache, diskCacheFactory, diskCacheService, sourceService); &#125; if (decodeFormat == null) &#123; //编码格式 默认PREFER_RGB_565 decodeFormat = DecodeFormat.DEFAULT; &#125; return new Glide(engine, memoryCache, bitmapPool, context, decodeFormat);&#125;Glide(Engine engine, MemoryCache memoryCache, BitmapPool bitmapPool, Context context, DecodeFormat decodeFormat) &#123; this.engine = engine; this.bitmapPool = bitmapPool; this.memoryCache = memoryCache; this.decodeFormat = decodeFormat; //ModelLoader生成工厂类 loaderFactory = new GenericLoaderFactory(context); mainHandler = new Handler(Looper.getMainLooper()); bitmapPreFiller = new BitmapPreFiller(memoryCache, bitmapPool, decodeFormat); //DataLoadProviderRegistry 注册 dataLoadProviderRegistry = new DataLoadProviderRegistry(); StreamBitmapDataLoadProvider streamBitmapLoadProvider = new StreamBitmapDataLoadProvider(bitmapPool, decodeFormat); dataLoadProviderRegistry.register(InputStream.class, Bitmap.class, streamBitmapLoadProvider); FileDescriptorBitmapDataLoadProvider fileDescriptorLoadProvider = new FileDescriptorBitmapDataLoadProvider(bitmapPool, decodeFormat); dataLoadProviderRegistry.register(ParcelFileDescriptor.class, Bitmap.class, fileDescriptorLoadProvider); ImageVideoDataLoadProvider imageVideoDataLoadProvider = new ImageVideoDataLoadProvider(streamBitmapLoadProvider, fileDescriptorLoadProvider); dataLoadProviderRegistry.register(ImageVideoWrapper.class, Bitmap.class, imageVideoDataLoadProvider); GifDrawableLoadProvider gifDrawableLoadProvider = new GifDrawableLoadProvider(context, bitmapPool); dataLoadProviderRegistry.register(InputStream.class, GifDrawable.class, gifDrawableLoadProvider); dataLoadProviderRegistry.register(ImageVideoWrapper.class, GifBitmapWrapper.class, new ImageVideoGifDrawableLoadProvider(imageVideoDataLoadProvider, gifDrawableLoadProvider, bitmapPool)); dataLoadProviderRegistry.register(InputStream.class, File.class, new StreamFileDataLoadProvider()); //GenericLoaderFactory注册 register(File.class, ParcelFileDescriptor.class, new FileDescriptorFileLoader.Factory()); register(File.class, InputStream.class, new StreamFileLoader.Factory()); register(int.class, ParcelFileDescriptor.class, new FileDescriptorResourceLoader.Factory()); register(int.class, InputStream.class, new StreamResourceLoader.Factory()); register(Integer.class, ParcelFileDescriptor.class, new FileDescriptorResourceLoader.Factory()); register(Integer.class, InputStream.class, new StreamResourceLoader.Factory()); register(String.class, ParcelFileDescriptor.class, new FileDescriptorStringLoader.Factory()); register(String.class, InputStream.class, new StreamStringLoader.Factory()); register(Uri.class, ParcelFileDescriptor.class, new FileDescriptorUriLoader.Factory()); register(Uri.class, InputStream.class, new StreamUriLoader.Factory()); register(URL.class, InputStream.class, new StreamUrlLoader.Factory()); register(GlideUrl.class, InputStream.class, new HttpUrlGlideUrlLoader.Factory()); register(byte[].class, InputStream.class, new StreamByteArrayLoader.Factory()); //TranscoderRegistry 注册 transcoderRegistry.register(Bitmap.class, GlideBitmapDrawable.class, new GlideBitmapDrawableTranscoder(context.getResources(), bitmapPool)); transcoderRegistry.register(GifBitmapWrapper.class, GlideDrawable.class, new GifBitmapWrapperDrawableTranscoder( new GlideBitmapDrawableTranscoder(context.getResources(), bitmapPool))); bitmapCenterCrop = new CenterCrop(bitmapPool); drawableCenterCrop = new GifBitmapWrapperTransformation(bitmapPool, bitmapCenterCrop); bitmapFitCenter = new FitCenter(bitmapPool); drawableFitCenter = new GifBitmapWrapperTransformation(bitmapPool, bitmapFitCenter);&#125;//根据modelClass，resourceClass，ModelLoaderFactory注册到GenericLoaderFactorypublic &lt;T, Y&gt; void register(Class&lt;T&gt; modelClass, Class&lt;Y&gt; resourceClass, ModelLoaderFactory&lt;T, Y&gt; factory) &#123; //详见【1.1.3】 ModelLoaderFactory&lt;T, Y&gt; removed = loaderFactory.register(modelClass, resourceClass, factory); if (removed != null) &#123; removed.teardown(); &#125;&#125; 可以看到，Glide初始化的时候做了很多的事，初始化了缓存相关的类，任务执行以及缓存管理的引擎，注册了DataLoadProviderRegistry GenericLoaderFactory等等这些。这个时候我们知道了Glide.buildModelLoader()函数里面Glide.get(context).getLoaderFactory()对象为GenericLoaderFactory 1.1.3 GenericLoaderFactory.register()12345678910111213141516171819202122232425262728public synchronized &lt;T, Y&gt; ModelLoaderFactory&lt;T, Y&gt; register(Class&lt;T&gt; modelClass, Class&lt;Y&gt; resourceClass, ModelLoaderFactory&lt;T, Y&gt; factory) &#123; cachedModelLoaders.clear(); //modelClassToResourceFactories key为modelClass,值为已resourceClass为key，factory为值得HashMap //根据modelClass获取resourceToFactories Map&lt;Class/*Y*/, ModelLoaderFactory/*T, Y*/&gt; resourceToFactories = modelClassToResourceFactories.get(modelClass); if (resourceToFactories == null) &#123; resourceToFactories = new HashMap&lt;Class/*Y*/, ModelLoaderFactory/*T, Y*/&gt;(); modelClassToResourceFactories.put(modelClass, resourceToFactories); &#125; ModelLoaderFactory/*T, Y*/ previous = resourceToFactories.put(resourceClass, factory); if (previous != null) &#123; // This factory may be being used by another model. We don't want to say it has been removed unless we // know it has been removed for all models. for (Map&lt;Class/*Y*/, ModelLoaderFactory/*T, Y*/&gt; factories : modelClassToResourceFactories.values()) &#123; if (factories.containsValue(previous)) &#123; previous = null; break; &#125; &#125; &#125; return previous; &#125; 1.2 GenericLoaderFactory.buildModelLoader()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public synchronized &lt;T, Y&gt; ModelLoader&lt;T, Y&gt; buildModelLoader(Class&lt;T&gt; modelClass, Class&lt;Y&gt; resourceClass) &#123; //获取缓存的ModelLoader ModelLoader&lt;T, Y&gt; result = getCachedLoader(modelClass, resourceClass); if (result != null) &#123; // We've already tried to create a model loader and can't with the currently registered set of factories, // but we can't use null to demonstrate that failure because model loaders that haven't been requested // yet will be null in the cache. To avoid this, we use a special signal model loader. if (NULL_MODEL_LOADER.equals(result)) &#123; return null; &#125; else &#123; return result; &#125; &#125; //根据 modelClass 和 resourceClass获取对应的ModelLoaderFactory final ModelLoaderFactory&lt;T, Y&gt; factory = getFactory(modelClass, resourceClass); if (factory != null) &#123; //根据ModelLoaderFactory获取到ModelLoader，并将存到缓存，详见【1.2.1】 result = factory.build(context, this); cacheModelLoader(modelClass, resourceClass, result); &#125; else &#123; // We can't generate a model loader for the given arguments with the currently registered set of factories. cacheNullLoader(modelClass, resourceClass); &#125; return result; &#125; private &lt;T, Y&gt; ModelLoaderFactory&lt;T, Y&gt; getFactory(Class&lt;T&gt; modelClass, Class&lt;Y&gt; resourceClass) &#123; // 在【1.1.2】Glide初始化的时候modelClassToResourceFactories注册对应关系 Map&lt;Class/*Y*/, ModelLoaderFactory/*T, Y*/&gt; resourceToFactories = modelClassToResourceFactories.get(modelClass); ModelLoaderFactory/*T, Y*/ result = null; if (resourceToFactories != null) &#123; result = resourceToFactories.get(resourceClass); &#125; if (result == null) &#123; for (Class&lt;? super T&gt; registeredModelClass : modelClassToResourceFactories.keySet()) &#123; // This accounts for model subclasses, our map only works for exact matches. We should however still // match a subclass of a model with a factory for a super class of that model if if there isn't a // factory for that particular subclass. Uris are a great example of when this happens, most uris // are actually subclasses for Uri, but we'd generally rather load them all with the same factory rather // than trying to register for each subclass individually. if (registeredModelClass.isAssignableFrom(modelClass)) &#123; Map&lt;Class/*Y*/, ModelLoaderFactory/*T, Y*/&gt; currentResourceToFactories = modelClassToResourceFactories.get(registeredModelClass); if (currentResourceToFactories != null) &#123; result = currentResourceToFactories.get(resourceClass); if (result != null) &#123; break; &#125; &#125; &#125; &#125; &#125; return result; &#125; 1.2.1 factory.build():根据ModelLoaderFactory获取到ModelLoader,这里用module.class=String.class来举例， 【1.1.2】Glide初始化的时候可知道register(String.class, InputStream.class, new StreamStringLoader.Factory()); StreamStringLoader.Factory.build()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102public class StreamStringLoader extends StringLoader&lt;InputStream&gt; implements StreamModelLoader&lt;String&gt; &#123; /** * The default factory for &#123;@link com.bumptech.glide.load.model.stream.StreamStringLoader&#125;s. */ public static class Factory implements ModelLoaderFactory&lt;String, InputStream&gt; &#123; @Override public ModelLoader&lt;String, InputStream&gt; build(Context context, GenericLoaderFactory factories) &#123; //这里通过`factories.buildModelLoader`来构建一个`module.class=Uri.class`类型的`ModuleLoader`，从【1.1.2】里面可以看到`register(Uri.class, InputStream.class, new StreamUriLoader.Factory());`。`factories.buildModelLoader`详见【1.2】 return new StreamStringLoader(factories.buildModelLoader(Uri.class, InputStream.class)); &#125; @Override public void teardown() &#123; // Do nothing. &#125; &#125; public StreamStringLoader(Context context) &#123; this(Glide.buildStreamModelLoader(Uri.class, context)); &#125; public StreamStringLoader(ModelLoader&lt;Uri, InputStream&gt; uriLoader) &#123; super(uriLoader); &#125;&#125;public class StreamUriLoader extends UriLoader&lt;InputStream&gt; implements StreamModelLoader&lt;Uri&gt; &#123; /** * THe default factory for &#123;@link com.bumptech.glide.load.model.stream.StreamUriLoader&#125;s. */ public static class Factory implements ModelLoaderFactory&lt;Uri, InputStream&gt; &#123; @Override public ModelLoader&lt;Uri, InputStream&gt; build(Context context, GenericLoaderFactory factories) &#123; //【1.1.2】 register(GlideUrl.class, InputStream.class, new HttpUrlGlideUrlLoader.Factory()); return new StreamUriLoader(context, factories.buildModelLoader(GlideUrl.class, InputStream.class)); &#125; @Override public void teardown() &#123; // Do nothing. &#125; &#125; public StreamUriLoader(Context context) &#123; this(context, Glide.buildStreamModelLoader(GlideUrl.class, context)); &#125; public StreamUriLoader(Context context, ModelLoader&lt;GlideUrl, InputStream&gt; urlLoader) &#123; super(context, urlLoader); &#125; //...&#125;public class HttpUrlGlideUrlLoader implements ModelLoader&lt;GlideUrl, InputStream&gt; &#123; private final ModelCache&lt;GlideUrl, GlideUrl&gt; modelCache; /** * The default factory for &#123;@link com.bumptech.glide.load.model.stream.HttpUrlGlideUrlLoader&#125;s. */ public static class Factory implements ModelLoaderFactory&lt;GlideUrl, InputStream&gt; &#123; private final ModelCache&lt;GlideUrl, GlideUrl&gt; modelCache = new ModelCache&lt;GlideUrl, GlideUrl&gt;(500); @Override public ModelLoader&lt;GlideUrl, InputStream&gt; build(Context context, GenericLoaderFactory factories) &#123; return new HttpUrlGlideUrlLoader(modelCache); &#125; @Override public void teardown() &#123; // Do nothing. &#125; &#125; public HttpUrlGlideUrlLoader() &#123; this(null); &#125; public HttpUrlGlideUrlLoader(ModelCache&lt;GlideUrl, GlideUrl&gt; modelCache) &#123; this.modelCache = modelCache; &#125; @Override public DataFetcher&lt;InputStream&gt; getResourceFetcher(GlideUrl model, int width, int height) &#123; // GlideUrls memoize parsed URLs so caching them saves a few object instantiations and time spent parsing urls. GlideUrl url = model; if (modelCache != null) &#123; url = modelCache.get(model, 0, 0); if (url == null) &#123; modelCache.put(model, 0, 0, model); url = model; &#125; &#125; return new HttpUrlFetcher(url); &#125;&#125; StreamStringLoader继承StringLoader,StringLoader里面有一个ModelLoader uriLoader成员变量,当build的时候，这里通过factories.buildModelLoader来构建一个module.class=Uri.class类型的ModuleLoader，从【1.1.2】里面可以看到register(Uri.class, InputStream.class, new StreamUriLoader.Factory());`StreamUriLoader继承UriLoader，它有一个ModelLoader urlLoader成员变量，这个时候也通过factories.buildModelLoader以module.class = GlideUrl.class的方式获取,【1.1.2】register(GlideUrl.class, InputStream.class, new HttpUrlGlideUrlLoader.Factory());`，这里一层一层的获取很是巧妙。 Glide.buildFileDescriptorModelLoader：获取fileDescriptorModelLoader12345public static &lt;T&gt; ModelLoader&lt;T, ParcelFileDescriptor&gt; buildFileDescriptorModelLoader(Class&lt;T&gt; modelClass, Context context) &#123; //详见【1】 return buildModelLoader(modelClass, ParcelFileDescriptor.class, context); &#125; 这一步和【1】差不多的流程，已module.class = String.class为例子，register(String.class, ParcelFileDescriptor.class, new FileDescriptorStringLoader.Factory());于【1.2.1】类似，也是一层一层的获取，这就不废话了。 获取DrawableTypeRequest: DrawableTypeRequest继承DrawableRequestBuilder,DrawableRequestBuilder继承GenericRequestBuilder1234567891011121314151617private final OptionsApplier optionsApplier;this.optionsApplier = new OptionsApplier();//【3.1】 new DrawableTypeRequestoptionsApplier.apply( new DrawableTypeRequest&lt;T&gt;(modelClass, streamModelLoader, fileDescriptorModelLoader, context, glide, requestTracker, lifecycle, optionsApplier)) class OptionsApplier &#123; public &lt;A, X extends GenericRequestBuilder&lt;A, ?, ?, ?&gt;&gt; X apply(X builder) &#123; //HOOK if (options != null) &#123; options.apply(builder); &#125; return builder; &#125; &#125; 这里获取Request对象的时候，留了一个hook。 3.1 new DrawableTypeRequest123456789101112131415161718192021222324252627282930313233343536373839404142DrawableTypeRequest(Class&lt;ModelType&gt; modelClass, ModelLoader&lt;ModelType, InputStream&gt; streamModelLoader, ModelLoader&lt;ModelType, ParcelFileDescriptor&gt; fileDescriptorModelLoader, Context context, Glide glide, RequestTracker requestTracker, Lifecycle lifecycle, RequestManager.OptionsApplier optionsApplier) &#123; //【3.2】 buildProvider super(context, modelClass, buildProvider(glide, streamModelLoader, fileDescriptorModelLoader, GifBitmapWrapper.class, GlideDrawable.class, null), glide, requestTracker, lifecycle); this.streamModelLoader = streamModelLoader; this.fileDescriptorModelLoader = fileDescriptorModelLoader; this.optionsApplier = optionsApplier; &#125; DrawableRequestBuilder(Context context, Class&lt;ModelType&gt; modelClass, LoadProvider&lt;ModelType, ImageVideoWrapper, GifBitmapWrapper, GlideDrawable&gt; loadProvider, Glide glide, RequestTracker requestTracker, Lifecycle lifecycle) &#123; super(context, modelClass, loadProvider, GlideDrawable.class, glide, requestTracker, lifecycle); // Default to animating. crossFade(); &#125; GenericRequestBuilder(Context context, Class&lt;ModelType&gt; modelClass, LoadProvider&lt;ModelType, DataType, ResourceType, TranscodeType&gt; loadProvider, Class&lt;TranscodeType&gt; transcodeClass, Glide glide, RequestTracker requestTracker, Lifecycle lifecycle) &#123; this.context = context; this.modelClass = modelClass; this.transcodeClass = transcodeClass; this.glide = glide; this.requestTracker = requestTracker; this.lifecycle = lifecycle; this.loadProvider = loadProvider != null ? new ChildLoadProvider&lt;ModelType, DataType, ResourceType, TranscodeType&gt;(loadProvider) : null; if (context == null) &#123; throw new NullPointerException("Context can't be null"); &#125; if (modelClass != null &amp;&amp; loadProvider == null) &#123; throw new NullPointerException("LoadProvider must not be null"); &#125; &#125; 3.2 buildProvider1234567891011121314151617181920private static &lt;A, Z, R&gt; FixedLoadProvider&lt;A, ImageVideoWrapper, Z, R&gt; buildProvider(Glide glide, ModelLoader&lt;A, InputStream&gt; streamModelLoader, ModelLoader&lt;A, ParcelFileDescriptor&gt; fileDescriptorModelLoader, Class&lt;Z&gt; resourceClass, Class&lt;R&gt; transcodedClass, ResourceTranscoder&lt;Z, R&gt; transcoder) &#123; if (streamModelLoader == null &amp;&amp; fileDescriptorModelLoader == null) &#123; return null; &#125; if (transcoder == null) &#123; //获取ResourceTranscoder详见【3.2.1】 --&gt; GifBitmapWrapperDrawableTranscoder transcoder = glide.buildTranscoder(resourceClass, transcodedClass); &#125; //详见【3.2.2】 DataLoadProvider&lt;ImageVideoWrapper, Z&gt; dataLoadProvider = glide.buildDataProvider(ImageVideoWrapper.class, resourceClass); ImageVideoModelLoader&lt;A&gt; modelLoader = new ImageVideoModelLoader&lt;A&gt;(streamModelLoader, fileDescriptorModelLoader); return new FixedLoadProvider&lt;A, ImageVideoWrapper, Z, R&gt;(modelLoader, transcoder, dataLoadProvider); &#125; 这里resourceClass = GifBitmapWrapper.class,transcodedClass = GlideDrawable.class 3.2.1 glide.buildTranscoder123&lt;Z, R&gt; ResourceTranscoder&lt;Z, R&gt; buildTranscoder(Class&lt;Z&gt; decodedClass, Class&lt;R&gt; transcodedClass) &#123; return transcoderRegistry.get(decodedClass, transcodedClass); &#125; 从【1.1.2】123transcoderRegistry.register(GifBitmapWrapper.class, GlideDrawable.class, new GifBitmapWrapperDrawableTranscoder( new GlideBitmapDrawableTranscoder(context.getResources(), bitmapPool))); 获取的transcoder为GifBitmapWrapperDrawableTranscoder 3.2.2 glide.buildDataProvider123&lt;T, Z&gt; DataLoadProvider&lt;T, Z&gt; buildDataProvider(Class&lt;T&gt; dataClass, Class&lt;Z&gt; decodedClass) &#123; return dataLoadProviderRegistry.get(dataClass, decodedClass); &#125; 这里dataClass = ImageVideoWrapper.class,decodedClass = resourceClass = GifBitmapWrapper.class从【1.1.2】12dataLoadProviderRegistry.register(ImageVideoWrapper.class, GifBitmapWrapper.class, new ImageVideoGifDrawableLoadProvider(imageVideoDataLoadProvider, gifDrawableLoadProvider, bitmapPool)); 获取的DataLoadProvider为ImageVideoGifDrawableLoadProvider DrawableTypeRequest.load12345678910111213 @Override public DrawableRequestBuilder&lt;ModelType&gt; load(ModelType model) &#123; super.load(model); return this; &#125; public GenericRequestBuilder&lt;ModelType, DataType, ResourceType, TranscodeType&gt; load(ModelType model) &#123; this.model = model; isModelSet = true; return this; &#125; 最后的load就是设置一些moduleType。 总结： Glide.with获取到RequestManager对象，然后我们通过RequestManager.load根据modelType获取到GenericRequestBuilder对象。 Glide根据modelType生成Request采用了工厂，并且初始化ModuleLoader的时候，里面又包含着另外一个ModuleLoader引用，很是巧妙。具体查看【1.2】 一个modelType(modelClass)对应多个resourceType(resourceClass),一个resourceType对应一个transcodedType(transcodedClass) modelType可以理解为请求的类型,String Uri File等;resourceType可以理解为请求的结果形式，比如Stream File等；transcodedType可以理解为图片的转换类型Drawable Bitmap等。]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>源码</tag>
        <tag>glide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Glide v3.7源码分析(1)-----Glide.with()]]></title>
    <url>%2FGlide%20v3.7%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(1)-----Glide.with().html</url>
    <content type="text"><![CDATA[Glide.with()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public static RequestManager with(FragmentActivity activity) &#123; //单例拿到一个RequestManagerRetriever RequestManagerRetriever retriever = RequestManagerRetriever.get(); return retriever.get(activity);&#125; public RequestManager get(FragmentActivity activity) &#123; if (Util.isOnBackgroundThread()) &#123; return get(activity.getApplicationContext()); &#125; else &#123; assertNotDestroyed(activity); FragmentManager fm = activity.getSupportFragmentManager(); return supportFragmentGet(activity, fm); &#125;&#125;RequestManager supportFragmentGet(Context context, FragmentManager fm) &#123; //根据TAG拿到SupportRequestManagerFragment 防止第二次重复创建 SupportRequestManagerFragment current = getSupportRequestManagerFragment(fm); //拿到RequestManager RequestManager requestManager = current.getRequestManager(); if (requestManager == null) &#123; requestManager = new RequestManager(context, current.getLifecycle(), current.getRequestManagerTreeNode()); current.setRequestManager(requestManager); &#125; return requestManager;&#125;SupportRequestManagerFragment getSupportRequestManagerFragment(final FragmentManager fm) &#123; SupportRequestManagerFragment current = (SupportRequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG); if (current == null) &#123; current = pendingSupportRequestManagerFragments.get(fm); if (current == null) &#123; current = new SupportRequestManagerFragment(); pendingSupportRequestManagerFragments.put(fm, current); fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss(); handler.obtainMessage(ID_REMOVE_SUPPORT_FRAGMENT_MANAGER, fm).sendToTarget(); &#125; &#125; return current;&#125;public class RequestManager implements LifecycleListener &#123; private final Context context; private final Lifecycle lifecycle; private final RequestManagerTreeNode treeNode; private final RequestTracker requestTracker; private final Glide glide; private final OptionsApplier optionsApplier; private DefaultOptions options; //RequestManager初始化 public RequestManager(Context context, Lifecycle lifecycle, RequestManagerTreeNode treeNode) &#123; this(context, lifecycle, treeNode, new RequestTracker(), new ConnectivityMonitorFactory()); &#125; RequestManager(Context context, final Lifecycle lifecycle, RequestManagerTreeNode treeNode, RequestTracker requestTracker, ConnectivityMonitorFactory factory) &#123; this.context = context.getApplicationContext(); this.lifecycle = lifecycle; this.treeNode = treeNode; this.requestTracker = requestTracker; this.glide = Glide.get(context); this.optionsApplier = new OptionsApplier(); ConnectivityMonitor connectivityMonitor = factory.build(context, new RequestManagerConnectivityListener(requestTracker)); // If we're the application level request manager, we may be created on a background thread. In that case we // cannot risk synchronously pausing or resuming requests, so we hack around the issue by delaying adding // ourselves as a lifecycle listener by posting to the main thread. This should be entirely safe. if (Util.isOnBackgroundThread()) &#123; new Handler(Looper.getMainLooper()).post(new Runnable() &#123; @Override public void run() &#123; lifecycle.addListener(RequestManager.this); &#125; &#125;); &#125; else &#123; lifecycle.addListener(this); &#125; lifecycle.addListener(connectivityMonitor); &#125; //...&#125; 总结： 创建一个Fragment绑定到Activity上面，Fragment调用setRequestManager()进行RequestManager赋值。 Fragment的作用是用于生命周期管理,当我们new Fragment的时候我们一同会new一个ActivityFragmentLifecycle 当Frament onLowMemory的时候RequestManager会回调onLowMemory回调。 ActivityFragmentLifecycle是使用观察者模式来管理LifecycleListener，当fragment触发生命周期的时候（onStart onStop onDestroy），ActivityFragmentLifecycle将会进行遍历回调。 RequestManager是一个LifecycleListener,当初始化的时候，RequestManager将会被注册到Fragent里面的ActivityFragmentLifecycle进行生命管理。]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>源码</tag>
        <tag>glide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenCv as配置]]></title>
    <url>%2FOpenCv%20%20as%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[使用opencv4android的java库，这里说下怎么把OpencvManager去除，把copy到opencv的javalib里面当so运行就可，调用initDebug初始化即可，目录结构如下: 根据需要导入对应的动态库以及头文件自己编译so库，主要配置如下build.gradle 12345678910111213141516171819android &#123; defaultConfig &#123; externalNativeBuild &#123; cmake &#123; arguments &quot;-DANDROID_TOOLCHAIN=clang&quot; cppFlags &quot;-std=c++11&quot;,&quot;-frtti&quot;, &quot;-fexceptions&quot; &#125; &#125; ndk&#123; abiFilters &apos;armeabi-v7a&apos; &#125; &#125; externalNativeBuild &#123; cmake &#123; path &quot;CMakeLists.txt&quot; &#125; &#125;&#125; CMakeLists.txt 注意target_link_libraries顺序。这里libopencv_java3其实已经包括了其他的了，我的理解是用了java3这个后面的动态库就可以不用添加了，我只是把可能用到的全部写了出来，以后好copy。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118# For more information about using CMake with Android Studio, read the# documentation: https://d.android.com/studio/projects/add-native-code.html# Sets the minimum version of CMake required to build the native library.cmake_minimum_required(VERSION 3.4.1)set(CMAKE_VERBOSE_MAKEFILE on)set(libs &quot;$&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs&quot;)include_directories($&#123;CMAKE_SOURCE_DIR&#125;/src/main/cpp/include)add_library(libopencv_java3 SHARED IMPORTED )set_target_properties(libopencv_java3 PROPERTIES IMPORTED_LOCATION &quot;$&#123;libs&#125;/$&#123;ANDROID_ABI&#125;/libopencv_java3.so&quot;)add_library(libopencv_calib3d STATIC IMPORTED )set_target_properties(libopencv_calib3d PROPERTIES IMPORTED_LOCATION &quot;$&#123;libs&#125;/$&#123;ANDROID_ABI&#125;/libopencv_calib3d.a&quot;)add_library(libopencv_core STATIC IMPORTED )set_target_properties(libopencv_core PROPERTIES IMPORTED_LOCATION &quot;$&#123;libs&#125;/$&#123;ANDROID_ABI&#125;/libopencv_core.a&quot;)add_library(libopencv_features2d STATIC IMPORTED )set_target_properties(libopencv_features2d PROPERTIES IMPORTED_LOCATION &quot;$&#123;libs&#125;/$&#123;ANDROID_ABI&#125;/libopencv_features2d.a&quot;)add_library(libopencv_flann STATIC IMPORTED )set_target_properties(libopencv_flann PROPERTIES IMPORTED_LOCATION &quot;$&#123;libs&#125;/$&#123;ANDROID_ABI&#125;/libopencv_flann.a&quot;)add_library(libopencv_highgui STATIC IMPORTED )set_target_properties(libopencv_highgui PROPERTIES IMPORTED_LOCATION &quot;$&#123;libs&#125;/$&#123;ANDROID_ABI&#125;/libopencv_highgui.a&quot;)add_library(libopencv_imgcodecs STATIC IMPORTED )set_target_properties(libopencv_imgcodecs PROPERTIES IMPORTED_LOCATION &quot;$&#123;libs&#125;/$&#123;ANDROID_ABI&#125;/libopencv_imgcodecs.a&quot;)add_library(libopencv_imgproc STATIC IMPORTED )set_target_properties(libopencv_imgproc PROPERTIES IMPORTED_LOCATION &quot;$&#123;libs&#125;/$&#123;ANDROID_ABI&#125;/libopencv_imgproc.a&quot;)add_library(libopencv_ml STATIC IMPORTED )set_target_properties(libopencv_ml PROPERTIES IMPORTED_LOCATION &quot;$&#123;libs&#125;/$&#123;ANDROID_ABI&#125;/libopencv_ml.a&quot;)add_library(libopencv_objdetect STATIC IMPORTED )set_target_properties(libopencv_objdetect PROPERTIES IMPORTED_LOCATION &quot;$&#123;libs&#125;/$&#123;ANDROID_ABI&#125;/libopencv_objdetect.a&quot;)add_library(libopencv_photo STATIC IMPORTED )set_target_properties(libopencv_photo PROPERTIES IMPORTED_LOCATION &quot;$&#123;libs&#125;/$&#123;ANDROID_ABI&#125;/libopencv_photo.a&quot;)add_library(libopencv_shape STATIC IMPORTED )set_target_properties(libopencv_shape PROPERTIES IMPORTED_LOCATION &quot;$&#123;libs&#125;/$&#123;ANDROID_ABI&#125;/libopencv_shape.a&quot;)add_library(libopencv_stitching STATIC IMPORTED )set_target_properties(libopencv_stitching PROPERTIES IMPORTED_LOCATION &quot;$&#123;libs&#125;/$&#123;ANDROID_ABI&#125;/libopencv_stitching.a&quot;)add_library(libopencv_superres STATIC IMPORTED )set_target_properties(libopencv_superres PROPERTIES IMPORTED_LOCATION &quot;$&#123;libs&#125;/$&#123;ANDROID_ABI&#125;/libopencv_superres.a&quot;)add_library(libopencv_video STATIC IMPORTED )set_target_properties(libopencv_video PROPERTIES IMPORTED_LOCATION &quot;$&#123;libs&#125;/$&#123;ANDROID_ABI&#125;/libopencv_video.a&quot;)add_library(libopencv_videoio STATIC IMPORTED )set_target_properties(libopencv_videoio PROPERTIES IMPORTED_LOCATION &quot;$&#123;libs&#125;/$&#123;ANDROID_ABI&#125;/libopencv_videoio.a&quot;)add_library(libopencv_videostab STATIC IMPORTED )set_target_properties(libopencv_videostab PROPERTIES IMPORTED_LOCATION &quot;$&#123;libs&#125;/$&#123;ANDROID_ABI&#125;/libopencv_videostab.a&quot;)add_library(libopencv_ts STATIC IMPORTED )set_target_properties(libopencv_ts PROPERTIES IMPORTED_LOCATION &quot;$&#123;libs&#125;/$&#123;ANDROID_ABI&#125;/libopencv_ts.a&quot;)#set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=gnu++11 -fexceptions -frtti&quot;)#支持-std=gnu++11set(CMAKE_VERBOSE_MAKEFILE on)set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=gnu++11 -Wall -DGLM_FORCE_SIZE_T_LENGTH&quot;)set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; -DGLM_FORCE_RADIANS&quot;)#include_directories(D:/Projects/Android/CLMAndroid/OpenCV-android-sdk/sdk/native/jni/include )#set(OpenCV_DIR D:/Projects/Android/CLMAndroid/OpenCV-android-sdk/sdk/native/jni)#find_package(OpenCV REQUIRED)#target_link_libraries($&#123;OpenCV_LIBS&#125;)add_library( # Sets the name of the library. native-lib # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). # Associated headers in the same location as their source # file are automatically included. src/main/cpp/native-lib.cpp )find_library( # Sets the name of the path variable. log-lib # Specifies the name of the NDK library that # you want CMake to locate. log)target_link_libraries(native-lib log libopencv_java3 libopencv_calib3d libopencv_core libopencv_features2d libopencv_flann libopencv_highgui libopencv_imgcodecs libopencv_imgproc libopencv_ml libopencv_objdetect libopencv_photo libopencv_shape libopencv_stitching libopencv_superres libopencv_video libopencv_videoio libopencv_videostab $&#123;log-lib&#125; ) 目录结构： 通过opencv 的源码，重新编译成 Android sdk 库，很复杂，好处就是可以实时的弄到新功能。]]></content>
      <categories>
        <category>cmake</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>openCv</tag>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zygote篇]]></title>
    <url>%2Fzygote%E7%AF%87.html</url>
    <content type="text"><![CDATA[Zygote是由init进程通过解析init.zygote.rc文件创建 调用流程 初始化系统app 初始化应用app 总结: 系统应用初始化的时候，先开启系统服务SystemServer,执行SystemServer.main。 在runSelectLoop开启Os.poll堵塞处理轮训，接收到事件，运行runOnce函数执行应用的初始化。在执行对应的ActivityMain.main。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public static void main(String argv[]) &#123; try &#123; RuntimeInit.enableDdms(); //开启DDMS功能 SamplingProfilerIntegration.start(); boolean startSystemServer = false; String socketName = "zygote"; String abiList = null; for (int i = 1; i &lt; argv.length; i++) &#123; if ("start-system-server".equals(argv[i])) &#123; startSystemServer = true; &#125; else if (argv[i].startsWith(ABI_LIST_ARG)) &#123; abiList = argv[i].substring(ABI_LIST_ARG.length()); &#125; else if (argv[i].startsWith(SOCKET_NAME_ARG)) &#123; socketName = argv[i].substring(SOCKET_NAME_ARG.length()); &#125; else &#123; throw new RuntimeException("Unknown command line argument: " + argv[i]); &#125; &#125; ... registerZygoteSocket(socketName); //为Zygote注册socket preload(); // 预加载类和资源 SamplingProfilerIntegration.writeZygoteSnapshot(); gcAndFinalize(); //GC操作 if (startSystemServer) &#123; startSystemServer(abiList, socketName);//启动system_server &#125; runSelectLoop(abiList); //进入循环模式 closeServerSocket(); &#125; catch (MethodAndArgsCaller caller) &#123; caller.run(); //启动system_server中会讲到。 &#125; catch (RuntimeException ex) &#123; closeServerSocket(); throw ex; &#125;&#125;private static void runSelectLoop(String abiList) throws MethodAndArgsCaller &#123; ArrayList&lt;FileDescriptor&gt; fds = new ArrayList&lt;FileDescriptor&gt;(); ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;ZygoteConnection&gt;(); //sServerSocket是socket通信中的服务端，即zygote进程。保存到fds[0] fds.add(sServerSocket.getFileDescriptor()); peers.add(null); while (true) &#123; StructPollfd[] pollFds = new StructPollfd[fds.size()]; for (int i = 0; i &lt; pollFds.length; ++i) &#123; pollFds[i] = new StructPollfd(); pollFds[i].fd = fds.get(i); pollFds[i].events = (short) POLLIN; &#125; try &#123; //处理轮询状态，当pollFds有事件到来则往下执行，否则阻塞在这里 Os.poll(pollFds, -1); &#125; catch (ErrnoException ex) &#123; ... &#125; for (int i = pollFds.length - 1; i &gt;= 0; --i) &#123; //采用I/O多路复用机制，当接收到客户端发出连接请求 或者数据处理请求到来，则往下执行； // 否则进入continue，跳出本次循环。 if ((pollFds[i].revents &amp; POLLIN) == 0) &#123; continue; &#125; if (i == 0) &#123; //即fds[0]，代表的是sServerSocket，则意味着有客户端连接请求； // 则创建ZygoteConnection对象,并添加到fds。 ZygoteConnection newPeer = acceptCommandPeer(abiList); peers.add(newPeer); fds.add(newPeer.getFileDesciptor()); //添加到fds. &#125; else &#123; //i&gt;0，则代表通过socket接收来自对端的数据，并执行相应操作 boolean done = peers.get(i).runOnce(); if (done) &#123; peers.remove(i); fds.remove(i); //处理完则从fds中移除该文件描述符 &#125; &#125; &#125; &#125;&#125; 参考连接:http://gityuan.com/2016/02/13/android-zygote/]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[startActivity时序图]]></title>
    <url>%2FstartActivity%E6%97%B6%E5%BA%8F%E5%9B%BE.html</url>
    <content type="text"><![CDATA[lauchModle 检测: ActivityStarter.startActivityUnchecked() 绕过AndroidManifest检测： 瞒天过海：使用代理Activity替换原来的Activity拿到ActivityManagerNative里面的IActivityManager对象动态代理拦截startActivity函数，获取原来的srcIntent，重新new一个代理Activity的newIntent,newIntent.putExtra(EXTRA_ORIGIN_INTENT,originIntent),然后用newIntent替换原来的srcIntent 借尸还魂: 在Activity实例化之前（laucherActivity的时候），判断intent里面有没有EXTRA_ORIGIN_INTENT字段，如果有的话取出来替换即可拿到ActivityThread对象里面的Handler对象mH,然后拿到new一个Handler的callback，然后适进去，在这个callback里面处理自己的回归需求。（设置callback的原因是因为我们只处理lauchActivy，不影响其他的操作）。这里注意AppCompatActivity需要兼容，先拿到ActivityThread里面的IPackageManager,然后动态代理拦截getActivityInfo()函数的ComponentName替换为代理Activity的ComponentName startActivity解析 插件化绕过AndroidManifest检测 Zygote孵化应用进程]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>源码</tag>
        <tag>时序图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bindService时序图]]></title>
    <url>%2FbindService%E6%97%B6%E5%BA%8F%E5%9B%BE.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>源码</tag>
        <tag>时序图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手写 ButterKnife BindView]]></title>
    <url>%2F%E6%89%8B%E5%86%99%20ButterKnife%20%20BindView.html</url>
    <content type="text"><![CDATA[先建三个module，分别为Butterknife ButterKnife-Annotions ButterKnife-compiler,其中butterknife为Android Module其余的都是Java Module。 ButterKnife-Annotions：提供注解。ButterKnife-compiler: 依赖ButterKnife-Annotions,生成代码的module。Butterknife：应用直接使用的库。 Butterknife-Annotions添加注解12345@Retention(CLASS)@Target(FIELD)public @interface BindView &#123; int value();&#125; ButterKnife-compiler添加依赖 123456dependencies &#123; implementation fileTree(include: ['*.jar'], dir: 'libs') implementation 'com.google.auto.service:auto-service:1.0-rc3' implementation 'com.squareup:javapoet:1.9.0' implementation project(':ButterKnife-Annotions')&#125; 写一个生成代码的类ButterKnifeProcessor继承AbstractProcessor123456public class ButterKnifeProcessor extends AbstractProcessor &#123; @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123; return false; &#125;&#125; 我们的步骤是: 添加注解@AutoService(Processor.class) 确定好我们需要生成代码的JAVA版本 确定生成代码 生成代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import com.zzw.butterknife_annotions.BindView;import java.lang.annotation.Annotation;import java.util.LinkedHashSet;import java.util.Set;import javax.annotation.processing.AbstractProcessor;import javax.annotation.processing.RoundEnvironment;import javax.lang.model.SourceVersion;import javax.lang.model.element.TypeElement;//1. 添加注解 @AutoService(Processor.class)@AutoService(Processor.class)public class ButterKnifeProcessor extends AbstractProcessor &#123; //2. 指定处理的版本 &gt;1.7 @Override public SourceVersion getSupportedSourceVersion() &#123; //最高版本 return SourceVersion.latestSupported(); &#125; //3. 指定处理的注解 @Override public Set&lt;String&gt; getSupportedAnnotationTypes() &#123; Set&lt;String&gt; types = new LinkedHashSet&lt;&gt;(); for (Class&lt;? extends Annotation&gt; annotation : getSupportedAnnotations()) &#123; types.add(annotation.getCanonicalName()); &#125; return types; &#125; //4. 在这执行生成类 @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123; return false; &#125; private Set&lt;Class&lt;? extends Annotation&gt;&gt; getSupportedAnnotations() &#123; Set&lt;Class&lt;? extends Annotation&gt;&gt; annotations = new LinkedHashSet&lt;&gt;(); annotations.add(BindView.class); return annotations; &#125;&#125; 我们确定一下这个环境编译是否是正确的Butterknife里面添加ButterKnife-compiler依赖1api project(':ButterKnife-compiler') app添加Butterknife依赖和compiler生成代码依赖 12implementation project(':Butterknife')annotationProcessor project(':ButterKnife-compiler') 在app的MainActivity添加注解123 @BindView(R.id.text_view)TextView textView; 这个时候运行程序报错了提示1234567891011C:\Users\Swartz\Desktop\githubdemo\AptDemo\ButterKnife-compiler\src\main\java\com\zzw\butterknife_compiler\ButterKnifeProcessor.javaError:(21, 20) 错误: 编码GBK的不可映射字符Error:(25, 12) 错误: 编码GBK的不可映射字符Error:(25, 17) 错误: 编码GBK的不可映射字符Error:(29, 20) 错误: 编码GBK的不可映射字符Error:(39, 20) 错误: 编码GBK的不可映射字符Error:Execution failed for task &apos;:Butterknife:javaPreCompileDebug&apos;.&gt; Annotation processors must be explicitly declared now. The following dependencies on the compile classpath are found to contain annotation processor. Please add them to the annotationProcessor configuration. - ButterKnife-compiler.jar (project :ButterKnife-compiler) Alternatively, set android.defaultConfig.javaCompileOptions.annotationProcessorOptions.includeCompileClasspath = true to continue with previous behavior. Note that this option is deprecated and will be removed in the future. See https://developer.android.com/r/tools/annotation-processor-error-message.html for more details. 这个是因为我们在ButterKnifeProcessor这个类使用了中文，所以我们在ButterKnife-compiler中指定编码集123tasks.withType(JavaCompile)&#123; options.encoding='UTF-8'&#125; 这个时候我们在ButterKnifeProcessor里面process函数添加打印1System.out.print("11111"); 然后随便修改一下MainActivity的代码，重新编译在Gradle Console里面就可以看到打印了。这里需要修改MainActivity代码是因为我们是编译时生成，as为了节省时间是重新编译修改了的类，如果不修改的话可以能会不编译。 环境ok了，这下我们就需要重点放在生成代码这块了，这块又分为以下步骤: 因为这getSupportedAnnotationTypes添加的所有注解都会走到process函数，所以我们要将注解按照类来分离。比如AActivity对应那些有那些注解，BActivity里面有那些注解。 生成代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155package com.zzw.butterknife_compiler;import com.google.auto.service.AutoService;import com.squareup.javapoet.ClassName;import com.squareup.javapoet.JavaFile;import com.squareup.javapoet.MethodSpec;import com.squareup.javapoet.TypeSpec;import com.zzw.butterknife_annotions.BindView;import java.io.IOException;import java.lang.annotation.Annotation;import java.util.ArrayList;import java.util.LinkedHashMap;import java.util.LinkedHashSet;import java.util.List;import java.util.Map;import java.util.Set;import javax.annotation.processing.AbstractProcessor;import javax.annotation.processing.Filer;import javax.annotation.processing.ProcessingEnvironment;import javax.annotation.processing.Processor;import javax.annotation.processing.RoundEnvironment;import javax.lang.model.SourceVersion;import javax.lang.model.element.Element;import javax.lang.model.element.Modifier;import javax.lang.model.element.TypeElement;import javax.lang.model.util.Elements;//1. 添加注解 @AutoService(Processor.class)@AutoService(Processor.class)public class ButterKnifeProcessor extends AbstractProcessor &#123; //决定生成的文件在哪个文件夹 private Filer mFiler; //决定生成的生成包名用 private Elements mElementUtils; @Override public synchronized void init(ProcessingEnvironment processingEnv) &#123; super.init(processingEnv); mFiler = processingEnv.getFiler(); mElementUtils = processingEnv.getElementUtils(); &#125; //2. 指定处理的版本 &gt;1.7 @Override public SourceVersion getSupportedSourceVersion() &#123; //最高版本 return SourceVersion.latestSupported(); &#125; //3. 指定处理的注解 @Override public Set&lt;String&gt; getSupportedAnnotationTypes() &#123; Set&lt;String&gt; types = new LinkedHashSet&lt;&gt;(); for (Class&lt;? extends Annotation&gt; annotation : getSupportedAnnotations()) &#123; types.add(annotation.getCanonicalName()); &#125; return types; &#125; //4. 在这执行生成类 @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123; //4.1 注解分类 //拿到所有的注解标记的元素 Set&lt;? extends Element&gt; elements= roundEnv.getElementsAnnotatedWith(BindView.class); //分类集合 Map&lt;Element , List&lt;Element&gt;&gt; elementMap= new LinkedHashMap&lt;&gt;(); //进行分类 for (Element element : elements) &#123; //拿到属于哪个类 Element enclosingElement = element.getEnclosingElement(); List&lt;Element&gt; viewBindElements = elementMap.get(enclosingElement); if(viewBindElements ==null)&#123; viewBindElements = new ArrayList&lt;&gt;(); elementMap.put(enclosingElement,viewBindElements); &#125; viewBindElements.add(element); &#125; //4.2 生成代码 for (Map.Entry&lt;Element,List&lt;Element&gt;&gt; entry : elementMap.entrySet()) &#123; Element enclosingElement = entry.getKey(); List&lt;Element&gt; viewBindElements = entry.getValue(); //类信息 // public final class xxxActivity_ViewBinding implements Unbinder final String activityNameStr = enclosingElement.getSimpleName().toString(); ClassName activityClassName = ClassName.bestGuess(activityNameStr); TypeSpec.Builder classBuilder = TypeSpec.classBuilder( activityNameStr +"_ViewBinding") .addModifiers(Modifier.FINAL,Modifier.PUBLIC) //添加实现 .addSuperinterface(ClassName.get("com.zzw.butterknife","Unbinder")) //添加属性 .addField(activityClassName,"target",Modifier.PRIVATE); //方法信息 //实现unbinder方法 MethodSpec.Builder unbindMethodBuilder = MethodSpec.methodBuilder("unbind") .addAnnotation(Override.class) .addModifiers(Modifier.PUBLIC); unbindMethodBuilder.addStatement("$T target = this.target",activityClassName); unbindMethodBuilder.addStatement("if (target == null) throw new IllegalStateException(\"Bindings already cleared.\");"); //构造函数 MethodSpec.Builder constructorMethodBuilder = MethodSpec.constructorBuilder() .addModifiers(Modifier.PUBLIC) .addParameter(activityClassName,"target"); constructorMethodBuilder.addStatement("this.target = target"); //findViewById for (Element viewBindElement : viewBindElements) &#123; //target.textView1 = Utils.findViewById(target,R.id.text_view1); String filedName = viewBindElement.getSimpleName().toString(); ClassName utilsClassName = ClassName.get("com.zzw.butterknife","Utils"); int resId = viewBindElement.getAnnotation(BindView.class).value(); constructorMethodBuilder.addStatement("target.$L = $T.findViewById(target,$L)",filedName,utilsClassName,resId); unbindMethodBuilder.addStatement("target.$L = null" ,filedName); &#125; //添加构造函数到类里面 classBuilder.addMethod(constructorMethodBuilder.build()); //添加unbinder方法到类里面 classBuilder.addMethod(unbindMethodBuilder.build()); try &#123; //拿到包名 String packageName =mElementUtils.getPackageOf(enclosingElement).getQualifiedName().toString(); JavaFile.builder(packageName,classBuilder.build()) .addFileComment("butterknife 自动生成")//注释 .build() .writeTo(mFiler); &#125; catch (IOException e) &#123; e.printStackTrace(); System.out.print("异常"); &#125; &#125; return false; &#125; private Set&lt;Class&lt;? extends Annotation&gt;&gt; getSupportedAnnotations() &#123; Set&lt;Class&lt;? extends Annotation&gt;&gt; annotations = new LinkedHashSet&lt;&gt;(); annotations.add(BindView.class); return annotations; &#125;&#125; 生成的代码如下：123456789101112131415161718192021222324// butterknife 自动生成package com.zzw.app;import com.zzw.butterknife.Unbinder;import com.zzw.butterknife.Utils;import java.lang.Override;public final class MainActivity_ViewBinding implements Unbinder &#123; private MainActivity target; public MainActivity_ViewBinding(MainActivity target) &#123; this.target = target; target.textView1 = Utils.findViewById(target,2131165301); target.textView2 = Utils.findViewById(target,2131165302); &#125; @Override public void unbind() &#123; MainActivity target = this.target; if (target == null) throw new IllegalStateException("Bindings already cleared.");; target.textView1 = null; target.textView2 = null; &#125;&#125; 我们可以自动生成代码了，这个时候我们可以通过这个来实现findViewById我们在Butterknife module里面建Butterknife这个类12345678910111213141516171819202122232425package com.zzw.butterknife;import android.app.Activity;import java.lang.reflect.Constructor;/** * Des: * Created by zzw on 2018/1/29. */public class Butterknife &#123; public static Unbinder bind(Activity activity)&#123; //xxxActivity_ViewBinding viewBinding = new xxxActivity_ViewBinding(activity); try&#123; Class&lt;? extends Unbinder&gt; bindClass= (Class&lt;? extends Unbinder&gt;) Class.forName(activity.getClass().getName()+"_ViewBinding"); Constructor&lt;? extends Unbinder&gt; bindConstructor= bindClass.getDeclaredConstructor(activity.getClass()); return bindConstructor.newInstance(activity); &#125;catch (Exception e)&#123; e.printStackTrace(); return Unbinder.EMPTY; &#125; &#125;&#125; MainActivity123456789101112131415161718192021222324252627282930313233343536package com.zzw.app;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.widget.TextView;import com.zzw.aptdemo.R;import com.zzw.butterknife.Butterknife;import com.zzw.butterknife.Unbinder;import com.zzw.butterknife_annotions.BindView;public class MainActivity extends AppCompatActivity &#123; @BindView(R.id.text_view1) TextView textView1; @BindView(R.id.text_view2) TextView textView2; private Unbinder mUnbinder; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mUnbinder = Butterknife.bind(this); textView1.setText("你好 大哥"); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); mUnbinder.unbind(); &#125;&#125; 该文中Butterknife module用到的类:123456789101112131415import android.support.annotation.UiThread;/** * Des: * Created by zzw on 2018/1/29. */public interface Unbinder &#123; @UiThread void unbind(); Unbinder EMPTY = new Unbinder() &#123; @Override public void unbind() &#123; &#125; &#125;;&#125; 123456789101112131415package com.zzw.butterknife;import android.app.Activity;import android.view.View;/** * Des: * Created by zzw on 2018/1/29. */public class Utils &#123; public static &lt;T extends View&gt;T findViewById(Activity activity,int viewId)&#123; return activity.findViewById(viewId); &#125;&#125;]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手写 Parcelable 序列化和反序列化的具体过程]]></title>
    <url>%2F%E6%89%8B%E5%86%99%20Parcelable%20%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%85%B7%E4%BD%93%E8%BF%87%E7%A8%8B.html</url>
    <content type="text"><![CDATA[123456binder 和 socket 通信的区别有哪些 : binder 共享内存，Soket需要copy内存 Socket 远程，本地低速（zygote）Serializable 和 Parcelable 之间的区别: (io流，共享内存) Parcelable 序列化和反序列化的具体过程 Parcel.kt 1234567891011121314151617181920212223242526272829303132333435363738package zzw.com.testparcelpublic class Parcel &#123; companion object &#123; // Used to load the 'native-lib' library on application startup. init &#123; System.loadLibrary("native-lib") &#125; &#125; private var mNativePtr: Long = 0 init &#123; mNativePtr = nativeCreate() &#125; fun writeInt(value: Int) &#123; nativeWriteInt(mNativePtr, value) &#125; fun readInt(): Int &#123; return nativeReadInt(mNativePtr) &#125; fun setDataPosition(pos: Int) &#123; nativeSetDataPosition(mNativePtr, pos) &#125; private external fun nativeCreate(): Long private external fun nativeSetDataPosition(nativePtr: Long, pos: Int) private external fun nativeWriteInt(nativePtr: Long, value: Int) private external fun nativeReadInt(nativePtr: Long): Int&#125; native-lib.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;jni.h&gt;#include &lt;stdlib.h&gt;#include &lt;string&gt;class Parcel &#123; char *mData;//共享内存首地址 int mDataPos = 0;//当前指针位置public: Parcel() &#123; mData = (char *) malloc(1024); &#125; void writeInt(jint value) &#123; *reinterpret_cast&lt;int *&gt;(mData + mDataPos) = value; mDataPos += sizeof(int); &#125; void setDataPosition(jint i) &#123; mDataPos = i; &#125; jint readInt() &#123; int result = *reinterpret_cast&lt;int *&gt;(mData + mDataPos); mDataPos += sizeof(int); return result; &#125;&#125;;extern "C" JNIEXPORT jlongJNICALLJava_zzw_com_testparcel_Parcel_nativeCreate( JNIEnv *env, jobject /* this */) &#123; return reinterpret_cast&lt;jlong&gt;(new Parcel());&#125;extern "C" JNIEXPORT voidJNICALLJava_zzw_com_testparcel_Parcel_nativeWriteInt( JNIEnv *env, jobject, jlong ptr, jint value) &#123; Parcel *parcel = reinterpret_cast&lt;Parcel *&gt;(ptr); parcel-&gt;writeInt(value);&#125;extern "C" JNIEXPORT voidJNICALLJava_zzw_com_testparcel_Parcel_nativeSetDataPosition( JNIEnv *env, jobject, jlong ptr, jint pos) &#123; Parcel *parcel = reinterpret_cast&lt;Parcel *&gt;(ptr); parcel-&gt;setDataPosition(pos);&#125;extern "C" JNIEXPORT jintJNICALLJava_zzw_com_testparcel_Parcel_nativeReadInt( JNIEnv *env, jobject, jlong ptr) &#123; Parcel *parcel = reinterpret_cast&lt;Parcel *&gt;(ptr); return parcel-&gt;readInt();&#125; MainActivity.kt123456789101112131415161718192021222324252627package zzw.com.testparcelimport android.support.v7.app.AppCompatActivityimport android.os.Bundleimport android.util.Logimport kotlinx.android.synthetic.main.activity_main.*class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) var parcel = Parcel() parcel.writeInt(5) parcel.writeInt(10) parcel.setDataPosition(0) var num1 = parcel.readInt() var num2 = parcel.readInt() Log.e(&quot;zzz&quot;, &quot;num1 =$num1 num2=$num2 &quot;) &#125;&#125; writeString分为两节，会先把长度存着，然后后面跟着具体的数据]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android aidl流程简单分析]]></title>
    <url>%2FAndroid%20aidl%E6%B5%81%E7%A8%8B%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90.html</url>
    <content type="text"><![CDATA[我们通过写一个从服务端（另外一个进程）获取用户名和密码作为demo来进行源码讲解。 先new一个IUserAidl.aidl 123456interface IUserAidl &#123; //注意 String S大写 String getUserName(); String getPwd();&#125; make生成IUserAidl.java文件 写一个service作为服务端 123456789101112131415161718192021222324252627/** * Des: * Created by zzw on 2018/1/26. */public class MessageService extends Service &#123; @Nullable @Override public IBinder onBind(Intent intent) &#123; return new UserBinder(); &#125; private final class UserBinder extends IUserAidl.Stub &#123; @Override public String getUserName() throws RemoteException &#123; return "zzw"; &#125; @Override public String getPwd() throws RemoteException &#123; return "123456"; &#125; &#125;&#125; AndroidManifest.xml注册service 123&lt;service android:process=":test" android:name=".MessageService"/&gt; Activity绑定 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 public class MainActivity extends AppCompatActivity &#123; //客户端获取的aidl实例 ， 通过这个实例就可以进行通讯 private IUserAidl mIUserAidl; private ServiceConnection mServiceConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; //连接 mIUserAidl = IUserAidl.Stub.asInterface(service); Log.e("zzz", "连接成功"); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; //断开连接 Log.e("zzz", "断开连接"); &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //启动服务 Intent intent = new Intent(this, MessageService.class); bindService(intent, mServiceConnection, Context.BIND_AUTO_CREATE); &#125; public void getUserName(View view) &#123; try &#123; if (mIUserAidl != null) &#123; String userName = mIUserAidl.getUserName(); Log.e("zzz", userName); &#125; &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; public void getPwd(View view) &#123; try &#123; if (mIUserAidl != null) &#123; String pwd = mIUserAidl.getPwd(); Log.e("zzz", pwd); &#125; &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); unbindService(mServiceConnection); &#125;&#125; 启动应用，发现是有test进程的 ，说明没问题。在当前客户端的进程(Acticity)可以发现是打印连接成功，然后依次点击获取用户名和密码，都对应打印成功，说明程序正常。我们接下来就开始分析源码，看看是怎么通讯的。 IUserAidl.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119public interface IUserAidl extends android.os.IInterface &#123; /** * Local-side IPC implementation stub class. */ public static abstract class Stub extends android.os.Binder implements com.zzw.testaidl.IUserAidl &#123; private static final java.lang.String DESCRIPTOR = "com.zzw.testaidl.IUserAidl"; /** * Construct the stub at attach it to the interface. */ public Stub() &#123; this.attachInterface(this, DESCRIPTOR); &#125; /** * Cast an IBinder object into an com.zzw.testaidl.IUserAidl interface, * generating a proxy if needed. */ public static com.zzw.testaidl.IUserAidl asInterface(android.os.IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof com.zzw.testaidl.IUserAidl))) &#123; return ((com.zzw.testaidl.IUserAidl) iin); &#125; return new com.zzw.testaidl.IUserAidl.Stub.Proxy(obj); &#125; @Override public android.os.IBinder asBinder() &#123; return this; &#125; @Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_getUserName: &#123; data.enforceInterface(DESCRIPTOR); java.lang.String _result = this.getUserName(); reply.writeNoException(); reply.writeString(_result); return true; &#125; case TRANSACTION_getPwd: &#123; data.enforceInterface(DESCRIPTOR); java.lang.String _result = this.getPwd(); reply.writeNoException(); reply.writeString(_result); return true; &#125; &#125; return super.onTransact(code, data, reply, flags); &#125; private static class Proxy implements com.zzw.testaidl.IUserAidl &#123; private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) &#123; mRemote = remote; &#125; @Override public android.os.IBinder asBinder() &#123; return mRemote; &#125; public java.lang.String getInterfaceDescriptor() &#123; return DESCRIPTOR; &#125; @Override public java.lang.String getUserName() throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); java.lang.String _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_getUserName, _data, _reply, 0); _reply.readException(); _result = _reply.readString(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result; &#125; @Override public java.lang.String getPwd() throws android.os.RemoteException &#123; android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); java.lang.String _result; try &#123; _data.writeInterfaceToken(DESCRIPTOR); mRemote.transact(Stub.TRANSACTION_getPwd, _data, _reply, 0); _reply.readException(); _result = _reply.readString(); &#125; finally &#123; _reply.recycle(); _data.recycle(); &#125; return _result; &#125; &#125; static final int TRANSACTION_getUserName = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); static final int TRANSACTION_getPwd = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1); &#125; public java.lang.String getUserName() throws android.os.RemoteException; public java.lang.String getPwd() throws android.os.RemoteException;&#125; 从上面这些代码我们可以知道，当客户端(Activity)和服务端(Service)bind的时候，服务端会把IUserAidl.Stub当做IBinder给传过来，然后通过IUserAidl.Stub.asInterface(service);拿到真正的IUserAidl实现类IUserAidl.Stub.Proxy。我们进入IUserAidl.Stub.Proxy这个类中,从调用的函数(getUserName getPwd)点进去查看是怎么进行通讯的。 123456Proxy关键代码://mRemote是服务端返回的IBinder实例 IUserAidl.Stub_data.writeInterfaceToken(DESCRIPTOR);mRemote.transact(Stub.TRANSACTION_getUserName, _data, _reply, 0);_reply.readException();_result = _reply.readString(); 看到实际是调用了IUserAidl.Stub的transact函数,但是在IUserAidl.Stub中并没有transact函数，只有一个onTransact函数，这里我们可以猜测应该是调用transact的时候调用了onTransact函数1234567891011121314Stub.onTransact关键代码@Override public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException &#123; switch (code) &#123; case TRANSACTION_getUserName: &#123; data.enforceInterface(DESCRIPTOR); java.lang.String _result = this.getUserName(); reply.writeNoException(); reply.writeString(_result); return true; &#125; &#125; &#125; 首先通过code判断调用的是那个函数，然后在调用服务端的getUserName()函数拿到对应的值，在写入reply里面，然后在Proxy里面通过_reply读取出来，这样就完成了数据传递。 我们来验证我们的想法是不是在transact调用了onTransact。我们知道mRemote是IUserAidl.Stub,他是继承Binder的，在Binder查看到transact函数123456789101112131415161718/** * Default implementation rewinds the parcels and calls onTransact. On * the remote side, transact calls into the binder to do the IPC. */ public final boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; if (false) Log.v("Binder", "Transact: " + code + " to " + this); if (data != null) &#123; data.setDataPosition(0); &#125; boolean r = onTransact(code, data, reply, flags); if (reply != null) &#123; reply.setDataPosition(0); &#125; return r; &#125; 我们从这段代码就可以看到确实是在transact中调用了onTransact函数。 总结： 客户端通过bind拿到服务端IBinder对象xxxx.Stub,然后通过xxxx.Stub.asInterface函数拿到对应的服务端通讯的代理类xxxx.Stub.Proxy。 每个通讯的函数和都会生成一个code，当我们客户端调用函数时都会通过服务端xxxx.Stub对象调用transact函数，并将相应的code Parcel对象传入，然后回调onTransact函数，通过code判断调用服务端的对应的函数，拿到对应的数据将之写入Parcel里面 服务端调用完毕之后，客户端通过Parcel拿到对应的数据，然后返回即可。]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[retrofit 源码分析]]></title>
    <url>%2Fretrofit%E6%BA%90%E7%A0%81.html</url>
    <content type="text"><![CDATA[retrofit的初始化123456789101112131415161718192021222324252627282930313233343536private static Retrofit RETROFIT;private static Retrofit getRetrofit() &#123; if (RETROFIT == null) &#123; RETROFIT = new Retrofit.Builder() .client(getHttpClient()) .baseUrl(BuildConfig.SERVER_URL) .addConverterFactory(NobodyConverterFactory.create()) .addConverterFactory(GsonConverterFactory.create(new GsonBuilder() .registerTypeAdapter(new TypeToken&lt;HashMap&lt;String, Object&gt;&gt;() &#123; &#125;.getType(), new MapTypeAdapter()).create())) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .build(); &#125; return RETROFIT;&#125;static OkHttpClient getHttpClient() &#123; return new OkHttpClient.Builder() .connectTimeout(15, TimeUnit.SECONDS) .readTimeout(15, TimeUnit.SECONDS) .writeTimeout(15, TimeUnit.SECONDS) .retryOnConnectionFailure(true) .addInterceptor(AccessTokenInterceptor.getInstance()) .addInterceptor(new RefreshTokenInterceptor( BuildConfig.SERVER_URL)) .addInterceptor(new ErrorPreviewInterceptor()) .addInterceptor(new HttpLoggingInterceptor(new HttpLoggingInterceptor.Logger() &#123; @Override public void log(String message) &#123; LogUtils.i(TAG, message); &#125; &#125;).setLevel(HttpLoggingInterceptor .Level.BODY)) .build();&#125; Refofit.Builder: 初始化过程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * Build a new &#123;@link Retrofit&#125;. * &lt;p&gt; * Calling &#123;@link #baseUrl&#125; is required before calling &#123;@link #build()&#125;. All other methods * are optional. */ public static final class Builder &#123; //平台 android？ java8？ ios？ private final Platform platform; //ok3网络请求Factory private okhttp3.Call.Factory callFactory; // host private HttpUrl baseUrl; // 数据转换器 request和responseBody解析器 string --&gt;gson--&gt;T private final List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(); // ok3返回的 response 转换器 response--&gt; rxjava对象 private final List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(); //线程调度 private Executor callbackExecutor; //如果设置为true 在service create的时候就先把方法参数解析出来加入缓存 //设置为false 在调用这个函数的时候在加入缓存 private boolean validateEagerly; Builder(Platform platform) &#123; this.platform = platform; // Add the built-in converter factory first. This prevents overriding its behavior but also // ensures correct behavior when using converters that consume all types. converterFactories.add(new BuiltInConverters()); &#125; public Builder() &#123; this(Platform.get()); &#125; Builder(Retrofit retrofit) &#123; platform = Platform.get(); callFactory = retrofit.callFactory; baseUrl = retrofit.baseUrl; converterFactories.addAll(retrofit.converterFactories); adapterFactories.addAll(retrofit.adapterFactories); // Remove the default, platform-aware call adapter added by build(). adapterFactories.remove(adapterFactories.size() - 1); callbackExecutor = retrofit.callbackExecutor; validateEagerly = retrofit.validateEagerly; &#125; /** * Create the &#123;@link Retrofit&#125; instance using the configured values. * &lt;p&gt; * Note: If neither &#123;@link #client&#125; nor &#123;@link #callFactory&#125; is called a default &#123;@link * OkHttpClient&#125; will be created and used. */ public Retrofit build() &#123; if (baseUrl == null) &#123; throw new IllegalStateException("Base URL required."); &#125; okhttp3.Call.Factory callFactory = this.callFactory; if (callFactory == null) &#123; callFactory = new OkHttpClient(); &#125; Executor callbackExecutor = this.callbackExecutor; if (callbackExecutor == null) &#123; callbackExecutor = platform.defaultCallbackExecutor(); &#125; // Make a defensive copy of the adapters and add the default Call adapter. List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(this.adapterFactories); adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor)); // Make a defensive copy of the converters. List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(this.converterFactories); return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories, callbackExecutor, validateEagerly); &#125; &#125; create1234567891011121314151617181920212223242526272829303132public &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; Utils.validateServiceInterface(service); if (validateEagerly) &#123; eagerlyValidateMethods(service); &#125; //动态代理 return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; //Android private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // If the method is a method from Object then defer to normal invocation. //如果是object的函数 直接执行 if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; //如果是platform的默认函数 预留的一个钩子 if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; //加载service的方法 ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method); //根据ServiceMethod得到ok3的网络请求call OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); //网络请求 数据转换 返回数据 return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;); &#125; loadServiceMethod: 拿到对应的解析器，根据注解解析方法的返回类型，方法参数，网络请求的一系列参数 封装成一个对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192 ServiceMethod&lt;?, ?&gt; loadServiceMethod(Method method) &#123; // 读缓存 ServiceMethod&lt;?, ?&gt; result = serviceMethodCache.get(method); if (result != null) return result; synchronized (serviceMethodCache) &#123; result = serviceMethodCache.get(method); if (result == null) &#123; //得到ServiceMethod对象 result = new ServiceMethod.Builder&lt;&gt;(this, method).build(); //加入缓存 serviceMethodCache.put(method, result); &#125; &#125; return result; &#125;ServiceMethod: Builder(Retrofit retrofit, Method method) &#123; this.retrofit = retrofit; this.method = method; this.methodAnnotations = method.getAnnotations(); this.parameterTypes = method.getGenericParameterTypes(); this.parameterAnnotationsArray = method.getParameterAnnotations(); &#125;public ServiceMethod build() &#123; //根据返回类型以及retrofit的adapterFactories拿到callAdapter解析器 callAdapter = createCallAdapter(); //解析之后的类型 responseType = callAdapter.responseType(); if (responseType == Response.class || responseType == okhttp3.Response.class) &#123; throw methodError("'" + Utils.getRawType(responseType).getName() + "' is not a valid response body type. Did you mean ResponseBody?"); &#125; //根据responseType通过retrofit的converterFactories拿到 responseBody解析器 responseConverter = createResponseConverter(); //后面都是解析注解 拼接参数 for (Annotation annotation : methodAnnotations) &#123; parseMethodAnnotation(annotation); &#125; if (httpMethod == null) &#123; throw methodError("HTTP method annotation is required (e.g., @GET, @POST, etc.)."); &#125; if (!hasBody) &#123; if (isMultipart) &#123; throw methodError( "Multipart can only be specified on HTTP methods with request body (e.g., @POST)."); &#125; if (isFormEncoded) &#123; throw methodError("FormUrlEncoded can only be specified on HTTP methods with " + "request body (e.g., @POST)."); &#125; &#125; int parameterCount = parameterAnnotationsArray.length; parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount]; for (int p = 0; p &lt; parameterCount; p++) &#123; Type parameterType = parameterTypes[p]; if (Utils.hasUnresolvableType(parameterType)) &#123; throw parameterError(p, "Parameter type must not include a type variable or wildcard: %s", parameterType); &#125; Annotation[] parameterAnnotations = parameterAnnotationsArray[p]; if (parameterAnnotations == null) &#123; throw parameterError(p, "No Retrofit annotation found."); &#125; parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations); &#125; if (relativeUrl == null &amp;&amp; !gotUrl) &#123; throw methodError("Missing either @%s URL or @Url parameter.", httpMethod); &#125; if (!isFormEncoded &amp;&amp; !isMultipart &amp;&amp; !hasBody &amp;&amp; gotBody) &#123; throw methodError("Non-body HTTP method cannot contain @Body."); &#125; if (isFormEncoded &amp;&amp; !gotField) &#123; throw methodError("Form-encoded method must contain at least one @Field."); &#125; if (isMultipart &amp;&amp; !gotPart) &#123; throw methodError("Multipart method must contain at least one @Part."); &#125; return new ServiceMethod&lt;&gt;(this); &#125; OkHttpCall:是一个ok3的call ，用于网络请求123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310/* * Copyright (C) 2015 Square, Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package retrofit2;import java.io.IOException;import okhttp3.MediaType;import okhttp3.Request;import okhttp3.ResponseBody;import okio.Buffer;import okio.BufferedSource;import okio.ForwardingSource;import okio.Okio;final class OkHttpCall&lt;T&gt; implements Call&lt;T&gt; &#123; private final ServiceMethod&lt;T, ?&gt; serviceMethod; private final Object[] args; private volatile boolean canceled; // All guarded by this. private okhttp3.Call rawCall; private Throwable creationFailure; // Either a RuntimeException or IOException. private boolean executed; OkHttpCall(ServiceMethod&lt;T, ?&gt; serviceMethod, Object[] args) &#123; this.serviceMethod = serviceMethod; this.args = args; &#125; @SuppressWarnings("CloneDoesntCallSuperClone") // We are a final type &amp; this saves clearing state. @Override public OkHttpCall&lt;T&gt; clone() &#123; return new OkHttpCall&lt;&gt;(serviceMethod, args); &#125; //请求 @Override public synchronized Request request() &#123; okhttp3.Call call = rawCall; if (call != null) &#123; return call.request(); &#125; if (creationFailure != null) &#123; if (creationFailure instanceof IOException) &#123; throw new RuntimeException("Unable to create request.", creationFailure); &#125; else &#123; throw (RuntimeException) creationFailure; &#125; &#125; try &#123; return (rawCall = createRawCall()).request(); &#125; catch (RuntimeException e) &#123; creationFailure = e; throw e; &#125; catch (IOException e) &#123; creationFailure = e; throw new RuntimeException("Unable to create request.", e); &#125; &#125; //异步请求 @Override public void enqueue(final Callback&lt;T&gt; callback) &#123; if (callback == null) throw new NullPointerException("callback == null"); okhttp3.Call call; Throwable failure; synchronized (this) &#123; if (executed) throw new IllegalStateException("Already executed."); executed = true; call = rawCall; failure = creationFailure; if (call == null &amp;&amp; failure == null) &#123; try &#123; call = rawCall = createRawCall(); &#125; catch (Throwable t) &#123; failure = creationFailure = t; &#125; &#125; &#125; if (failure != null) &#123; callback.onFailure(this, failure); return; &#125; if (canceled) &#123; call.cancel(); &#125; call.enqueue(new okhttp3.Callback() &#123; @Override public void onResponse(okhttp3.Call call, okhttp3.Response rawResponse) throws IOException &#123; Response&lt;T&gt; response; try &#123; response = parseResponse(rawResponse); &#125; catch (Throwable e) &#123; callFailure(e); return; &#125; callSuccess(response); &#125; @Override public void onFailure(okhttp3.Call call, IOException e) &#123; try &#123; callback.onFailure(OkHttpCall.this, e); &#125; catch (Throwable t) &#123; t.printStackTrace(); &#125; &#125; private void callFailure(Throwable e) &#123; try &#123; callback.onFailure(OkHttpCall.this, e); &#125; catch (Throwable t) &#123; t.printStackTrace(); &#125; &#125; private void callSuccess(Response&lt;T&gt; response) &#123; try &#123; callback.onResponse(OkHttpCall.this, response); &#125; catch (Throwable t) &#123; t.printStackTrace(); &#125; &#125; &#125;); &#125; @Override public synchronized boolean isExecuted() &#123; return executed; &#125; @Override public Response&lt;T&gt; execute() throws IOException &#123; okhttp3.Call call; synchronized (this) &#123; if (executed) throw new IllegalStateException("Already executed."); executed = true; if (creationFailure != null) &#123; if (creationFailure instanceof IOException) &#123; throw (IOException) creationFailure; &#125; else &#123; throw (RuntimeException) creationFailure; &#125; &#125; call = rawCall; if (call == null) &#123; try &#123; call = rawCall = createRawCall(); &#125; catch (IOException | RuntimeException e) &#123; creationFailure = e; throw e; &#125; &#125; &#125; if (canceled) &#123; call.cancel(); &#125; return parseResponse(call.execute()); &#125; //创建realCall ok3的 private okhttp3.Call createRawCall() throws IOException &#123; //组装参数 Request request = serviceMethod.toRequest(args); okhttp3.Call call = serviceMethod.callFactory.newCall(request); if (call == null) &#123; throw new NullPointerException("Call.Factory returned null."); &#125; return call; &#125; //解析response Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException &#123; ResponseBody rawBody = rawResponse.body(); // Remove the body's source (the only stateful object) so we can pass the response along. rawResponse = rawResponse.newBuilder() .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength())) .build(); int code = rawResponse.code(); if (code &lt; 200 || code &gt;= 300) &#123; try &#123; // Buffer the entire body to avoid future I/O. ResponseBody bufferedBody = Utils.buffer(rawBody); return Response.error(bufferedBody, rawResponse); &#125; finally &#123; rawBody.close(); &#125; &#125; if (code == 204 || code == 205) &#123; rawBody.close(); return Response.success(null, rawResponse); &#125; ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody); try &#123; //通过response解析器进行类型转换 T body = serviceMethod.toResponse(catchingBody); return Response.success(body, rawResponse); &#125; catch (RuntimeException e) &#123; // If the underlying source threw an exception, propagate that rather than indicating it was // a runtime exception. catchingBody.throwIfCaught(); throw e; &#125; &#125; public void cancel() &#123; canceled = true; okhttp3.Call call; synchronized (this) &#123; call = rawCall; &#125; if (call != null) &#123; call.cancel(); &#125; &#125; @Override public boolean isCanceled() &#123; if (canceled) &#123; return true; &#125; synchronized (this) &#123; return rawCall != null &amp;&amp; rawCall.isCanceled(); &#125; &#125; static final class NoContentResponseBody extends ResponseBody &#123; private final MediaType contentType; private final long contentLength; NoContentResponseBody(MediaType contentType, long contentLength) &#123; this.contentType = contentType; this.contentLength = contentLength; &#125; @Override public MediaType contentType() &#123; return contentType; &#125; @Override public long contentLength() &#123; return contentLength; &#125; @Override public BufferedSource source() &#123; throw new IllegalStateException("Cannot read raw response body of a converted body."); &#125; &#125; static final class ExceptionCatchingRequestBody extends ResponseBody &#123; private final ResponseBody delegate; IOException thrownException; ExceptionCatchingRequestBody(ResponseBody delegate) &#123; this.delegate = delegate; &#125; @Override public MediaType contentType() &#123; return delegate.contentType(); &#125; @Override public long contentLength() &#123; return delegate.contentLength(); &#125; @Override public BufferedSource source() &#123; return Okio.buffer(new ForwardingSource(delegate.source()) &#123; @Override public long read(Buffer sink, long byteCount) throws IOException &#123; try &#123; return super.read(sink, byteCount); &#125; catch (IOException e) &#123; thrownException = e; throw e; &#125; &#125; &#125;); &#125; @Override public void close() &#123; delegate.close(); &#125; void throwIfCaught() throws IOException &#123; if (thrownException != null) &#123; throw thrownException; &#125; &#125; &#125;&#125; CallAdapter的选择：ServiceMethon.createCallAdapter()–&gt;retrofit.callAdapter() –&gt;retrofit.nextCallAdapter() –&gt;adapterFactories.get();1234567891011121314151617181920212223242526272829303132333435/** * Returns the &#123;@link CallAdapter&#125; for &#123;@code returnType&#125; from the available &#123;@linkplain * #callAdapterFactories() factories&#125; except &#123;@code skipPast&#125;. * * @throws IllegalArgumentException if no call adapter available for &#123;@code type&#125;. */public CallAdapter&lt;?, ?&gt; nextCallAdapter(CallAdapter.Factory skipPast, Type returnType, Annotation[] annotations) &#123; checkNotNull(returnType, "returnType == null"); checkNotNull(annotations, "annotations == null"); int start = adapterFactories.indexOf(skipPast) + 1; for (int i = start, count = adapterFactories.size(); i &lt; count; i++) &#123; CallAdapter&lt;?, ?&gt; adapter = adapterFactories.get(i).get(returnType, annotations, this); if (adapter != null) &#123; return adapter; &#125; &#125; StringBuilder builder = new StringBuilder("Could not locate call adapter for ") .append(returnType) .append(".\n"); if (skipPast != null) &#123; builder.append(" Skipped:"); for (int i = 0; i &lt; start; i++) &#123; builder.append("\n * ").append(adapterFactories.get(i).getClass().getName()); &#125; builder.append('\n'); &#125; builder.append(" Tried:"); for (int i = start, count = adapterFactories.size(); i &lt; count; i++) &#123; builder.append("\n * ").append(adapterFactories.get(i).getClass().getName()); &#125; throw new IllegalArgumentException(builder.toString());&#125; 看看RxJava2CallAdapterFactory的get函数,拿到属于自己的RxJava2CallAdapter 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Override public CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123; Class&lt;?&gt; rawType = getRawType(returnType); if (rawType == Completable.class) &#123; // Completable is not parameterized (which is what the rest of this method deals with) so it // can only be created with a single configuration. return new RxJava2CallAdapter(Void.class, scheduler, isAsync, false, true, false, false, false, true); &#125; boolean isFlowable = rawType == Flowable.class; boolean isSingle = rawType == Single.class; boolean isMaybe = rawType == Maybe.class; if (rawType != Observable.class &amp;&amp; !isFlowable &amp;&amp; !isSingle &amp;&amp; !isMaybe) &#123; return null; &#125; boolean isResult = false; boolean isBody = false; Type responseType; if (!(returnType instanceof ParameterizedType)) &#123; String name = isFlowable ? "Flowable" : isSingle ? "Single" : isMaybe ? "Maybe" : "Observable"; throw new IllegalStateException(name + " return type must be parameterized" + " as " + name + "&lt;Foo&gt; or " + name + "&lt;? extends Foo&gt;"); &#125; Type observableType = getParameterUpperBound(0, (ParameterizedType) returnType); Class&lt;?&gt; rawObservableType = getRawType(observableType); if (rawObservableType == Response.class) &#123; if (!(observableType instanceof ParameterizedType)) &#123; throw new IllegalStateException("Response must be parameterized" + " as Response&lt;Foo&gt; or Response&lt;? extends Foo&gt;"); &#125; responseType = getParameterUpperBound(0, (ParameterizedType) observableType); &#125; else if (rawObservableType == Result.class) &#123; if (!(observableType instanceof ParameterizedType)) &#123; throw new IllegalStateException("Result must be parameterized" + " as Result&lt;Foo&gt; or Result&lt;? extends Foo&gt;"); &#125; responseType = getParameterUpperBound(0, (ParameterizedType) observableType); isResult = true; &#125; else &#123; responseType = observableType; isBody = true; &#125; return new RxJava2CallAdapter(responseType, scheduler, isAsync, isResult, isBody, isFlowable, isSingle, isMaybe, false); &#125; 我们在拿到ok3的response之后转换为我们需要的类型通过callAdapter的adapter函数，看下RxJava2CallAdapter1234567891011121314151617181920212223242526272829303132@Override public Object adapt(Call&lt;R&gt; call) &#123; Observable&lt;Response&lt;R&gt;&gt; responseObservable = isAsync ? new CallEnqueueObservable&lt;&gt;(call) : new CallExecuteObservable&lt;&gt;(call); Observable&lt;?&gt; observable; if (isResult) &#123; observable = new ResultObservable&lt;&gt;(responseObservable); &#125; else if (isBody) &#123; observable = new BodyObservable&lt;&gt;(responseObservable); &#125; else &#123; observable = responseObservable; &#125; if (scheduler != null) &#123; observable = observable.subscribeOn(scheduler); &#125; if (isFlowable) &#123; return observable.toFlowable(BackpressureStrategy.LATEST); &#125; if (isSingle) &#123; return observable.singleOrError(); &#125; if (isMaybe) &#123; return observable.singleElement(); &#125; if (isCompletable) &#123; return observable.ignoreElements(); &#125; return observable; &#125; 解析看responseConverter，ServiceMthon.createResponseConverter()–&gt;retrofit.responseBodyConverter–&gt;retrofit.nextResponseBodyConverter() 12345678910111213141516171819202122232425262728293031323334353637/** * Returns a &#123;@link Converter&#125; for &#123;@link ResponseBody&#125; to &#123;@code type&#125; from the available * &#123;@linkplain #converterFactories() factories&#125; except &#123;@code skipPast&#125;. * * @throws IllegalArgumentException if no converter available for &#123;@code type&#125;. */ public &lt;T&gt; Converter&lt;ResponseBody, T&gt; nextResponseBodyConverter(Converter.Factory skipPast, Type type, Annotation[] annotations) &#123; checkNotNull(type, "type == null"); checkNotNull(annotations, "annotations == null"); int start = converterFactories.indexOf(skipPast) + 1; for (int i = start, count = converterFactories.size(); i &lt; count; i++) &#123; Converter&lt;ResponseBody, ?&gt; converter = converterFactories.get(i).responseBodyConverter(type, annotations, this); if (converter != null) &#123; //noinspection unchecked return (Converter&lt;ResponseBody, T&gt;) converter; &#125; &#125; StringBuilder builder = new StringBuilder("Could not locate ResponseBody converter for ") .append(type) .append(".\n"); if (skipPast != null) &#123; builder.append(" Skipped:"); for (int i = 0; i &lt; start; i++) &#123; builder.append("\n * ").append(converterFactories.get(i).getClass().getName()); &#125; builder.append('\n'); &#125; builder.append(" Tried:"); for (int i = start, count = converterFactories.size(); i &lt; count; i++) &#123; builder.append("\n * ").append(converterFactories.get(i).getClass().getName()); &#125; throw new IllegalArgumentException(builder.toString()); &#125; 看看GsonConverterFactory12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * A &#123;@linkplain Converter.Factory converter&#125; which uses Gson for JSON. * &lt;p&gt; * Because Gson is so flexible in the types it supports, this converter assumes that it can handle * all types. If you are mixing JSON serialization with something else (such as protocol buffers), * you must &#123;@linkplain Retrofit.Builder#addConverterFactory(Converter.Factory) add this instance&#125; * last to allow the other converters a chance to see their types. */public final class GsonConverterFactory extends Converter.Factory &#123; /** * Create an instance using a default &#123;@link Gson&#125; instance for conversion. Encoding to JSON and * decoding from JSON (when no charset is specified by a header) will use UTF-8. */ public static GsonConverterFactory create() &#123; return create(new Gson()); &#125; /** * Create an instance using &#123;@code gson&#125; for conversion. Encoding to JSON and * decoding from JSON (when no charset is specified by a header) will use UTF-8. */ public static GsonConverterFactory create(Gson gson) &#123; return new GsonConverterFactory(gson); &#125; private final Gson gson; private GsonConverterFactory(Gson gson) &#123; if (gson == null) throw new NullPointerException("gson == null"); this.gson = gson; &#125; @Override public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123; TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type)); return new GsonResponseBodyConverter&lt;&gt;(gson, adapter); &#125; @Override public Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) &#123; TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type)); return new GsonRequestBodyConverter&lt;&gt;(gson, adapter); &#125;&#125; 通过工程得到GsonResponseBodyConverter1234567891011121314151617181920212223242526import com.google.gson.Gson;import com.google.gson.TypeAdapter;import com.google.gson.stream.JsonReader;import java.io.IOException;import okhttp3.ResponseBody;import retrofit2.Converter;final class GsonResponseBodyConverter&lt;T&gt; implements Converter&lt;ResponseBody, T&gt; &#123; private final Gson gson; private final TypeAdapter&lt;T&gt; adapter; GsonResponseBodyConverter(Gson gson, TypeAdapter&lt;T&gt; adapter) &#123; this.gson = gson; this.adapter = adapter; &#125; @Override public T convert(ResponseBody value) throws IOException &#123; JsonReader jsonReader = gson.newJsonReader(value.charStream()); try &#123; return adapter.read(jsonReader); &#125; finally &#123; value.close(); &#125; &#125;&#125; 当然请求和GsonResponseBodyConverter类似，也是通过工厂来生成。 总结: 动态代理实现接口函数调用的拦截 通过返回类型来和CallAdapter.Factory遍历对比调用get函数拿到对应于的callAdapter，然后通过callAdapter.adapter函数来进行数据转换 通过返回类型来和Converter.Factory遍历对比调用responseBodyConverter和requestBodyConverter函数拿到对应于的Converter，然后通过Converter.convert函数来进行请求数据或者responseBody的数据转换 参数解析的时候判断很多，根据你的参数不同实例不同的ParameterHandler，请求的时候通过ParameterHandler组装数据 参考链接：retrofit源码]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeakCanary 原理浅析]]></title>
    <url>%2FLeakCanary%20%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90.html</url>
    <content type="text"><![CDATA[使用方法1234567891011在Application里初始化this.mRefWatcher = BuildConfig.DEBUG ? LeakCanary.install(this) : RefWatcher.DISABLED;fragment的onDestroy@Override public void onDestroy() &#123; super.onDestroy(); RefWatcher refWatcher = App.getMyApplicationContext().getRefWatcher(); refWatcher.watch(this); &#125; 简述：install的时候为application注册Application.ActivityLifecycleCallbacks，然后在onActivityDestroyed为当前activity添加弱引用，手动触发gc，收集日志然后报警与否。 LeakCanary 原理浅析 LeakCanary原理浅析 详细]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThreadLocal源码分析]]></title>
    <url>%2FThreadLocal%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</url>
    <content type="text"><![CDATA[ThreadLocal的作用是保证当前线程对象的唯一性，在android源码中有大量的应用，是怎么实现的呢？ set: 1234567891011121314151617181920212223242526272829303132333435363738/** * Sets the current thread's copy of this thread-local variable * to the specified value. Most subclasses will have no need to * override this method, relying solely on the &#123;@link #initialValue&#125; * method to set the values of thread-locals. * * @param value the value to be stored in the current thread's copy of * this thread-local. */ public void set(T value) &#123; //得到当前线程对象 Thread t = Thread.currentThread(); //获取Thread里面的ThreadLocal.ThreadLocalMap对象 ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else //创建ThreadLocal.ThreadLocalMap对象 createMap(t, value); &#125; /** * Get the map associated with a ThreadLocal. Overridden in * InheritableThreadLocal. * * @param t the current thread * @return the map */ ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals; &#125; /* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ //Thread对象中 ThreadLocal.ThreadLocalMap threadLocals = null; createMap函数:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * Create the map associated with a ThreadLocal. Overridden in * InheritableThreadLocal. * * @param t the current thread * @param firstValue value for the initial entry of the map */ void createMap(Thread t, T firstValue) &#123; //给当前线程的threadLocals赋值 t.threadLocals = new ThreadLocalMap(this, firstValue); &#125;ThreadLocalMap： /** * The table, resized as necessary. * table.length MUST always be a power of two. */ private Entry[] table; /** * The initial capacity -- MUST be a power of two. */ private static final int INITIAL_CAPACITY = 16; /** * The number of entries in the table. */ private int size = 0; /** * Construct a new map initially containing (firstKey, firstValue). * ThreadLocalMaps are constructed lazily, so we only create * one when we have at least one entry to put in it. */ ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; //创建Entry对象 初始化容积 16 table = new Entry[INITIAL_CAPACITY]; //根据ThreadLocal的hash值找到对应的位置 int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); //设置对应的object //点进Entry可以看到，其实Entry是将ThradLocal包装成弱引用的一个扩充 table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY); &#125; /** * The entries in this hash map extend WeakReference, using * its main ref field as the key (which is always a * ThreadLocal object). Note that null keys (i.e. entry.get() * == null) mean that the key is no longer referenced, so the * entry can be expunged from table. Such entries are referred to * as "stale entries" in the code that follows. */ static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; &#125; ThreadLocal的set函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207/** * Set the value associated with key. * * @param key the thread local object * @param value the value to be set */ private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; // We don't use a fast path as with get() because it is at // least as common to use set() to create new entries as // it is to replace existing ones, in which case, a fast // path would fail more often than not. Entry[] tab = table; int len = tab.length; //根据当前ThreadLocal得到对应的位置 int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); //如果当前的对象已经在当前线程存储过 那么替换 if (k == key) &#123; e.value = value; return; &#125; //表示对象被回收 if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; //如果当前的对象没有在当前线程存储过，那么将进行Entry初始化、赋值和存储 tab[i] = new Entry(key, value); int sz = ++size; //回收旧的对象 //如果阈值threshold超过2/3的值就回收并且cleanSomeSlots返回false if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash(); &#125; /** * Replace a stale entry encountered during a set operation * with an entry for the specified key. The value passed in * the value parameter is stored in the entry, whether or not * an entry already exists for the specified key. * * As a side effect, this method expunges all stale entries in the * "run" containing the stale entry. (A run is a sequence of entries * between two null slots.) * * @param key the key * @param value the value to be associated with key * @param staleSlot index of the first stale entry encountered while * searching for key. */ private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value, int staleSlot) &#123; Entry[] tab = table; int len = tab.length; Entry e; // Back up to check for prior stale entry in current run. // We clean out whole runs at a time to avoid continual // incremental rehashing due to garbage collector freeing // up refs in bunches (i.e., whenever the collector runs). int slotToExpunge = staleSlot; for (int i = prevIndex(staleSlot, len); (e = tab[i]) != null; i = prevIndex(i, len)) if (e.get() == null) slotToExpunge = i; // Find either the key or trailing null slot of run, whichever // occurs first for (int i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); // If we find key, then we need to swap it // with the stale entry to maintain hash table order. // The newly stale slot, or any other stale slot // encountered above it, can then be sent to expungeStaleEntry // to remove or rehash all of the other entries in run. if (k == key) &#123; e.value = value; tab[i] = tab[staleSlot]; tab[staleSlot] = e; // Start expunge at preceding stale entry if it exists if (slotToExpunge == staleSlot) slotToExpunge = i; cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); return; &#125; // If we didn't find stale entry on backward scan, the // first stale entry seen while scanning for key is the // first still present in the run. if (k == null &amp;&amp; slotToExpunge == staleSlot) slotToExpunge = i; &#125; // If key not found, put new entry in stale slot tab[staleSlot].value = null; tab[staleSlot] = new Entry(key, value); // If there are any other stale entries in run, expunge them if (slotToExpunge != staleSlot) cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); &#125; /** * Heuristically scan some cells looking for stale entries. * This is invoked when either a new element is added, or * another stale one has been expunged. It performs a * logarithmic number of scans, as a balance between no * scanning (fast but retains garbage) and a number of scans * proportional to number of elements, that would find all * garbage but would cause some insertions to take O(n) time. * * @param i a position known NOT to hold a stale entry. The * scan starts at the element after i. * * @param n scan control: &#123;@code log2(n)&#125; cells are scanned, * unless a stale entry is found, in which case * &#123;@code log2(table.length)-1&#125; additional cells are scanned. * When called from insertions, this parameter is the number * of elements, but when from replaceStaleEntry, it is the * table length. (Note: all this could be changed to be either * more or less aggressive by weighting n instead of just * using straight log n. But this version is simple, fast, and * seems to work well.) * * @return true if any stale entries have been removed. */ private boolean cleanSomeSlots(int i, int n) &#123; boolean removed = false; Entry[] tab = table; int len = tab.length; do &#123; i = nextIndex(i, len); Entry e = tab[i]; if (e != null &amp;&amp; e.get() == null) &#123; n = len; removed = true; i = expungeStaleEntry(i); &#125; &#125; while ( (n &gt;&gt;&gt;= 1) != 0); return removed; &#125; /** * Expunge a stale entry by rehashing any possibly colliding entries * lying between staleSlot and the next null slot. This also expunges * any other stale entries encountered before the trailing null. See * Knuth, Section 6.4 * * @param staleSlot index of slot known to have null key * @return the index of the next null slot after staleSlot * (all between staleSlot and this slot will have been checked * for expunging). */ private int expungeStaleEntry(int staleSlot) &#123; Entry[] tab = table; int len = tab.length; // expunge entry at staleSlot tab[staleSlot].value = null; tab[staleSlot] = null; size--; // Rehash until we encounter null Entry e; int i; for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == null) &#123; e.value = null; tab[i] = null; size--; &#125; else &#123; int h = k.threadLocalHashCode &amp; (len - 1); if (h != i) &#123; tab[i] = null; // Unlike Knuth 6.4 Algorithm R, we must scan until // null because multiple entries could have been stale. while (tab[h] != null) h = nextIndex(h, len); tab[h] = e; &#125; &#125; &#125; return i; &#125; 总结: 一个线程存在一个ThreadLocal.ThreadLocalMap对象,存储的对象被封装成一个ThreadLocal作为key的弱引用扩展对象Entry,是ThreadLocal.ThreadLocalMap的内部类,然后ThreadLocal.ThreadLocalMap里面有一个Entry数组管理着这些存储的对象。 线程死亡时，线程局部变量会自动回收内存； 当线程拥有的局部变量超过了容量的2/3(没有扩大容量时是10个)，会涉及到ThreadLocalMap中Entry的回收； 参考链接：ThreadLocal 源码剖析]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OkHttp系统拦截器]]></title>
    <url>%2FOkHttp%E7%B3%BB%E7%BB%9F%E6%8B%A6%E6%88%AA%E5%99%A8.html</url>
    <content type="text"><![CDATA[1234567891011121314151617Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123; interceptors.addAll(client.networkInterceptors()); &#125; interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain( interceptors, null, null, null, 0, originalRequest); return chain.proceed(originalRequest); &#125; RetryAndFollowUpInterceptor 处理重试的一个拦截器，会去处理一些异常，只要不是致命的异常就会重新发起一次请求（把Request给下级），如果是致命的异常就会抛给上一级；会处理一些重定向等等，比如 3XX 307、407 就会从头部中获取新的路径，生成一个新的请求交给下一级（重新发起一次请求） BridgeInterceptor 做一个简单的处理，设置一些通用的请求头，Content-Type Connection Content-Length Cookie做一些返回的处理，如果返回的数据被压缩了采用 ZipSource , 保存 Cookie CacheInterceptor 在缓存可用的情况下，读取本地的缓存的数据，如果没有直接去服务器，如果有首先判断有没有缓存策略，然后判断有没有过期，如果没有过期直接拿缓存，如果过期了需要添加一些之前头部信息如：If-Modified-Since ，这个时候后台有可能会给你返回 304 代表你还是可以拿本地缓存，每次读取到新的响应后做一次缓存。 ConnectInterceptor findHealthyConnection() 找一个连接，首先判断有没有健康的，没有就创建（建立Scoket,握手连接），连接缓存得到一条结论：OkHttp 是基于原生的 Socket + okio（原生IO的封装） 封装 HttpCodec 里面封装了 okio 的 Source（输入） 和 Sink (输出)，我们通过 HttpCodec 就可以操作 Socket的输入输出，我们就可以像服务器写数据和读取返回数据 CallServerInterceptor 写数据和读取数据,写头部信息，写body表单信息等等 连接三个核心类（连接复用）RealConnection、ConnectionPool、StreamAllocation RealConnection: 建立连接的一个对象的封装 ConnectionPool：保存了连接 StreamAllocation: 找一些连接，做一下封装]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>源码</tag>
        <tag>okhttp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android EventBus3.0源码分析]]></title>
    <url>%2FAndroid%20EventBus3.0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</url>
    <content type="text"><![CDATA[在我们开发过程中，相信应该有很多人使用过EventBus 3.0，这个确实方便了我们，少些了很多代码，这是个优秀的库，我们接下来进行对他剖析。我们使用EventBus 3.0的过程：123EventBus.getDefault().register()EventBus.getDefault().post()EventBus.getDefault().unregister() 我们先看看是怎么初始化的1234567891011121314151617181920212223242526272829303132333435363738/** Convenience singleton for apps using a process-wide EventBus instance. */ public static EventBus getDefault() &#123; if (defaultInstance == null) &#123; synchronized (EventBus.class) &#123; if (defaultInstance == null) &#123; defaultInstance = new EventBus(); &#125; &#125; &#125; return defaultInstance; &#125;/** * Creates a new EventBus instance; each instance is a separate scope in which events are delivered. To use a * central bus, consider &#123;@link #getDefault()&#125;. */ public EventBus() &#123; this(DEFAULT_BUILDER); &#125; EventBus(EventBusBuilder builder) &#123; subscriptionsByEventType = new HashMap&lt;&gt;(); typesBySubscriber = new HashMap&lt;&gt;(); stickyEvents = new ConcurrentHashMap&lt;&gt;(); mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10); backgroundPoster = new BackgroundPoster(this); asyncPoster = new AsyncPoster(this); indexCount = builder.subscriberInfoIndexes != null ? builder.subscriberInfoIndexes.size() : 0; subscriberMethodFinder = new SubscriberMethodFinder(builder.subscriberInfoIndexes, builder.strictMethodVerification, builder.ignoreGeneratedIndex); logSubscriberExceptions = builder.logSubscriberExceptions; logNoSubscriberMessages = builder.logNoSubscriberMessages; sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent; sendNoSubscriberEvent = builder.sendNoSubscriberEvent; throwSubscriberException = builder.throwSubscriberException; eventInheritance = builder.eventInheritance; executorService = builder.executorService; &#125; 一个单例模式,接着点你会发现其实是利用的Builder模式，而框架内部帮我们写了一个EventBusBuilder12345private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder(); EventBusBuilder() &#123; &#125; 在EventBusBuilder初始化的时候除了对成员变量的一些初始化外，其他的并没有做什么操作。接下来我们进入register函数12345678910111213141516171819/** * Registers the given subscriber to receive events. Subscribers must call &#123;@link #unregister(Object)&#125; once they * are no longer interested in receiving events. * &lt;p/&gt; * Subscribers have event handling methods that must be annotated by &#123;@link Subscribe&#125;. * The &#123;@link Subscribe&#125; annotation also allows configuration like &#123;@link * ThreadMode&#125; and priority. */ public void register(Object subscriber) &#123; Class&lt;?&gt; subscriberClass = subscriber.getClass(); //根据subscriberClass 获取订阅的方法 List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); synchronized (this) &#123; //遍历订阅 for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; subscribe(subscriber, subscriberMethod); &#125; &#125; &#125; 从这个函数我们可以很清晰的看到逻辑，首先根据subscriber(Activity,Fragment)得到相应的订阅方法，然后在遍历订阅。这里代码就不点进去看了，主要说下框架的实现思路。 采用了缓存加反射的方式，主要的参数和类为下：METHOD_CACHE:一个key为订阅者class，value为需要订阅实现的方法的一个ConcurrentHashMap，这个HashMap是为了保证线程并发安全。我们获取的订阅方法就会缓存到这里面。FindState：顾名思义，这是一个检测状态的类，里面的参数为123456789final List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;(); final Map&lt;Class, Object&gt; anyMethodByEventType = new HashMap&lt;&gt;(); final Map&lt;String, Class&gt; subscriberClassByMethodKey = new HashMap&lt;&gt;(); final StringBuilder methodKeyBuilder = new StringBuilder(128); Class&lt;?&gt; subscriberClass; Class&lt;?&gt; clazz; boolean skipSuperClasses; SubscriberInfo subscriberInfo; 里面比较重要的几个参数：SubscriberMethod: 当前订阅对象(Activity,Fragment)的订阅方法实体。1234567891011public class SubscriberMethod &#123; //方法 final Method method;//模式 final ThreadMode threadMode;//类型， 就是参数的类型 参数只能为1个 final Class&lt;?&gt; eventType; final int priority; final boolean sticky; /** Used for efficient comparison */ String methodString; subscriberMethods:用来存储当前订阅对象(Activity,Fragment)内的订阅方法SubscriberMethod。anyMethodByEventType: key为参数类型（订阅类型）,value为方法的一个缓存。subscriberClassByMethodKey:key为 订阅方法名+&quot;&gt;&quot;+参数类型name,value为订阅方法的class。 获取订阅方法的时候先判断缓存里面是否存在，不存在就获取FindState实例，根据反射获取注解Subscribe(Activity,Fragment)的方法，然后对FindState实例进行操作（anyMethodByEventType和subscriberClassByMethodKey得到相应的值或添加到缓存），获取到的订阅方法集合其实就是FindState实例里面的subscriberMethods,最后在把获取的订阅方法集合加入缓存。得到了订阅方法集合接下来就遍历subscriberMethods：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber; private final Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents; // Must be called in synchronized block private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123; Class&lt;?&gt; eventType = subscriberMethod.eventType; Subscription newSubscription = new Subscription(subscriber, subscriberMethod); CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); if (subscriptions == null) &#123; subscriptions = new CopyOnWriteArrayList&lt;&gt;(); subscriptionsByEventType.put(eventType, subscriptions); &#125; else &#123; if (subscriptions.contains(newSubscription)) &#123; throw new EventBusException("Subscriber " + subscriber.getClass() + " already registered to event " + eventType); &#125; &#125; int size = subscriptions.size(); for (int i = 0; i &lt;= size; i++) &#123; if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123; subscriptions.add(i, newSubscription); break; &#125; &#125; List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber); if (subscribedEvents == null) &#123; subscribedEvents = new ArrayList&lt;&gt;(); typesBySubscriber.put(subscriber, subscribedEvents); &#125; subscribedEvents.add(eventType); if (subscriberMethod.sticky) &#123; if (eventInheritance) &#123; // Existing sticky events of all subclasses of eventType have to be considered. // Note: Iterating over all events may be inefficient with lots of sticky events, // thus data structure should be changed to allow a more efficient lookup // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;). Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet(); for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123; Class&lt;?&gt; candidateEventType = entry.getKey(); if (eventType.isAssignableFrom(candidateEventType)) &#123; Object stickyEvent = entry.getValue(); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; &#125; else &#123; Object stickyEvent = stickyEvents.get(eventType); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; &#125; 订阅的时候，首先根据订阅者(Activity Fragment)和SubscriberMethod得到一个Subscription对象，这个类就是一个真正执行信息传递的订阅对象。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* * Copyright (C) 2012-2016 Markus Junginger, greenrobot (http://greenrobot.org) * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.greenrobot.eventbus;final class Subscription &#123; final Object subscriber; final SubscriberMethod subscriberMethod; /** * Becomes false as soon as &#123;@link EventBus#unregister(Object)&#125; is called, which is checked by queued event delivery * &#123;@link EventBus#invokeSubscriber(PendingPost)&#125; to prevent race conditions. */ volatile boolean active; Subscription(Object subscriber, SubscriberMethod subscriberMethod) &#123; this.subscriber = subscriber; this.subscriberMethod = subscriberMethod; active = true; &#125; @Override public boolean equals(Object other) &#123; if (other instanceof Subscription) &#123; Subscription otherSubscription = (Subscription) other; return subscriber == otherSubscription.subscriber &amp;&amp; subscriberMethod.equals(otherSubscription.subscriberMethod); &#125; else &#123; return false; &#125; &#125; @Override public int hashCode() &#123; return subscriber.hashCode() + subscriberMethod.methodString.hashCode(); &#125;&#125; 接着把这个Subscription对象添加CopyOnWriteArrayList（CopyOnWriteArrayList是一个适合用在读多，写少的并发应用中，它是一个线程安全的集合）然后将这个CopyOnWriteArrayList添加到subscriptionsByEventType里面，这个subscriptionsByEventType是一个key为订阅方法的类型(方法函数的类型)，value为一个存放Subscription的CopyOnWriteArrayList的HashMap。接下来把订阅方法的类型（参数类型）eventType添加到一个ArrayList里面，在将这个ArrayList添加到typesBySubscriber，typesBySubscriber是一个key为订阅者对象（Fragment，Activity），value为ArrayList&lt;Class&lt;?&gt;&gt;的HashMap，最后在判断是否是sticky,如果是的就将遍历一个stickyEvents的HashMap，然后根据key（订阅方法类型）发出消息。 我们看看unregister1234567891011121314151617181920212223242526272829/** Unregisters the given subscriber from all event classes. */ public synchronized void unregister(Object subscriber) &#123; List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber); if (subscribedTypes != null) &#123; for (Class&lt;?&gt; eventType : subscribedTypes) &#123; unsubscribeByEventType(subscriber, eventType); &#125; typesBySubscriber.remove(subscriber); &#125; else &#123; Log.w(TAG, "Subscriber to unregister was not registered before: " + subscriber.getClass()); &#125; &#125;/** Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber. */ private void unsubscribeByEventType(Object subscriber, Class&lt;?&gt; eventType) &#123; List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); if (subscriptions != null) &#123; int size = subscriptions.size(); for (int i = 0; i &lt; size; i++) &#123; Subscription subscription = subscriptions.get(i); if (subscription.subscriber == subscriber) &#123; subscription.active = false; subscriptions.remove(i); i--; size--; &#125; &#125; &#125; &#125; 很简单，先根据订阅者(Activity Fragment)获取到typesBySubscriber里面的订阅方法类型集合(List&lt;Class&lt;?&gt;&gt; subscribedTypes),然后遍历这个集合，根据这个订阅方法类型得到subscriptionsByEventType里面的订阅对象集合List&lt;Subscription&gt; subscriptions,在遍历这个subscriptions集合，判断subscription.subscriber == subscriber然后移除，最后在移除typesBySubscriber里面的这个订阅对象(Fragment ,Activity )。 接下来我们看看post，最终会走到这个函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123; switch (subscription.subscriberMethod.threadMode) &#123; case POSTING: invokeSubscriber(subscription, event); break; case MAIN: if (isMainThread) &#123; invokeSubscriber(subscription, event); &#125; else &#123; mainThreadPoster.enqueue(subscription, event); &#125; break; case BACKGROUND: if (isMainThread) &#123; backgroundPoster.enqueue(subscription, event); &#125; else &#123; invokeSubscriber(subscription, event); &#125; break; case ASYNC: asyncPoster.enqueue(subscription, event); break; default: throw new IllegalStateException("Unknown thread mode: " + subscription.subscriberMethod.threadMode); &#125; &#125;/** * Invokes the subscriber if the subscriptions is still active. Skipping subscriptions prevents race conditions * between &#123;@link #unregister(Object)&#125; and event delivery. Otherwise the event might be delivered after the * subscriber unregistered. This is particularly important for main thread delivery and registrations bound to the * live cycle of an Activity or Fragment. */ void invokeSubscriber(PendingPost pendingPost) &#123; Object event = pendingPost.event; Subscription subscription = pendingPost.subscription; PendingPost.releasePendingPost(pendingPost); if (subscription.active) &#123; invokeSubscriber(subscription, event); &#125; &#125; void invokeSubscriber(Subscription subscription, Object event) &#123; try &#123; subscription.subscriberMethod.method.invoke(subscription.subscriber, event); &#125; catch (InvocationTargetException e) &#123; handleSubscriberException(subscription, event, e.getCause()); &#125; catch (IllegalAccessException e) &#123; throw new IllegalStateException("Unexpected exception", e); &#125; &#125; 在发送消息的时候根据消息类型(参数类型)然后从上面的subscriptionsByEventType里面取出相应的数据进行封装成一个PendingPost对象，在根据反射invoke对应的方法即可，如果是MAIN的话就通过Handler进行线程转换，如果是BACKGROUND并且是在主线程中调用或者是ASYNC将会通过线程池来进行线程切换。 接下来看看postSticky：1234567891011/** * Posts the given event to the event bus and holds on to the event (because it is sticky). The most recent sticky * event of an event's type is kept in memory for future access by subscribers using &#123;@link Subscribe#sticky()&#125;. */ public void postSticky(Object event) &#123; synchronized (stickyEvents) &#123; stickyEvents.put(event.getClass(), event); &#125; // Should be posted after it is putted, in case the subscriber wants to remove immediately post(event); &#125; 这个其实我们在注册的时候已经分析了，当调用这个函数的时候，将会将这个消息加到stickyEvents里面，这个stickyEvents是一个ConcurrentHashMap,ConcurrentHashMap是一个应用于高并发的键值对，接着调用post函数先把已经注册的观察者的方法实现，接下来其他对象注册的时候12345678910111213141516171819if (subscriberMethod.sticky) &#123; if (eventInheritance) &#123; // Existing sticky events of all subclasses of eventType have to be considered. // Note: Iterating over all events may be inefficient with lots of sticky events, // thus data structure should be changed to allow a more efficient lookup // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;). Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet(); for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123; Class&lt;?&gt; candidateEventType = entry.getKey(); if (eventType.isAssignableFrom(candidateEventType)) &#123; Object stickyEvent = entry.getValue(); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; &#125; else &#123; Object stickyEvent = stickyEvents.get(eventType); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; 在这里将会调用。还有一个优先级priority问题，可以看到也是在注册的时候1234567int size = subscriptions.size(); for (int i = 0; i &lt;= size; i++) &#123; if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123; subscriptions.add(i, newSubscription); break; &#125; &#125; 其实也是很简单的原理。源码分析得也差不多了，具体的需要大家自己去查看源码。 总结，EventBus的实现方式：反射 + 数据封装 + 缓存 + 线程切换通过查看EventBus的源码收获了什么？ 1. Builder模式封装参数 2. 根据用处不同进行对不同的类封装，比如:`SubscriberMethodFinder`用于订阅方法的查找;`FindState`一个用`SubscriberMethodFinder`查找的辅助类，里面封装了一些数据;`SubscriberMethod`订阅方法实体，就是通过注解的方法对应的对象；`Subscription`一个订阅对象。 3. 缓存 4. 线程切换使用方式 5. 反射用法熟悉加强 6. `ThreadLocal`是一个关于创建线程局部变量的类。 通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。而使用`ThreadLocal`创建的变量只能被当前线程访问，其他线程则无法访问和修改。 7. `CopyOnWriteArrayList`:是一个适合用在读多，写少的并发应用中，它是一个线程安全的集合 8. `ConcurrentHashMap`:是一个应用于高并发的键值对]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android ClassLoader流程解读并简单方式实现热更新]]></title>
    <url>%2FAndroid%20ClassLoader%E6%B5%81%E7%A8%8B%E8%A7%A3%E8%AF%BB%E5%B9%B6%E7%AE%80%E5%8D%95%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E7%83%AD%E6%9B%B4%E6%96%B0.html</url>
    <content type="text"><![CDATA[ClassLoader在启动Activity的时候会调用loadClass方法，我们就从这里入手: 123456public Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; return (Activity)cl.loadClass(className).newInstance(); &#125; 然后我们点击进入进入了ClassLoader的loadClass方法：1234567891011121314151617181920212223242526272829protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; // First, check if the class has already been loaded Class c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats &#125; &#125; return c; &#125; 看到源码是调用了findClass方法：123protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; throw new ClassNotFoundException(name); &#125; 发现这个是抛出了一个异常，就没办法继续阅读了。这个时候发现ClassLoader是一个抽象类，应该是子类重写了这个方法,然后通过启动StartActivity的源码可以得到:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public ClassLoader getClassLoader(String zip, int targetSdkVersion, boolean isBundled, String librarySearchPath, String libraryPermittedPath, ClassLoader parent) &#123; /* * This is the parent we use if they pass "null" in. In theory * this should be the "system" class loader; in practice we * don't use that and can happily (and more efficiently) use the * bootstrap class loader. */ ClassLoader baseParent = ClassLoader.getSystemClassLoader().getParent(); synchronized (mLoaders) &#123; if (parent == null) &#123; parent = baseParent; &#125; /* * If we're one step up from the base class loader, find * something in our cache. Otherwise, we create a whole * new ClassLoader for the zip archive. */ if (parent == baseParent) &#123; ClassLoader loader = mLoaders.get(zip); if (loader != null) &#123; return loader; &#125; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, zip); PathClassLoader pathClassloader = PathClassLoaderFactory.createClassLoader( zip, librarySearchPath, libraryPermittedPath, parent, targetSdkVersion, isBundled); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "setupVulkanLayerPath"); setupVulkanLayerPath(pathClassloader, librarySearchPath); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); mLoaders.put(zip, pathClassloader); return pathClassloader; &#125; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, zip); PathClassLoader pathClassloader = new PathClassLoader(zip, parent); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); return pathClassloader; &#125; &#125; 得知这个ClassLoader是PathClassLoader,点进去查看1234567891011public class PathClassLoader extends BaseDexClassLoader &#123; public PathClassLoader(String dexPath, ClassLoader parent) &#123; super((String)null, (File)null, (String)null, (ClassLoader)null); throw new RuntimeException("Stub!"); &#125; public PathClassLoader(String dexPath, String librarySearchPath, ClassLoader parent) &#123; super((String)null, (File)null, (String)null, (ClassLoader)null); throw new RuntimeException("Stub!"); &#125;&#125; 发现其实是BaseDexClassLoader里面的findClass()生效了，我们通过http://androidxref.com/ 查看源码：12345678910111213141516171819202122232425262728293031323334353637383940private final DexPathList pathList; /** * Constructs an instance. * * @param dexPath the list of jar/apk files containing classes and * resources, delimited by &#123;@code File.pathSeparator&#125;, which * defaults to &#123;@code ":"&#125; on Android * @param optimizedDirectory directory where optimized dex files * should be written; may be &#123;@code null&#125; * @param libraryPath the list of directories containing native * libraries, delimited by &#123;@code File.pathSeparator&#125;; may be * &#123;@code null&#125; * @param parent the parent class loader */ public BaseDexClassLoader(String dexPath, File optimizedDirectory, String libraryPath, ClassLoader parent) &#123; super(parent); this.pathList = new DexPathList(this, dexPath, libraryPath, optimizedDirectory); &#125; @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; List&lt;Throwable&gt; suppressedExceptions = new ArrayList&lt;Throwable&gt;(); Class c = pathList.findClass(name, suppressedExceptions); if (c == null) &#123; ClassNotFoundException cnfe = new ClassNotFoundException("Didn't find class \"" + name + "\" on path: " + pathList); for (Throwable t : suppressedExceptions) &#123; cnfe.addSuppressed(t); &#125; throw cnfe; &#125; return c; &#125; 其实就是DexPathList pathList这个字段得到Class&lt;?&gt;,我们继续查看DexPathList里面源码12345678910111213141516171819202122232425262728293031323334353637/** * List of dex/resource (class path) elements. * Should be called pathElements, but the Facebook app uses reflection * to modify 'dexElements' (http://b/7726934). */ private final Element[] dexElements; /** * * Finds the named class in one of the dex files pointed at by * * this instance. This will find the one in the earliest listed * * path element. If the class is found but has not yet been * * defined, then this method will define it in the defining * * context that this instance was constructed with. * * * * @param name of class to find * * @param suppressed exceptions encountered whilst finding the class * * @return the named class or &#123;@code null&#125; if the class is not * * found in any of the dex files * */ public Class findClass(String name, List&lt;Throwable&gt; suppressed) &#123; for (Element element : dexElements) &#123; DexFile dex = element.dexFile; if (dex != null) &#123; Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed); if (clazz != null) &#123; return clazz; &#125; &#125; &#125; if (dexElementsSuppressedExceptions != null) &#123; suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions)); &#125; return null; &#125; 可以发现其实是一个dex的Element[]数组,通过for循环得到相应的值，所以我们就可以把改变的class打成dex格式的文件，通过反射把这个dex文件里面的Element[] dexElements值插入到原APP的Element[] dexElements前就可以了。下面是具体代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171package com.zzw.baselibray.fixBug;import android.content.Context;import android.util.Log;import com.zzw.baselibray.util.FileUtil;import java.io.File;import java.io.FileNotFoundException;import java.lang.reflect.Array;import java.lang.reflect.Field;import java.util.ArrayList;import java.util.List;import dalvik.system.BaseDexClassLoader;/** * Created by zzw on 2017/5/5. * 热修复管理 */public class FixBugManager &#123; private static final String TAG = "FixBugManager"; private Context mContext; private File mDexDir;//应用可以访问的dex目录 public FixBugManager(Context context) &#123; this.mContext = context; //获取到应用可以访问的dex目录 this.mDexDir = context.getDir("odex", Context.MODE_PRIVATE); &#125; /** * 设置新的dexElements到applicationClassLoader里面 * * @param classLoader * @param dexElements */ private void setElementsToClassLoader(ClassLoader classLoader, Object dexElements) throws NoSuchFieldException, IllegalAccessException &#123; //1.先获取ClassLoader里面的pathList Field pathListFiled = BaseDexClassLoader.class.getDeclaredField("pathList"); pathListFiled.setAccessible(true); Object pathList = pathListFiled.get(classLoader); //2.获取pathList里面的dexElements字段并设置新的值 Field dexElementsField = pathList.getClass().getField("dexElements"); dexElementsField.setAccessible(true); dexElementsField.set(pathList, dexElements); &#125; /** * 从ClassLoader里面获取dexElements * * @param applicationClassLoader * @return */ private Object getElementsByClassLoader(ClassLoader applicationClassLoader) throws NoSuchFieldException, IllegalAccessException &#123; //1.先获取ClassLoader里面的pathList Field pathListFiled = BaseDexClassLoader.class.getDeclaredField("pathList"); pathListFiled.setAccessible(true); Object pathList = pathListFiled.get(applicationClassLoader); //2.获取pathList里面的dexElements Field dexElementsField = pathList.getClass().getField("dexElements"); dexElementsField.setAccessible(true); Object dexElements = dexElementsField.get(pathList); return dexElements; &#125; /** * 合并两个dexElements数组 * * @param arrayLhs * @param arrayRhs * @return */ private static Object combineArray(Object arrayLhs, Object arrayRhs) &#123; Class&lt;?&gt; localClass = arrayLhs.getClass().getComponentType(); int i = Array.getLength(arrayLhs); int j = i + Array.getLength(arrayRhs); Object result = Array.newInstance(localClass, j); for (int k = 0; k &lt; j; ++k) &#123; if (k &lt; i) &#123; Array.set(result, k, Array.get(arrayLhs, k)); &#125; else &#123; Array.set(result, k, Array.get(arrayRhs, k - i)); &#125; &#125; return result; &#125; /** * 加载所有的修复包 */ public void loadFixDex() throws Exception &#123; File[] files = mDexDir.listFiles(); List&lt;File&gt; fixDexFiles = new ArrayList&lt;&gt;(); for (File dexFile : files) &#123; if (dexFile.getName().endsWith(".dex")) &#123; fixDexFiles.add(dexFile); &#125; &#125; fixDexFiles(fixDexFiles); &#125; /** * 修复dex包 * * @param fixDexPath dexDex修复路径 */ public void fixDex(String fixDexPath) throws Exception &#123; File srcFile = new File(fixDexPath); if (!srcFile.exists()) &#123; throw new FileNotFoundException(fixDexPath); &#125; File destFile = new File(mDexDir, srcFile.getName()); if (destFile.exists()) &#123; Log.d(TAG, "patch [" + fixDexPath + "] has be loaded."); return; &#125; FileUtil.copyFile(srcFile, destFile);// copy to patch's directory// FileUtil.deleteFile(srcFile);//copy完成后删除 //2.2 ClassLoader读取fixDex路径 为什么加入到集合?--&gt;可能已启动就可能要修复 List&lt;File&gt; fixDexFiles = new ArrayList&lt;&gt;(); fixDexFiles.add(destFile); fixDexFiles(fixDexFiles); &#125; /** * 修复dex 已经修复过的dex文件全部copy在mContext里面，application初始化的时候将这些多个dex文件一起修复 * * @param fixDexFiles */ private void fixDexFiles(List&lt;File&gt; fixDexFiles) throws Exception &#123; //1.先获取applicationClassLoader的pathList字段的dexElements值 ClassLoader applicationClassLoader = mContext.getClassLoader(); Object applicationDexElements = getElementsByClassLoader(applicationClassLoader); //2.获取下载好的补丁的dexElements //2.1 移动到系统能够访问的dex目录下 --&gt; ClassLoader File optimizedDirectory = new File(mDexDir, "oder"); if (!optimizedDirectory.exists()) optimizedDirectory.mkdirs(); //修复 for (File fixDexFile : fixDexFiles) &#123; //dexPath 加载的dex路径 //optimizedDirectory 解压路径 //librarySearchPath so文件位置 //parent 父ClassLoader ClassLoader fixClassLoader = new BaseDexClassLoader( fixDexFile.getAbsolutePath(), //dexPath 加载的dex路径 optimizedDirectory,// 解压文件 null, applicationClassLoader); Object fixDexElements = getElementsByClassLoader(fixClassLoader); //3.把补丁的dexElements插到已经已经运行的dexElements前面 //合并完成 fixDexElements插入dexElements之前 applicationDexElements = combineArray(fixDexElements, applicationDexElements); //把合并的数组注入到原来的applicationClassLoader类中 setElementsToClassLoader(applicationClassLoader, applicationDexElements); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/* * * Copyright (c) 2015, alipay.com * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.zzw.baselibray.util;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.nio.channels.FileChannel;/** * file utility * * @author sanping.li@alipay.com */public class FileUtil &#123; /** * copy file * * @param src source file * @param dest target file * @throws IOException */ public static void copyFile(File src, File dest) throws IOException &#123; FileChannel inChannel = null; FileChannel outChannel = null; try &#123; if (!dest.exists()) &#123; dest.createNewFile(); &#125; inChannel = new FileInputStream(src).getChannel(); outChannel = new FileOutputStream(dest).getChannel(); inChannel.transferTo(0, inChannel.size(), outChannel); &#125; finally &#123; if (inChannel != null) &#123; inChannel.close(); &#125; if (outChannel != null) &#123; outChannel.close(); &#125; &#125; &#125; /** * delete file * * @param file file * @return true if delete success */ public static boolean deleteFile(File file) &#123; if (!file.exists()) &#123; return true; &#125; if (file.isDirectory()) &#123; File[] files = file.listFiles(); for (File f : files) &#123; deleteFile(f); &#125; &#125; return file.delete(); &#125;&#125; 学习来源:红橙Darren]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android View绘制流程分析]]></title>
    <url>%2FAndroid%20invalidate%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.html</url>
    <content type="text"><![CDATA[我们刚接触android开发的时候，应该都是从写布局开始的，在写布局的时候一般组长都要求我们少嵌套，这个是为什么呢？这个就要从我们今天要分析的invalidate()分析。我们开始进入正题：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** * Invalidate the whole view. If the view is visible, * &#123;@link #onDraw(android.graphics.Canvas)&#125; will be called at some point in * the future. * &lt;p&gt; * This must be called from a UI thread. To call from a non-UI thread, call * &#123;@link #postInvalidate()&#125;. */public void invalidate() &#123; invalidate(true);&#125;/** * This is where the invalidate() work actually happens. A full invalidate() * causes the drawing cache to be invalidated, but this function can be * called with invalidateCache set to false to skip that invalidation step * for cases that do not need it (for example, a component that remains at * the same dimensions with the same content). * * @param invalidateCache Whether the drawing cache for this view should be * invalidated as well. This is usually true for a full * invalidate, but may be set to false if the View's contents or * dimensions have not changed. */void invalidate(boolean invalidateCache) &#123; invalidateInternal(0, 0, mRight - mLeft, mBottom - mTop, invalidateCache, true);&#125;void invalidateInternal(int l, int t, int r, int b, boolean invalidateCache, boolean fullInvalidate) &#123; if (mGhostView != null) &#123; mGhostView.invalidate(true); return; &#125; if (skipInvalidate()) &#123; return; &#125; if ((mPrivateFlags &amp; (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS) || (invalidateCache &amp;&amp; (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) || (mPrivateFlags &amp; PFLAG_INVALIDATED) != PFLAG_INVALIDATED || (fullInvalidate &amp;&amp; isOpaque() != mLastIsOpaque)) &#123; if (fullInvalidate) &#123; mLastIsOpaque = isOpaque(); mPrivateFlags &amp;= ~PFLAG_DRAWN; &#125; mPrivateFlags |= PFLAG_DIRTY; if (invalidateCache) &#123; mPrivateFlags |= PFLAG_INVALIDATED; mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID; &#125; // Propagate the damage rectangle to the parent view. final AttachInfo ai = mAttachInfo; final ViewParent p = mParent; if (p != null &amp;&amp; ai != null &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123; final Rect damage = ai.mTmpInvalRect; damage.set(l, t, r, b); p.invalidateChild(this, damage); &#125; // Damage the entire projection receiver, if necessary. if (mBackground != null &amp;&amp; mBackground.isProjected()) &#123; final View receiver = getProjectionReceiver(); if (receiver != null) &#123; receiver.damageInParent(); &#125; &#125; // Damage the entire IsolatedZVolume receiving this view's shadow. if (isHardwareAccelerated() &amp;&amp; getZ() != 0) &#123; damageShadowReceiver(); &#125; &#125;&#125; 可以看到我们最终会进入invalidateInternal这个函数可以看到这段代码:123456final ViewParent p = mParent;if (p != null &amp;&amp; ai != null &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123; final Rect damage = ai.mTmpInvalRect; damage.set(l, t, r, b); p.invalidateChild(this, damage);&#125; 很明显的就是进入了父布局的invalidateChild函数，我们就从ViewGroup里面看123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192/** * Don't call or override this method. It is used for the implementation of * the view hierarchy. */ @Override public final void invalidateChild(View child, final Rect dirty) &#123; ViewParent parent = this; //...... do &#123; View view = null; if (parent instanceof View) &#123; view = (View) parent; &#125; if (drawAnimation) &#123; if (view != null) &#123; view.mPrivateFlags |= PFLAG_DRAW_ANIMATION; &#125; else if (parent instanceof ViewRootImpl) &#123; ((ViewRootImpl) parent).mIsAnimating = true; &#125; &#125; // If the parent is dirty opaque or not dirty, mark it dirty with the opaque // flag coming from the child that initiated the invalidate if (view != null) &#123; if ((view.mViewFlags &amp; FADING_EDGE_MASK) != 0 &amp;&amp; view.getSolidColor() == 0) &#123; opaqueFlag = PFLAG_DIRTY; &#125; if ((view.mPrivateFlags &amp; PFLAG_DIRTY_MASK) != PFLAG_DIRTY) &#123; view.mPrivateFlags = (view.mPrivateFlags &amp; ~PFLAG_DIRTY_MASK) | opaqueFlag; &#125; &#125; parent = parent.invalidateChildInParent(location, dirty); if (view != null) &#123; // Account for transform on current parent Matrix m = view.getMatrix(); if (!m.isIdentity()) &#123; RectF boundingRect = attachInfo.mTmpTransformRect; boundingRect.set(dirty); m.mapRect(boundingRect); dirty.set((int) Math.floor(boundingRect.left), (int) Math.floor(boundingRect.top), (int) Math.ceil(boundingRect.right), (int) Math.ceil(boundingRect.bottom)); &#125; &#125; &#125; while (parent != null); //... ｝ /** * Don't call or override this method. It is used for the implementation of * the view hierarchy. * * This implementation returns null if this ViewGroup does not have a parent, * if this ViewGroup is already fully invalidated or if the dirty rectangle * does not intersect with this ViewGroup's bounds. */ @Override public ViewParent invalidateChildInParent(final int[] location, final Rect dirty) &#123; if ((mPrivateFlags &amp; PFLAG_DRAWN) == PFLAG_DRAWN || (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) &#123; if ((mGroupFlags &amp; (FLAG_OPTIMIZE_INVALIDATE | FLAG_ANIMATION_DONE)) != FLAG_OPTIMIZE_INVALIDATE) &#123; dirty.offset(location[CHILD_LEFT_INDEX] - mScrollX, location[CHILD_TOP_INDEX] - mScrollY); if ((mGroupFlags &amp; FLAG_CLIP_CHILDREN) == 0) &#123; dirty.union(0, 0, mRight - mLeft, mBottom - mTop); &#125; final int left = mLeft; final int top = mTop; if ((mGroupFlags &amp; FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) &#123; if (!dirty.intersect(0, 0, mRight - left, mBottom - top)) &#123; dirty.setEmpty(); &#125; &#125; mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID; location[CHILD_LEFT_INDEX] = left; location[CHILD_TOP_INDEX] = top; if (mLayerType != LAYER_TYPE_NONE) &#123; mPrivateFlags |= PFLAG_INVALIDATED; &#125; return mParent; &#125; else &#123; mPrivateFlags &amp;= ~PFLAG_DRAWN &amp; ~PFLAG_DRAWING_CACHE_VALID; location[CHILD_LEFT_INDEX] = mLeft; location[CHILD_TOP_INDEX] = mTop; if ((mGroupFlags &amp; FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) &#123; dirty.set(0, 0, mRight - mLeft, mBottom - mTop); &#125; else &#123; // in case the dirty rect extends outside the bounds of this container dirty.union(0, 0, mRight - mLeft, mBottom - mTop); &#125; if (mLayerType != LAYER_TYPE_NONE) &#123; mPrivateFlags |= PFLAG_INVALIDATED; &#125; return mParent; &#125; &#125; return null; &#125;``` 从这里我们可以看到，在这个函数里面，主要是对当前`viewgroup`在次验证是否还有父布局，使用`do while`循环得到`parent`，等到最上层没有`parent`的时候才执行下一步,从这就可以知道，如果嵌套太多层的话，就会在这消耗性能。这样的话我们就可以知道，肯定是调用到了最外层的`ViewGroup`,也就是`ViewRootImpl`，我们查看`ViewRootImpl`源码:```java @Override public ViewParent invalidateChildInParent(int[] location, Rect dirty) &#123; checkThread(); if (DEBUG_DRAW) Log.v(mTag, "Invalidate child: " + dirty); if (dirty == null) &#123; invalidate(); return null; &#125; else if (dirty.isEmpty() &amp;&amp; !mIsAnimating) &#123; return null; &#125; if (mCurScrollY != 0 || mTranslator != null) &#123; mTempRect.set(dirty); dirty = mTempRect; if (mCurScrollY != 0) &#123; dirty.offset(0, -mCurScrollY); &#125; if (mTranslator != null) &#123; mTranslator.translateRectInAppWindowToScreen(dirty); &#125; if (mAttachInfo.mScalingRequired) &#123; dirty.inset(-1, -1); &#125; &#125; invalidateRectOnScreen(dirty); return null; &#125; void checkThread() &#123; if (mThread != Thread.currentThread()) &#123; throw new CalledFromWrongThreadException( "Only the original thread that created a view hierarchy can touch its views."); &#125; &#125; private void invalidateRectOnScreen(Rect dirty) &#123; final Rect localDirty = mDirty; if (!localDirty.isEmpty() &amp;&amp; !localDirty.contains(dirty)) &#123; mAttachInfo.mSetIgnoreDirtyState = true; mAttachInfo.mIgnoreDirtyState = true; &#125; // Add the new dirty rect to the current one localDirty.union(dirty.left, dirty.top, dirty.right, dirty.bottom); // Intersect with the bounds of the window to skip // updates that lie outside of the visible region final float appScale = mAttachInfo.mApplicationScale; final boolean intersected = localDirty.intersect(0, 0, (int) (mWidth * appScale + 0.5f), (int) (mHeight * appScale + 0.5f)); if (!intersected) &#123; localDirty.setEmpty(); &#125; if (!mWillDrawSoon &amp;&amp; (intersected || mIsAnimating)) &#123; scheduleTraversals(); &#125; &#125; void scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; mTraversalScheduled = true; mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); if (!mUnbufferedInputDispatch) &#123; scheduleConsumeBatchedInput(); &#125; notifyRendererOfFramePending(); pokeDrawLockIfNeeded(); //..... 从这里我们就知道了，首先会检测线程，也就是为什么在子线程更新UI为什么会崩溃的原因，然后经过一系列的判断进入到scheduleTraversals函数，在这个函数中可以看到会调用mTraversalRunnable这个Runnable123456789101112131415161718192021222324252627final TraversalRunnable mTraversalRunnable = new TraversalRunnable(); final class TraversalRunnable implements Runnable &#123; @Override public void run() &#123; doTraversal(); &#125; &#125; void doTraversal() &#123; if (mTraversalScheduled) &#123; mTraversalScheduled = false; mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier); if (mProfile) &#123; Debug.startMethodTracing("ViewAncestor"); &#125; performTraversals(); if (mProfile) &#123; Debug.stopMethodTracing(); mProfile = false; &#125; &#125; &#125; 可以看到，实际上就是调用了performTraversals()函数,这个函数很长，我们主要看关键点:12345678910 private void performTraversals() &#123; //...... // Ask host how big it wants to be performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); //...... performLayout(lp, mWidth, mHeight); //..... performDraw(); //.....&#125; 可以看到，进入这里面了，会依次调用performMeasure performLayoutperformDraw三个函数，依次调用了view的绘制流程。 顾名思义，在performMeasure中主要会实现测量12345678private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, "measure"); try &#123; mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; &#125; mView就是ViewGroup，然后会调用ViewGroup的onMeasure函数，然后测量，就从最上层父布局一直到测量到最底层的view。performLayout主要负责子view摆放12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) &#123; mLayoutRequested = false; mScrollMayChange = true; mInLayout = true; final View host = mView; if (DEBUG_ORIENTATION || DEBUG_LAYOUT) &#123; Log.v(mTag, "Laying out " + host + " to (" + host.getMeasuredWidth() + ", " + host.getMeasuredHeight() + ")"); &#125; Trace.traceBegin(Trace.TRACE_TAG_VIEW, "layout"); try &#123; host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); mInLayout = false; int numViewsRequestingLayout = mLayoutRequesters.size(); if (numViewsRequestingLayout &gt; 0) &#123; // requestLayout() was called during layout. // If no layout-request flags are set on the requesting views, there is no problem. // If some requests are still pending, then we need to clear those flags and do // a full request/measure/layout pass to handle this situation. ArrayList&lt;View&gt; validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters, false); if (validLayoutRequesters != null) &#123; // Set this flag to indicate that any further requests are happening during // the second pass, which may result in posting those requests to the next // frame instead mHandlingLayoutInLayoutRequest = true; // Process fresh layout requests, then measure and layout int numValidRequests = validLayoutRequesters.size(); for (int i = 0; i &lt; numValidRequests; ++i) &#123; final View view = validLayoutRequesters.get(i); Log.w("View", "requestLayout() improperly called by " + view + " during layout: running second layout pass"); view.requestLayout(); &#125; measureHierarchy(host, lp, mView.getContext().getResources(), desiredWindowWidth, desiredWindowHeight); mInLayout = true; host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); mHandlingLayoutInLayoutRequest = false; // Check the valid requests again, this time without checking/clearing the // layout flags, since requests happening during the second pass get noop'd validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters, true); if (validLayoutRequesters != null) &#123; final ArrayList&lt;View&gt; finalRequesters = validLayoutRequesters; // Post second-pass requests to the next frame getRunQueue().post(new Runnable() &#123; @Override public void run() &#123; int numValidRequests = finalRequesters.size(); for (int i = 0; i &lt; numValidRequests; ++i) &#123; final View view = finalRequesters.get(i); Log.w("View", "requestLayout() improperly called by " + view + " during second layout pass: posting in next frame"); view.requestLayout(); &#125; &#125; &#125;); &#125; &#125; &#125; &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; mInLayout = false; &#125; 同样的道理，又是从最上层viewGroup到最底层的view。performDraw负责绘制,performDraw()会 调用draw,在调用drawSoftware123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/** * @return true if drawing was successful, false if an error occurred */ private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scalingRequired, Rect dirty) &#123; // Draw with software renderer. final Canvas canvas; try &#123; final int left = dirty.left; final int top = dirty.top; final int right = dirty.right; final int bottom = dirty.bottom; canvas = mSurface.lockCanvas(dirty); // The dirty rectangle can be modified by Surface.lockCanvas() //noinspection ConstantConditions if (left != dirty.left || top != dirty.top || right != dirty.right || bottom != dirty.bottom) &#123; attachInfo.mIgnoreDirtyState = true; &#125; // TODO: Do this in native canvas.setDensity(mDensity); &#125; catch (Surface.OutOfResourcesException e) &#123; handleOutOfResourcesException(e); return false; &#125; catch (IllegalArgumentException e) &#123; Log.e(mTag, "Could not lock surface", e); // Don't assume this is due to out of memory, it could be // something else, and if it is something else then we could // kill stuff (or ourself) for no reason. mLayoutRequested = true; // ask wm for a new surface next time. return false; &#125; try &#123; if (DEBUG_ORIENTATION || DEBUG_DRAW) &#123; Log.v(mTag, "Surface " + surface + " drawing to bitmap w=" + canvas.getWidth() + ", h=" + canvas.getHeight()); //canvas.drawARGB(255, 255, 0, 0); &#125; // If this bitmap's format includes an alpha channel, we // need to clear it before drawing so that the child will // properly re-composite its drawing on a transparent // background. This automatically respects the clip/dirty region // or // If we are applying an offset, we need to clear the area // where the offset doesn't appear to avoid having garbage // left in the blank areas. if (!canvas.isOpaque() || yoff != 0 || xoff != 0) &#123; canvas.drawColor(0, PorterDuff.Mode.CLEAR); &#125; dirty.setEmpty(); mIsAnimating = false; mView.mPrivateFlags |= View.PFLAG_DRAWN; if (DEBUG_DRAW) &#123; Context cxt = mView.getContext(); Log.i(mTag, "Drawing: package:" + cxt.getPackageName() + ", metrics=" + cxt.getResources().getDisplayMetrics() + ", compatibilityInfo=" + cxt.getResources().getCompatibilityInfo()); &#125; try &#123; canvas.translate(-xoff, -yoff); if (mTranslator != null) &#123; mTranslator.translateCanvas(canvas); &#125; canvas.setScreenDensity(scalingRequired ? mNoncompatDensity : 0); attachInfo.mSetIgnoreDirtyState = false; mView.draw(canvas); drawAccessibilityFocusedDrawableIfNeeded(canvas); &#125; finally &#123; if (!attachInfo.mSetIgnoreDirtyState) &#123; // Only clear the flag if it was not set during the mView.draw() call attachInfo.mIgnoreDirtyState = false; &#125; &#125; &#125; finally &#123; try &#123; surface.unlockCanvasAndPost(canvas); &#125; catch (IllegalArgumentException e) &#123; Log.e(mTag, "Could not unlock surface", e); mLayoutRequested = true; // ask wm for a new surface next time. //noinspection ReturnInsideFinallyBlock return false; &#125; if (LOCAL_LOGV) &#123; Log.v(mTag, "Surface " + surface + " unlockCanvasAndPost"); &#125; &#125; return true; &#125; 从mView.draw(canvas);可以看到，又是一样的从最上层ViewGroup一直调用最底层view，不断的从draw方法调用drawBackground-&gt;onDraw-&gt;dispatchDraw-&gt;onDrawForeground 。流程为下图: 从这更加验证了我们嵌套多层之后会消耗性能的真理。invalidate()就分析到这里了，有什么意见或者文中有什么错误的希望可以在下方评论。希望大家可以在看我的文章中可以学习到知识。]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android view绘制流程分析]]></title>
    <url>%2FAndroid%20View%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.html</url>
    <content type="text"><![CDATA[我们刚接触android开发的时候，应该都是从写布局开始的，在写布局的时候一般组长都要求我们少嵌套，这个是为什么呢？这个就要从我们今天要分析的invalidate()分析。我们开始进入正题：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** * Invalidate the whole view. If the view is visible, * &#123;@link #onDraw(android.graphics.Canvas)&#125; will be called at some point in * the future. * &lt;p&gt; * This must be called from a UI thread. To call from a non-UI thread, call * &#123;@link #postInvalidate()&#125;. */public void invalidate() &#123; invalidate(true);&#125;/** * This is where the invalidate() work actually happens. A full invalidate() * causes the drawing cache to be invalidated, but this function can be * called with invalidateCache set to false to skip that invalidation step * for cases that do not need it (for example, a component that remains at * the same dimensions with the same content). * * @param invalidateCache Whether the drawing cache for this view should be * invalidated as well. This is usually true for a full * invalidate, but may be set to false if the View's contents or * dimensions have not changed. */void invalidate(boolean invalidateCache) &#123; invalidateInternal(0, 0, mRight - mLeft, mBottom - mTop, invalidateCache, true);&#125;void invalidateInternal(int l, int t, int r, int b, boolean invalidateCache, boolean fullInvalidate) &#123; if (mGhostView != null) &#123; mGhostView.invalidate(true); return; &#125; if (skipInvalidate()) &#123; return; &#125; if ((mPrivateFlags &amp; (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS) || (invalidateCache &amp;&amp; (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) || (mPrivateFlags &amp; PFLAG_INVALIDATED) != PFLAG_INVALIDATED || (fullInvalidate &amp;&amp; isOpaque() != mLastIsOpaque)) &#123; if (fullInvalidate) &#123; mLastIsOpaque = isOpaque(); mPrivateFlags &amp;= ~PFLAG_DRAWN; &#125; mPrivateFlags |= PFLAG_DIRTY; if (invalidateCache) &#123; mPrivateFlags |= PFLAG_INVALIDATED; mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID; &#125; // Propagate the damage rectangle to the parent view. final AttachInfo ai = mAttachInfo; final ViewParent p = mParent; if (p != null &amp;&amp; ai != null &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123; final Rect damage = ai.mTmpInvalRect; damage.set(l, t, r, b); p.invalidateChild(this, damage); &#125; // Damage the entire projection receiver, if necessary. if (mBackground != null &amp;&amp; mBackground.isProjected()) &#123; final View receiver = getProjectionReceiver(); if (receiver != null) &#123; receiver.damageInParent(); &#125; &#125; // Damage the entire IsolatedZVolume receiving this view's shadow. if (isHardwareAccelerated() &amp;&amp; getZ() != 0) &#123; damageShadowReceiver(); &#125; &#125;&#125; 可以看到我们最终会进入invalidateInternal这个函数可以看到这段代码:123456final ViewParent p = mParent;if (p != null &amp;&amp; ai != null &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123; final Rect damage = ai.mTmpInvalRect; damage.set(l, t, r, b); p.invalidateChild(this, damage);&#125; 很明显的就是进入了父布局的invalidateChild函数，我们就从ViewGroup里面看123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192/** * Don't call or override this method. It is used for the implementation of * the view hierarchy. */ @Override public final void invalidateChild(View child, final Rect dirty) &#123; ViewParent parent = this; //...... do &#123; View view = null; if (parent instanceof View) &#123; view = (View) parent; &#125; if (drawAnimation) &#123; if (view != null) &#123; view.mPrivateFlags |= PFLAG_DRAW_ANIMATION; &#125; else if (parent instanceof ViewRootImpl) &#123; ((ViewRootImpl) parent).mIsAnimating = true; &#125; &#125; // If the parent is dirty opaque or not dirty, mark it dirty with the opaque // flag coming from the child that initiated the invalidate if (view != null) &#123; if ((view.mViewFlags &amp; FADING_EDGE_MASK) != 0 &amp;&amp; view.getSolidColor() == 0) &#123; opaqueFlag = PFLAG_DIRTY; &#125; if ((view.mPrivateFlags &amp; PFLAG_DIRTY_MASK) != PFLAG_DIRTY) &#123; view.mPrivateFlags = (view.mPrivateFlags &amp; ~PFLAG_DIRTY_MASK) | opaqueFlag; &#125; &#125; parent = parent.invalidateChildInParent(location, dirty); if (view != null) &#123; // Account for transform on current parent Matrix m = view.getMatrix(); if (!m.isIdentity()) &#123; RectF boundingRect = attachInfo.mTmpTransformRect; boundingRect.set(dirty); m.mapRect(boundingRect); dirty.set((int) Math.floor(boundingRect.left), (int) Math.floor(boundingRect.top), (int) Math.ceil(boundingRect.right), (int) Math.ceil(boundingRect.bottom)); &#125; &#125; &#125; while (parent != null); //... ｝ /** * Don't call or override this method. It is used for the implementation of * the view hierarchy. * * This implementation returns null if this ViewGroup does not have a parent, * if this ViewGroup is already fully invalidated or if the dirty rectangle * does not intersect with this ViewGroup's bounds. */ @Override public ViewParent invalidateChildInParent(final int[] location, final Rect dirty) &#123; if ((mPrivateFlags &amp; PFLAG_DRAWN) == PFLAG_DRAWN || (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID) &#123; if ((mGroupFlags &amp; (FLAG_OPTIMIZE_INVALIDATE | FLAG_ANIMATION_DONE)) != FLAG_OPTIMIZE_INVALIDATE) &#123; dirty.offset(location[CHILD_LEFT_INDEX] - mScrollX, location[CHILD_TOP_INDEX] - mScrollY); if ((mGroupFlags &amp; FLAG_CLIP_CHILDREN) == 0) &#123; dirty.union(0, 0, mRight - mLeft, mBottom - mTop); &#125; final int left = mLeft; final int top = mTop; if ((mGroupFlags &amp; FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) &#123; if (!dirty.intersect(0, 0, mRight - left, mBottom - top)) &#123; dirty.setEmpty(); &#125; &#125; mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID; location[CHILD_LEFT_INDEX] = left; location[CHILD_TOP_INDEX] = top; if (mLayerType != LAYER_TYPE_NONE) &#123; mPrivateFlags |= PFLAG_INVALIDATED; &#125; return mParent; &#125; else &#123; mPrivateFlags &amp;= ~PFLAG_DRAWN &amp; ~PFLAG_DRAWING_CACHE_VALID; location[CHILD_LEFT_INDEX] = mLeft; location[CHILD_TOP_INDEX] = mTop; if ((mGroupFlags &amp; FLAG_CLIP_CHILDREN) == FLAG_CLIP_CHILDREN) &#123; dirty.set(0, 0, mRight - mLeft, mBottom - mTop); &#125; else &#123; // in case the dirty rect extends outside the bounds of this container dirty.union(0, 0, mRight - mLeft, mBottom - mTop); &#125; if (mLayerType != LAYER_TYPE_NONE) &#123; mPrivateFlags |= PFLAG_INVALIDATED; &#125; return mParent; &#125; &#125; return null; &#125;``` 从这里我们可以看到，在这个函数里面，主要是对当前`viewgroup`在次验证是否还有父布局，使用`do while`循环得到`parent`，等到最上层没有`parent`的时候才执行下一步,从这就可以知道，如果嵌套太多层的话，就会在这消耗性能。这样的话我们就可以知道，肯定是调用到了最外层的`ViewGroup`,也就是`ViewRootImpl`，我们查看`ViewRootImpl`源码:```java @Override public ViewParent invalidateChildInParent(int[] location, Rect dirty) &#123; checkThread(); if (DEBUG_DRAW) Log.v(mTag, "Invalidate child: " + dirty); if (dirty == null) &#123; invalidate(); return null; &#125; else if (dirty.isEmpty() &amp;&amp; !mIsAnimating) &#123; return null; &#125; if (mCurScrollY != 0 || mTranslator != null) &#123; mTempRect.set(dirty); dirty = mTempRect; if (mCurScrollY != 0) &#123; dirty.offset(0, -mCurScrollY); &#125; if (mTranslator != null) &#123; mTranslator.translateRectInAppWindowToScreen(dirty); &#125; if (mAttachInfo.mScalingRequired) &#123; dirty.inset(-1, -1); &#125; &#125; invalidateRectOnScreen(dirty); return null; &#125; void checkThread() &#123; if (mThread != Thread.currentThread()) &#123; throw new CalledFromWrongThreadException( "Only the original thread that created a view hierarchy can touch its views."); &#125; &#125; private void invalidateRectOnScreen(Rect dirty) &#123; final Rect localDirty = mDirty; if (!localDirty.isEmpty() &amp;&amp; !localDirty.contains(dirty)) &#123; mAttachInfo.mSetIgnoreDirtyState = true; mAttachInfo.mIgnoreDirtyState = true; &#125; // Add the new dirty rect to the current one localDirty.union(dirty.left, dirty.top, dirty.right, dirty.bottom); // Intersect with the bounds of the window to skip // updates that lie outside of the visible region final float appScale = mAttachInfo.mApplicationScale; final boolean intersected = localDirty.intersect(0, 0, (int) (mWidth * appScale + 0.5f), (int) (mHeight * appScale + 0.5f)); if (!intersected) &#123; localDirty.setEmpty(); &#125; if (!mWillDrawSoon &amp;&amp; (intersected || mIsAnimating)) &#123; scheduleTraversals(); &#125; &#125; void scheduleTraversals() &#123; if (!mTraversalScheduled) &#123; mTraversalScheduled = true; mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier(); mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null); if (!mUnbufferedInputDispatch) &#123; scheduleConsumeBatchedInput(); &#125; notifyRendererOfFramePending(); pokeDrawLockIfNeeded(); //..... 从这里我们就知道了，首先会检测线程，也就是为什么在子线程更新UI为什么会崩溃的原因，然后经过一系列的判断进入到scheduleTraversals函数，在这个函数中可以看到会调用mTraversalRunnable这个Runnable123456789101112131415161718192021222324252627final TraversalRunnable mTraversalRunnable = new TraversalRunnable(); final class TraversalRunnable implements Runnable &#123; @Override public void run() &#123; doTraversal(); &#125; &#125; void doTraversal() &#123; if (mTraversalScheduled) &#123; mTraversalScheduled = false; mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier); if (mProfile) &#123; Debug.startMethodTracing("ViewAncestor"); &#125; performTraversals(); if (mProfile) &#123; Debug.stopMethodTracing(); mProfile = false; &#125; &#125; &#125; 可以看到，实际上就是调用了performTraversals()函数,这个函数很长，我们主要看关键点:12345678910 private void performTraversals() &#123; //...... // Ask host how big it wants to be performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); //...... performLayout(lp, mWidth, mHeight); //..... performDraw(); //.....&#125; 可以看到，进入这里面了，会依次调用performMeasure performLayoutperformDraw三个函数，依次调用了view的绘制流程。 顾名思义，在performMeasure中主要会实现测量12345678private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, "measure"); try &#123; mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; &#125; mView就是ViewGroup，然后会调用ViewGroup的onMeasure函数，然后测量，就从最上层父布局一直到测量到最底层的view。performLayout主要负责子view摆放12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) &#123; mLayoutRequested = false; mScrollMayChange = true; mInLayout = true; final View host = mView; if (DEBUG_ORIENTATION || DEBUG_LAYOUT) &#123; Log.v(mTag, "Laying out " + host + " to (" + host.getMeasuredWidth() + ", " + host.getMeasuredHeight() + ")"); &#125; Trace.traceBegin(Trace.TRACE_TAG_VIEW, "layout"); try &#123; host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); mInLayout = false; int numViewsRequestingLayout = mLayoutRequesters.size(); if (numViewsRequestingLayout &gt; 0) &#123; // requestLayout() was called during layout. // If no layout-request flags are set on the requesting views, there is no problem. // If some requests are still pending, then we need to clear those flags and do // a full request/measure/layout pass to handle this situation. ArrayList&lt;View&gt; validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters, false); if (validLayoutRequesters != null) &#123; // Set this flag to indicate that any further requests are happening during // the second pass, which may result in posting those requests to the next // frame instead mHandlingLayoutInLayoutRequest = true; // Process fresh layout requests, then measure and layout int numValidRequests = validLayoutRequesters.size(); for (int i = 0; i &lt; numValidRequests; ++i) &#123; final View view = validLayoutRequesters.get(i); Log.w("View", "requestLayout() improperly called by " + view + " during layout: running second layout pass"); view.requestLayout(); &#125; measureHierarchy(host, lp, mView.getContext().getResources(), desiredWindowWidth, desiredWindowHeight); mInLayout = true; host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); mHandlingLayoutInLayoutRequest = false; // Check the valid requests again, this time without checking/clearing the // layout flags, since requests happening during the second pass get noop'd validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters, true); if (validLayoutRequesters != null) &#123; final ArrayList&lt;View&gt; finalRequesters = validLayoutRequesters; // Post second-pass requests to the next frame getRunQueue().post(new Runnable() &#123; @Override public void run() &#123; int numValidRequests = finalRequesters.size(); for (int i = 0; i &lt; numValidRequests; ++i) &#123; final View view = finalRequesters.get(i); Log.w("View", "requestLayout() improperly called by " + view + " during second layout pass: posting in next frame"); view.requestLayout(); &#125; &#125; &#125;); &#125; &#125; &#125; &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; mInLayout = false; &#125; 同样的道理，又是从最上层viewGroup到最底层的view。performDraw负责绘制,performDraw()会 调用draw,在调用drawSoftware123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/** * @return true if drawing was successful, false if an error occurred */ private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scalingRequired, Rect dirty) &#123; // Draw with software renderer. final Canvas canvas; try &#123; final int left = dirty.left; final int top = dirty.top; final int right = dirty.right; final int bottom = dirty.bottom; canvas = mSurface.lockCanvas(dirty); // The dirty rectangle can be modified by Surface.lockCanvas() //noinspection ConstantConditions if (left != dirty.left || top != dirty.top || right != dirty.right || bottom != dirty.bottom) &#123; attachInfo.mIgnoreDirtyState = true; &#125; // TODO: Do this in native canvas.setDensity(mDensity); &#125; catch (Surface.OutOfResourcesException e) &#123; handleOutOfResourcesException(e); return false; &#125; catch (IllegalArgumentException e) &#123; Log.e(mTag, "Could not lock surface", e); // Don't assume this is due to out of memory, it could be // something else, and if it is something else then we could // kill stuff (or ourself) for no reason. mLayoutRequested = true; // ask wm for a new surface next time. return false; &#125; try &#123; if (DEBUG_ORIENTATION || DEBUG_DRAW) &#123; Log.v(mTag, "Surface " + surface + " drawing to bitmap w=" + canvas.getWidth() + ", h=" + canvas.getHeight()); //canvas.drawARGB(255, 255, 0, 0); &#125; // If this bitmap's format includes an alpha channel, we // need to clear it before drawing so that the child will // properly re-composite its drawing on a transparent // background. This automatically respects the clip/dirty region // or // If we are applying an offset, we need to clear the area // where the offset doesn't appear to avoid having garbage // left in the blank areas. if (!canvas.isOpaque() || yoff != 0 || xoff != 0) &#123; canvas.drawColor(0, PorterDuff.Mode.CLEAR); &#125; dirty.setEmpty(); mIsAnimating = false; mView.mPrivateFlags |= View.PFLAG_DRAWN; if (DEBUG_DRAW) &#123; Context cxt = mView.getContext(); Log.i(mTag, "Drawing: package:" + cxt.getPackageName() + ", metrics=" + cxt.getResources().getDisplayMetrics() + ", compatibilityInfo=" + cxt.getResources().getCompatibilityInfo()); &#125; try &#123; canvas.translate(-xoff, -yoff); if (mTranslator != null) &#123; mTranslator.translateCanvas(canvas); &#125; canvas.setScreenDensity(scalingRequired ? mNoncompatDensity : 0); attachInfo.mSetIgnoreDirtyState = false; mView.draw(canvas); drawAccessibilityFocusedDrawableIfNeeded(canvas); &#125; finally &#123; if (!attachInfo.mSetIgnoreDirtyState) &#123; // Only clear the flag if it was not set during the mView.draw() call attachInfo.mIgnoreDirtyState = false; &#125; &#125; &#125; finally &#123; try &#123; surface.unlockCanvasAndPost(canvas); &#125; catch (IllegalArgumentException e) &#123; Log.e(mTag, "Could not unlock surface", e); mLayoutRequested = true; // ask wm for a new surface next time. //noinspection ReturnInsideFinallyBlock return false; &#125; if (LOCAL_LOGV) &#123; Log.v(mTag, "Surface " + surface + " unlockCanvasAndPost"); &#125; &#125; return true; &#125; 从mView.draw(canvas);可以看到，又是一样的从最上层ViewGroup一直调用最底层view，不断的从draw方法调用drawBackground-&gt;onDraw-&gt;dispatchDraw-&gt;onDrawForeground 。流程为下图: 从这更加验证了我们嵌套多层之后会消耗性能的真理。invalidate()就分析到这里了，有什么意见或者文中有什么错误的希望可以在下方评论。希望大家可以在看我的文章中可以学习到知识。]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 通过自己创建Resources加载非身生apk的资源]]></title>
    <url>%2FAndroid%20%E9%80%9A%E8%BF%87%E8%87%AA%E5%B7%B1%E5%88%9B%E5%BB%BAResources%E5%8A%A0%E8%BD%BD%E9%9D%9E%E8%BA%AB%E7%94%9Fapk%E7%9A%84%E8%B5%84%E6%BA%90.html</url>
    <content type="text"><![CDATA[在我们开发中我们在xml里面写布局1234&lt;ImageView android:src="@mipmap/ic_launcher_round" android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; 我们的src中赋值@mipmap/ic_launcher_round,然后就会得到对应的资源，那么有没有好奇我们这些资源是怎么加载进去的呢？我们点进ImageView去查看:1234567891011121314151617181920212223 final Drawable d = a.getDrawable(R.styleable.ImageView_src); if (d != null) &#123; setImageDrawable(d); &#125; @Nullable public Drawable getDrawable(@StyleableRes int index) &#123; if (mRecycled) &#123; throw new RuntimeException("Cannot make calls to a recycled instance!"); &#125; final TypedValue value = mValue; if (getValueAt(index*AssetManager.STYLE_NUM_ENTRIES, value)) &#123; if (value.type == TypedValue.TYPE_ATTRIBUTE) &#123; throw new UnsupportedOperationException( "Failed to resolve attribute at index " + index + ": " + value); &#125; return mResources.loadDrawable(value, value.resourceId, mTheme); &#125; return null; &#125;mResources.loadDrawable(value, value.resourceId, mTheme); 调用的是mResources的loadDrawable方法,这样就获取了相应的值。下面我们通过来分析Resources是怎么创建和寻找对应的资源的。如果我们想要用自己的Resources来加载资源，我们应该怎么做呢?我们从Activity的getResources()里面入手:1234567891011private Resources getResourcesInternal() &#123; if (mResources == null) &#123; if (mOverrideConfiguration == null) &#123; mResources = super.getResources(); &#125; else &#123; final Context resContext = createConfigurationContext(mOverrideConfiguration); mResources = resContext.getResources(); &#125; &#125; return mResources;&#125; 可以发现这个mResources是在Context里面获取到的，在Context里面: 123456789101112/** * Returns a Resources instance for the application's package. * &lt;p&gt; * &lt;strong&gt;Note:&lt;/strong&gt; Implementations of this method should return * a Resources instance that is consistent with the AssetManager instance * returned by &#123;@link #getAssets()&#125;. For example, they should share the * same &#123;@link Configuration&#125; object. * * @return a Resources instance for the application's package * @see #getAssets() */ public abstract Resources getResources(); 这是一个抽象方法，从注释上我们可以知道这个应该和getAssets(),也就是和AssetManager有关,我们找到Context的实现类ContextImpl查看:1234567891011121314151617181920212223 @Override public Resources getResources() &#123; return mResources; &#125; private ContextImpl(ContextImpl container, ActivityThread mainThread, LoadedApk packageInfo, IBinder activityToken, UserHandle user, boolean restricted, Display display, Configuration overrideConfiguration, int createDisplayWithId) &#123; //.... Resources resources = packageInfo.getResources(mainThread); if (resources != null) &#123; if (displayId != Display.DEFAULT_DISPLAY || overrideConfiguration != null || (compatInfo != null &amp;&amp; compatInfo.applicationScale != resources.getCompatibilityInfo().applicationScale)) &#123; resources = mResourcesManager.getTopLevelResources(packageInfo.getResDir(), packageInfo.getSplitResDirs(), packageInfo.getOverlayDirs(), packageInfo.getApplicationInfo().sharedLibraryFiles, displayId, overrideConfiguration, compatInfo); &#125; &#125; mResources = resources; //....&#125; 发现是ResourcesManager里面调用了getTopLevelResources函数，点进去：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/** * Creates the top level Resources for applications with the given compatibility info. * * @param resDir the resource directory. * @param splitResDirs split resource directories. * @param overlayDirs the resource overlay directories. * @param libDirs the shared library resource dirs this app references. * @param displayId display Id. * @param overrideConfiguration override configurations. * @param compatInfo the compatibility info. Must not be null. */ Resources getTopLevelResources(String resDir, String[] splitResDirs, String[] overlayDirs, String[] libDirs, int displayId, Configuration overrideConfiguration, CompatibilityInfo compatInfo) &#123; //..... Configuration overrideConfigCopy = (overrideConfiguration != null) ? new Configuration(overrideConfiguration) : null; ResourcesKey key = new ResourcesKey(resDir, displayId, overrideConfigCopy, scale); Resources r; synchronized (this) &#123; // Resources is app scale dependent. if (DEBUG) Slog.w(TAG, "getTopLevelResources: " + resDir + " / " + scale); WeakReference&lt;Resources&gt; wr = mActiveResources.get(key); r = wr != null ? wr.get() : null; //if (r != null) Log.i(TAG, "isUpToDate " + resDir + ": " + r.getAssets().isUpToDate()); if (r != null &amp;&amp; r.getAssets().isUpToDate()) &#123; if (DEBUG) Slog.w(TAG, "Returning cached resources " + r + " " + resDir + ": appScale=" + r.getCompatibilityInfo().applicationScale + " key=" + key + " overrideConfig=" + overrideConfiguration); return r; &#125; &#125; AssetManager assets = new AssetManager(); // resDir can be null if the 'android' package is creating a new Resources object. // This is fine, since each AssetManager automatically loads the 'android' package // already. if (resDir != null) &#123; if (assets.addAssetPath(resDir) == 0) &#123; return null; &#125; &#125; if (splitResDirs != null) &#123; for (String splitResDir : splitResDirs) &#123; if (assets.addAssetPath(splitResDir) == 0) &#123; return null; &#125; &#125; &#125; if (overlayDirs != null) &#123; for (String idmapPath : overlayDirs) &#123; assets.addOverlayPath(idmapPath); &#125; &#125; if (libDirs != null) &#123; for (String libDir : libDirs) &#123; if (libDir.endsWith(".apk")) &#123; // Avoid opening files we know do not have resources, // like code-only .jar files. if (assets.addAssetPath(libDir) == 0) &#123; Log.w(TAG, "Asset path '" + libDir + "' does not exist or contains no resources."); &#125; &#125; &#125; &#125; //Log.i(TAG, "Resource: key=" + key + ", display metrics=" + metrics); DisplayMetrics dm = getDisplayMetricsLocked(displayId); Configuration config; final boolean isDefaultDisplay = (displayId == Display.DEFAULT_DISPLAY); final boolean hasOverrideConfig = key.hasOverrideConfiguration(); if (!isDefaultDisplay || hasOverrideConfig) &#123; config = new Configuration(getConfiguration()); if (!isDefaultDisplay) &#123; applyNonDefaultDisplayMetricsToConfigurationLocked(dm, config); &#125; if (hasOverrideConfig) &#123; config.updateFrom(key.mOverrideConfiguration); if (DEBUG) Slog.v(TAG, "Applied overrideConfig=" + key.mOverrideConfiguration); &#125; &#125; else &#123; config = getConfiguration(); &#125; r = new Resources(assets, dm, config, compatInfo); //.... return r; &#125; &#125; 从这段代码我们就可以知道，如果缓存里面有对应的Resources就直接返回，如果没有就直接new出来,对应的资源路径就是通过AssetManager.addAssetPath(String path)函数设置,也验证了上面说的那句话，Resources和AssetManager有关。 AssetManager的创建我们进入AssetManager类中查看addAssetPath函数:123456789101112131415/** * Add an additional set of assets to the asset manager. This can be * either a directory or ZIP file. Not for use by applications. Returns * the cookie of the added asset, or 0 on failure. * &#123;@hide&#125; */ public final int addAssetPath(String path) &#123; synchronized (this) &#123; int res = addAssetPathNative(path); makeStringBlocks(mStringBlocks); return res; &#125; &#125; private native final int addAssetPathNative(String path); 可以看到调用了一个native方法，从注释我们可以知道,这个路径对应的可以是一个目录或者一个zip文件。我们看看AssetManager的构造方法 123456789101112131415161718/** * Create a new AssetManager containing only the basic system assets. * Applications will not generally use this method, instead retrieving the * appropriate asset manager with &#123;@link Resources#getAssets&#125;. Not for * use by applications. * &#123;@hide&#125; */ public AssetManager() &#123; synchronized (this) &#123; if (DEBUG_REFS) &#123; mNumRefs = 0; incRefsLocked(this.hashCode()); &#125; init(false); if (localLOGV) Log.v(TAG, "New asset manager: " + this); ensureSystemAssets(); &#125; &#125; 我们可以查看到addAssetPath这个方法和AssetManager的构造方法注释上面都有{@hide},这个表示我们不能在应用层直接调用,如果我们还是要调用的话就需要用到反射: 1234567//创建一个AssetManager//AssetManager assetManager = new AssetManager(); hide的调用不了 只有用反射调用AssetManager assetManager = AssetManager.class.newInstance();//添加本地下载好的资源// assetManager.addAssetPath(String path);// 也是hide的调用不了 继续用反射执行该方法Method addAssetPathMethod = assetManager.getClass().getDeclaredMethod("addAssetPath", String.class);addAssetPathMethod.invoke(assetManager, resPath); 通过前面的分析可知,Android系统中实际对资源的管理是AssetManager类.每个Resources对象都会关联一个AssetManager对象，Resources将对资源的操作大多数委托给了AssetManager。当然有些源码还有一层 ResourcesImpl 刚刚我们也看到了。 另外还会存在一个native层的AssetManager对象与java层的这个AssetManager对象相对应，而这个native层AssetManager对象在内存的地址存储在java层的AssetManager.mObject中。所以在java层AssetManager的jni方法中可以快速找到它对应的native层的AssetManager对象。AssetManager的init()1234567891011121314151617181920212223/** * Create a new AssetManager containing only the basic system assets. * Applications will not generally use this method, instead retrieving the * appropriate asset manager with &#123;@link Resources#getAssets&#125;. Not for * use by applications. * &#123;@hide&#125; */ public AssetManager() &#123; synchronized (this) &#123; if (DEBUG_REFS) &#123; mNumRefs = 0; incRefsLocked(this.hashCode()); &#125; init(false); if (localLOGV) Log.v(TAG, "New asset manager: " + this); ensureSystemAssets(); &#125; &#125; // ndk的源码路径 // frameworks/base/core/jni/android_util_AssetManager.cpp // frameworks/base/libs/androidfw/AssetManager.cpp private native final void init(boolean isSystem); 12345678910111213141516171819202122232425262728293031static void android_content_AssetManager_init(JNIEnv* env, jobject clazz, jboolean isSystem)&#123; if (isSystem) &#123; verifySystemIdmaps(); &#125; // AssetManager.cpp AssetManager* am = new AssetManager(); if (am == NULL) &#123; jniThrowException(env, "java/lang/OutOfMemoryError", ""); return; &#125; am-&gt;addDefaultAssets(); ALOGV("Created AssetManager %p for Java object %p\n", am, clazz); env-&gt;SetLongField(clazz, gAssetManagerOffsets.mObject, reinterpret_cast&lt;jlong&gt;(am));&#125;bool AssetManager::addDefaultAssets()&#123; const char* root = getenv("ANDROID_ROOT"); LOG_ALWAYS_FATAL_IF(root == NULL, "ANDROID_ROOT not set"); String8 path(root); // framework/framework-res.apk // 初始化的时候会去加载系统的framework-res.apk资源 // 也就是说我们为什么能加载系统的资源如颜色、图片、文字等等 path.appendPath(kSystemAssets); return addAssetPath(path, NULL);&#125; AssetManager的addAssetPath(String path)方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143bool AssetManager::addAssetPath(const String8&amp; path, int32_t* cookie)&#123; asset_path ap; // 省略一些校验代码 // 判断是否已经加载过了 for (size_t i=0; i&lt;mAssetPaths.size(); i++) &#123; if (mAssetPaths[i].path == ap.path) &#123; if (cookie) &#123; *cookie = static_cast&lt;int32_t&gt;(i+1); &#125; return true; &#125; &#125; // 检查路径是否有一个androidmanifest . xml Asset* manifestAsset = const_cast&lt;AssetManager*&gt;(this)-&gt;openNonAssetInPathLocked( kAndroidManifest, Asset::ACCESS_BUFFER, ap); if (manifestAsset == NULL) &#123; // 如果不包含任何资源 delete manifestAsset; return false; &#125; delete manifestAsset; // 添加 mAssetPaths.add(ap); // 新路径总是补充到最后 if (cookie) &#123; *cookie = static_cast&lt;int32_t&gt;(mAssetPaths.size()); &#125; if (mResources != NULL) &#123; appendPathToResTable(ap); &#125; return true;&#125;bool AssetManager::appendPathToResTable(const asset_path&amp; ap) const &#123; // skip those ap's that correspond to system overlays if (ap.isSystemOverlay) &#123; return true; &#125; Asset* ass = NULL; ResTable* sharedRes = NULL; bool shared = true; bool onlyEmptyResources = true; MY_TRACE_BEGIN(ap.path.string()); // 资源覆盖机制，暂不考虑 Asset* idmap = openIdmapLocked(ap); size_t nextEntryIdx = mResources-&gt;getTableCount(); ALOGV("Looking for resource asset in '%s'\n", ap.path.string()); // 资源包路径不是一个文件夹，那就是一个apk文件了 if (ap.type != kFileTypeDirectory) &#123; // 对于app来说，第一次执行时，肯定为0，因为mResources刚创建，还没对其操作 // 下面的分支 指挥在参数是系统资源包路径时，才执行， // 而且系统资源包路径是首次被解析的 // 第二次执行appendPathToResTable，nextEntryIdx就不会为0了 if (nextEntryIdx == 0) &#123; // mAssetPaths中存储的第一个资源包路径是系统资源的路径， // 即framework-res.apk的路径，它在zygote启动时已经加载了 // 可以通过mZipSet.getZipResourceTable获得其ResTable对象 sharedRes = const_cast&lt;AssetManager*&gt;(this)-&gt; mZipSet.getZipResourceTable(ap.path); // 对于APP来说，肯定不为NULL if (sharedRes != NULL) &#123; // 得到系统资源包路径中resources.arsc个数 nextEntryIdx = sharedRes-&gt;getTableCount(); &#125; &#125; // 当参数是mAssetPaths中除第一个以外的其他资源资源包路径， // 比如app自己的资源包路径时，走下面的逻辑 if (sharedRes == NULL) &#123; // 检查该资源包是否被其他进程加载了，这与ZipSet数据结构有关，后面在详细介绍 ass = const_cast&lt;AssetManager*&gt;(this)-&gt; mZipSet.getZipResourceTableAsset(ap.path); // 对于app自己的资源包来说，一般都会都下面的逻辑 if (ass == NULL) &#123; ALOGV("loading resource table %s\n", ap.path.string()); // 创建Asset对象，就是打开resources.arsc ass = const_cast&lt;AssetManager*&gt;(this)-&gt; openNonAssetInPathLocked("resources.arsc", Asset::ACCESS_BUFFER, ap); if (ass != NULL &amp;&amp; ass != kExcludedAsset) &#123; ass = const_cast&lt;AssetManager*&gt;(this)-&gt; mZipSet.setZipResourceTableAsset(ap.path, ass); &#125; &#125; // 只有在zygote启动时，才会执行下面的逻辑 // 为系统资源创建 ResTable，并加入到mZipSet里。 if (nextEntryIdx == 0 &amp;&amp; ass != NULL) &#123; // If this is the first resource table in the asset // manager, then we are going to cache it so that we // can quickly copy it out for others. ALOGV("Creating shared resources for %s", ap.path.string()); // 创建ResTable对象，并把前面与resources.arsc关联的Asset对象，加入到这个ResTabl中 sharedRes = new ResTable(); sharedRes-&gt;add(ass, idmap, nextEntryIdx + 1, false); sharedRes = const_cast&lt;AssetManager*&gt;(this)-&gt; mZipSet.setZipResourceTable(ap.path, sharedRes); &#125; &#125; &#125; else &#123; ALOGV("loading resource table %s\n", ap.path.string()); ass = const_cast&lt;AssetManager*&gt;(this)-&gt; openNonAssetInPathLocked("resources.arsc", Asset::ACCESS_BUFFER, ap); shared = false; &#125; if ((ass != NULL || sharedRes != NULL) &amp;&amp; ass != kExcludedAsset) &#123; ALOGV("Installing resource asset %p in to table %p\n", ass, mResources); // 系统资源包时 if (sharedRes != NULL) &#123; ALOGV("Copying existing resources for %s", ap.path.string()); mResources-&gt;add(sharedRes); &#125; else &#123; // 非系统资源包时，将与resources.arsc关联的Asset对象加入到Restable中 // 此过程会解析resources.arsc文件。 ALOGV("Parsing resources for %s", ap.path.string()); mResources-&gt;add(ass, idmap, nextEntryIdx + 1, !shared); &#125; onlyEmptyResources = false; if (!shared) &#123; delete ass; &#125; &#125; else &#123; mResources-&gt;addEmpty(nextEntryIdx + 1); &#125; if (idmap != NULL) &#123; delete idmap; &#125; MY_TRACE_END(); return onlyEmptyResources;&#125; 大家应该之前了解过这个文件resources.arsc， 如果没了解过可以在网上找篇文章看一下。apk在打包的时候会生成它，我们解压apk就应该能够看到他。这里面基本都是存放的资源的索引，之所以不同的分辨率可以加载不同的图片它可是个大功臣。 我们获取到了assetManager其他的都好办了，因为资源地址是由这个决定的，所以我们其他的都可以用当前app本身的123456789//创建一个AssetManager //AssetManager assetManager = new AssetManager(); hide的调用不了 只有用反射调用 AssetManager assetManager = AssetManager.class.newInstance(); //添加本地下载好的资源皮肤 // assetManager.addAssetPath(String path);// 也是hide的调用不了 继续用反射执行该方法 Method addAssetPathMethod = assetManager.getClass().getDeclaredMethod("addAssetPath", String.class); addAssetPathMethod.invoke(assetManager, resPath); Resources superResources = context.getResources(); Resources mResources = new Resources(assetManager, superResources.getDisplayMetrics(), superResources.getConfiguration()); 这样的话我们就可以通过自己创建Resources来加载非本身apk的资源了`]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android setContentView()源码流程分析]]></title>
    <url>%2FAndroid%20setContentView()%E6%BA%90%E7%A0%81%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.html</url>
    <content type="text"><![CDATA[我们在Activity创建的时候，都用调用setContentView()函数来设置界面，下面我们通过源码来分析setContentView()的流程。我们先看Activity里面的setContentView进去查看：12345678910111213/** * Set the activity content from a layout resource. The resource will be * inflated, adding all top-level views to the activity. * * @param layoutResID Resource ID to be inflated. * * @see #setContentView(android.view.View) * @see #setContentView(android.view.View, android.view.ViewGroup.LayoutParams) */ public void setContentView(@LayoutRes int layoutResID) &#123; getWindow().setContentView(layoutResID); initWindowDecorActionBar(); &#125; 函数如下:我们再次点击setContentView进去查看发现是一个Window的抽象方法,所以我们要找到对应的实现类，我们点击getWindow()进去查看最终得到:1mWindow = new PhoneWindow(this, window); 我们得到了他的实现类PhoneWindow，然后在PhoneWindow找到setContentView函数:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Override public void setContentView(int layoutResID) &#123; // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. if (mContentParent == null) &#123; installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; final Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID, getContext()); transitionTo(newScene); &#125; else &#123; mLayoutInflater.inflate(layoutResID, mContentParent); &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125; &#125; @Override public void setContentView(View view) &#123; setContentView(view, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); &#125; @Override public void setContentView(View view, ViewGroup.LayoutParams params) &#123; // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. if (mContentParent == null) &#123; installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; view.setLayoutParams(params); final Scene newScene = new Scene(mContentParent, view); transitionTo(newScene); &#125; else &#123; mContentParent.addView(view, params); &#125; mContentParent.requestApplyInsets(); final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125; &#125; 可以发现都是把这个View加到了mContentParent这个ViewGroup里面去了，这个mContentParent是什么呢？我们急着看源码,发现在installDecor()方法里面:1mContentParent = generateLayout(mDecor); 继续点进去:123456789101112131415161718192021222324252627282930313233343536373839protected ViewGroup generateLayout(DecorView decor) &#123; // Apply data from current theme. TypedArray a = getWindowStyle(); if (false) &#123; System.out.println("From style:"); String s = "Attrs:"; for (int i = 0; i &lt; R.styleable.Window.length; i++) &#123; s = s + " " + Integer.toHexString(R.styleable.Window[i![无标题.png](http://upload-images.jianshu.io/upload_images/4658633-9a3a758cbac9f8aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)]) + "=" + a.getString(i); &#125; System.out.println(s); &#125; //根据style属性做一些列的判断... //在做一些列的判断得到layoutResource layoutResource=.... //这里用R.layout.screen_simple来分析 mDecor.startChanging(); View in = mLayoutInflater.inflate(layoutResource, null); decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); mContentRoot = (ViewGroup) in; ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); if (contentParent == null) &#123; throw new RuntimeException("Window couldn't find content container view"); &#125; //...... mDecor.finishChanging(); return contentParent; &#125; 从这段代码可以知道，通过一系列的判断，得到相对于的layoutResource,然后通过mLayoutInflater.inflate(layoutResource, null);得到这个View,将其加入到mDecor,其中mContentParent最终为一个ID_ANDROID_CONTENT = com.android.internal.R.id.content的一个ViewGroup，在这里我们拿R.layout.screen_simple布局来看看123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!--/* //device/apps/common/assets/res/layout/screen_simple.xml**** Copyright 2006, The Android Open Source Project**** Licensed under the Apache License, Version 2.0 (the "License"); ** you may not use this file except in compliance with the License. ** You may obtain a copy of the License at **** http://www.apache.org/licenses/LICENSE-2.0 **** Unless required by applicable law or agreed to in writing, software ** distributed under the License is distributed on an "AS IS" BASIS, ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. ** See the License for the specific language governing permissions and ** limitations under the License.*/This is an optimized layout for a screen, with the minimum set of featuresenabled.--&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:fitsSystemWindows="true" android:orientation="vertical"&gt; &lt;ViewStub android:id="@+id/action_mode_bar_stub" android:inflatedId="@+id/action_mode_bar" android:layout="@layout/action_mode_bar" android:layout_width="match_parent" android:layout_height="wrap_content" android:theme="?attr/actionBarTheme" /&gt; &lt;FrameLayout android:id="@android:id/content" android:layout_width="match_parent" android:layout_height="match_parent" android:foregroundInsidePadding="false" android:foregroundGravity="fill_horizontal|top" android:foreground="?android:attr/windowContentOverlay" /&gt;&lt;/LinearLayout&gt; 可以知道这个mContentParent为一个FrameLayout，这时候我们应该知道，我们setContentView其实就是把那个View加入到一个id为com.android.internal.R.id.content的FrameLayout里面，而这个id为com.android.internal.R.id.content的FrameLayout有parentView又是加在mDecor里面，我们来看看这个mDecor是什么，在installDecor()函数中:12345678if (mDecor == null) &#123; mDecor = generateDecor(); mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS); mDecor.setIsRootNamespace(true); if (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != 0) &#123; mDecor.postOnAnimation(mInvalidatePanelMenuRunnable); &#125; &#125; 123protected DecorView generateDecor() &#123; return new DecorView(getContext(), -1); &#125; 可以发现这个mDecor就是一个new的一个DecorView,我们继续看：1private final class DecorView extends FrameLayout 这个DecorView其实也是一个FrameLayout,这个时候我们就可以得到这样一张图: 在这基础上我们看AppCompatActivity的setContentView函数:1234567891011121314151617181920212223242526272829303132333435363738 @Override public void setContentView(@LayoutRes int layoutResID) &#123; getDelegate().setContentView(layoutResID); &#125; /** * @return The &#123;@link AppCompatDelegate&#125; being used by this Activity. */ @NonNull public AppCompatDelegate getDelegate() &#123; if (mDelegate == null) &#123; mDelegate = AppCompatDelegate.create(this, this); &#125; return mDelegate; &#125;/** * Create a &#123;@link android.support.v7.app.AppCompatDelegate&#125; to use with &#123;@code activity&#125;. * * @param callback An optional callback for AppCompat specific events */ public static AppCompatDelegate create(Activity activity, AppCompatCallback callback) &#123; return create(activity, activity.getWindow(), callback); &#125; private static AppCompatDelegate create(Context context, Window window, AppCompatCallback callback) &#123; final int sdk = Build.VERSION.SDK_INT; if (sdk &gt;= 23) &#123; return new AppCompatDelegateImplV23(context, window, callback); &#125; else if (sdk &gt;= 14) &#123; return new AppCompatDelegateImplV14(context, window, callback); &#125; else if (sdk &gt;= 11) &#123; return new AppCompatDelegateImplV11(context, window, callback); &#125; else &#123; return new AppCompatDelegateImplV7(context, window, callback); &#125; &#125; 可以看到最终进入到了AppCompatDelegate的create方法,这个函数通过new 23 14 11 7就可以看出是为了兼容不同的版本,我们点进去就可以看到AppCompatDelegateImplV23–&gt;AppCompatDelegateImplV14–&gt;AppCompatDelegateImplV11–&gt;AppCompatDelegateImplV7依次继承的，我们最终查看到AppCompatDelegateImplV7的setContentView函数:1234567891011121314151617181920212223242526@Override public void setContentView(View v) &#123; ensureSubDecor(); ViewGroup contentParent = (ViewGroup) mSubDecor.findViewById(android.R.id.content); contentParent.removeAllViews(); contentParent.addView(v); mOriginalWindowCallback.onContentChanged(); &#125; @Override public void setContentView(int resId) &#123; ensureSubDecor(); ViewGroup contentParent = (ViewGroup) mSubDecor.findViewById(android.R.id.content); contentParent.removeAllViews(); LayoutInflater.from(mContext).inflate(resId, contentParent); mOriginalWindowCallback.onContentChanged(); &#125; @Override public void setContentView(View v, ViewGroup.LayoutParams lp) &#123; ensureSubDecor(); ViewGroup contentParent = (ViewGroup) mSubDecor.findViewById(android.R.id.content); contentParent.removeAllViews(); contentParent.addView(v, lp); mOriginalWindowCallback.onContentChanged(); &#125; 其实也就是把得到的view添加到contentParent里面。比如说，在android21以前一般是使用控件TextView等控件，在21以后出了相关的AppCompat控件，这个时候怎么让开发者写的TextView自动转换为AppCompatTextView呢？所以在AppCompatDelegateImplV7重写了这样一个函数函数:12345678910111213@Override public void installViewFactory() &#123; LayoutInflater layoutInflater = LayoutInflater.from(mContext); if (layoutInflater.getFactory() == null) &#123; LayoutInflaterCompat.setFactory(layoutInflater, this); &#125; else &#123; if (!(LayoutInflaterCompat.getFactory(layoutInflater) instanceof AppCompatDelegateImplV7)) &#123; Log.i(TAG, "The Activity's LayoutInflater already has a Factory installed" + " so we can not install AppCompat's"); &#125; &#125; &#125; 我们查找abstract类，可以查看着方法注释:12345678910111213141516171819/** * Installs AppCompat's &#123;@link android.view.LayoutInflater&#125; Factory so that it can replace * the framework widgets with compatible tinted versions. This should be called before * &#123;@code super.onCreate()&#125; as so: * &lt;pre class="prettyprint"&gt; * protected void onCreate(Bundle savedInstanceState) &#123; * getDelegate().installViewFactory(); * getDelegate().onCreate(savedInstanceState); * super.onCreate(savedInstanceState); * * // ... * &#125; * &lt;/pre&gt; * If you are using your own &#123;@link android.view.LayoutInflater.Factory Factory&#125; or * &#123;@link android.view.LayoutInflater.Factory2 Factory2&#125; then you can omit this call, and instead call * &#123;@link #createView(android.view.View, String, android.content.Context, android.util.AttributeSet)&#125; * from your factory to return any compatible widgets. */ public abstract void installViewFactory(); 从意思可以看出，就是说我们可以通过这个方法然后给LayoutInflater设置一个Factory,这个Factory是干嘛的呢？从我的上篇文章就知道，这个Factory是在LayoutInflater执行inflate函数生成View的时候用的，这个Factory可以拦截View的生成，通过这个Factory我们可以自己给inflate写一套解析layout.xml的规则，在换肤的时候就可以用到这个。我们实现LayoutInflaterFactory接口，重写onCreateView方法，就可以拦截相应的信息进行解析。比如在AppCompatDelegateImplV7类中:12345678910111213141516171819202122232425262728293031323334353637383940414243444546 /** * From &#123;@link android.support.v4.view.LayoutInflaterFactory&#125; */ @Override public final View onCreateView(View parent, String name, Context context, AttributeSet attrs) &#123; // First let the Activity's Factory try and inflate the view final View view = callActivityOnCreateView(parent, name, context, attrs); if (view != null) &#123; return view; &#125; // If the Factory didn't handle it, let our createView() method try return createView(parent, name, context, attrs); &#125; View callActivityOnCreateView(View parent, String name, Context context, AttributeSet attrs) &#123; // Let the Activity's LayoutInflater.Factory try and handle it if (mOriginalWindowCallback instanceof LayoutInflater.Factory) &#123; final View result = ((LayoutInflater.Factory) mOriginalWindowCallback) .onCreateView(name, context, attrs); if (result != null) &#123; return result; &#125; &#125; return null; &#125;@Override public View createView(View parent, final String name, @NonNull Context context, @NonNull AttributeSet attrs) &#123; final boolean isPre21 = Build.VERSION.SDK_INT &lt; 21; if (mAppCompatViewInflater == null) &#123; mAppCompatViewInflater = new AppCompatViewInflater(); &#125; // We only want the View to inherit its context if we're running pre-v21 final boolean inheritContext = isPre21 &amp;&amp; shouldInheritContext((ViewParent) parent); return mAppCompatViewInflater.createView(parent, name, context, attrs, inheritContext, isPre21, /* Only read android:theme pre-L (L+ handles this anyway) */ true /* Read read app:theme as a fallback at all times for legacy reasons */ ); &#125; 它拦截下了layoutt.xml的解析，自己写了一个解析类AppCompatViewInflater，来解析View123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326/* * Copyright (C) 2014 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package android.support.v7.app;import android.content.Context;import android.content.ContextWrapper;import android.content.res.TypedArray;import android.os.Build;import android.support.annotation.NonNull;import android.support.annotation.Nullable;import android.support.v4.util.ArrayMap;import android.support.v4.view.ViewCompat;import android.support.v7.appcompat.R;import android.support.v7.view.ContextThemeWrapper;import android.support.v7.widget.AppCompatAutoCompleteTextView;import android.support.v7.widget.AppCompatButton;import android.support.v7.widget.AppCompatCheckBox;import android.support.v7.widget.AppCompatCheckedTextView;import android.support.v7.widget.AppCompatEditText;import android.support.v7.widget.AppCompatImageButton;import android.support.v7.widget.AppCompatImageView;import android.support.v7.widget.AppCompatMultiAutoCompleteTextView;import android.support.v7.widget.AppCompatRadioButton;import android.support.v7.widget.AppCompatRatingBar;import android.support.v7.widget.AppCompatSeekBar;import android.support.v7.widget.AppCompatSpinner;import android.support.v7.widget.AppCompatTextView;import android.util.AttributeSet;import android.util.Log;import android.view.InflateException;import android.view.View;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.util.Map;/** * This class is responsible for manually inflating our tinted widgets which are used on devices * running &#123;@link android.os.Build.VERSION_CODES#KITKAT KITKAT&#125; or below. As such, this class * should only be used when running on those devices. * &lt;p&gt;This class two main responsibilities: the first is to 'inject' our tinted views in place of * the framework versions in layout inflation; the second is backport the &#123;@code android:theme&#125; * functionality for any inflated widgets. This include theme inheritance from it's parent. */class AppCompatViewInflater &#123; private static final Class&lt;?&gt;[] sConstructorSignature = new Class[]&#123; Context.class, AttributeSet.class&#125;; private static final int[] sOnClickAttrs = new int[]&#123;android.R.attr.onClick&#125;; private static final String[] sClassPrefixList = &#123; "android.widget.", "android.view.", "android.webkit." &#125;; private static final String LOG_TAG = "AppCompatViewInflater"; private static final Map&lt;String, Constructor&lt;? extends View&gt;&gt; sConstructorMap = new ArrayMap&lt;&gt;(); private final Object[] mConstructorArgs = new Object[2]; public final View createView(View parent, final String name, @NonNull Context context, @NonNull AttributeSet attrs, boolean inheritContext, boolean readAndroidTheme, boolean readAppTheme) &#123; final Context originalContext = context; // We can emulate Lollipop's android:theme attribute propagating down the view hierarchy // by using the parent's context if (inheritContext &amp;&amp; parent != null) &#123; context = parent.getContext(); &#125; if (readAndroidTheme || readAppTheme) &#123; // We then apply the theme on the context, if specified context = themifyContext(context, attrs, readAndroidTheme, readAppTheme); &#125; View view = null; // We need to 'inject' our tint aware Views in place of the standard framework versions switch (name) &#123; case "TextView": view = new AppCompatTextView(context, attrs); break; case "ImageView": view = new AppCompatImageView(context, attrs); break; case "Button": view = new AppCompatButton(context, attrs); break; case "EditText": view = new AppCompatEditText(context, attrs); break; case "Spinner": view = new AppCompatSpinner(context, attrs); break; case "ImageButton": view = new AppCompatImageButton(context, attrs); break; case "CheckBox": view = new AppCompatCheckBox(context, attrs); break; case "RadioButton": view = new AppCompatRadioButton(context, attrs); break; case "CheckedTextView": view = new AppCompatCheckedTextView(context, attrs); break; case "AutoCompleteTextView": view = new AppCompatAutoCompleteTextView(context, attrs); break; case "MultiAutoCompleteTextView": view = new AppCompatMultiAutoCompleteTextView(context, attrs); break; case "RatingBar": view = new AppCompatRatingBar(context, attrs); break; case "SeekBar": view = new AppCompatSeekBar(context, attrs); break; &#125; if (view == null &amp;&amp; originalContext != context) &#123; // If the original context does not equal our themed context, then we need to manually // inflate it using the name so that android:theme takes effect. view = createViewFromTag(context, name, attrs); &#125; if (view != null) &#123; // If we have created a view, check it's android:onClick checkOnClickListener(view, attrs); &#125; return view; &#125; private View createViewFromTag(Context context, String name, AttributeSet attrs) &#123; if (name.equals("view")) &#123; name = attrs.getAttributeValue(null, "class"); &#125; try &#123; mConstructorArgs[0] = context; mConstructorArgs[1] = attrs; if (-1 == name.indexOf('.')) &#123; for (int i = 0; i &lt; sClassPrefixList.length; i++) &#123; final View view = createView(context, name, sClassPrefixList[i]); if (view != null) &#123; return view; &#125; &#125; return null; &#125; else &#123; return createView(context, name, null); &#125; &#125; catch (Exception e) &#123; // We do not want to catch these, lets return null and let the actual LayoutInflater // try return null; &#125; finally &#123; // Don't retain references on context. mConstructorArgs[0] = null; mConstructorArgs[1] = null; &#125; &#125; /** * android:onClick doesn't handle views with a ContextWrapper context. This method * backports new framework functionality to traverse the Context wrappers to find a * suitable target. */ private void checkOnClickListener(View view, AttributeSet attrs) &#123; final Context context = view.getContext(); if (!(context instanceof ContextWrapper) || (Build.VERSION.SDK_INT &gt;= 15 &amp;&amp; !ViewCompat.hasOnClickListeners(view))) &#123; // Skip our compat functionality if: the Context isn't a ContextWrapper, or // the view doesn't have an OnClickListener (we can only rely on this on API 15+ so // always use our compat code on older devices) return; &#125; final TypedArray a = context.obtainStyledAttributes(attrs, sOnClickAttrs); final String handlerName = a.getString(0); if (handlerName != null) &#123; view.setOnClickListener(new DeclaredOnClickListener(view, handlerName)); &#125; a.recycle(); &#125; private View createView(Context context, String name, String prefix) throws ClassNotFoundException, InflateException &#123; Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name); try &#123; if (constructor == null) &#123; // Class not found in the cache, see if it's real, and try to add it Class&lt;? extends View&gt; clazz = context.getClassLoader().loadClass( prefix != null ? (prefix + name) : name).asSubclass(View.class); constructor = clazz.getConstructor(sConstructorSignature); sConstructorMap.put(name, constructor); &#125; constructor.setAccessible(true); return constructor.newInstance(mConstructorArgs); &#125; catch (Exception e) &#123; // We do not want to catch these, lets return null and let the actual LayoutInflater // try return null; &#125; &#125; /** * Allows us to emulate the &#123;@code android:theme&#125; attribute for devices before L. */ private static Context themifyContext(Context context, AttributeSet attrs, boolean useAndroidTheme, boolean useAppTheme) &#123; final TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.View, 0, 0); int themeId = 0; if (useAndroidTheme) &#123; // First try reading android:theme if enabled themeId = a.getResourceId(R.styleable.View_android_theme, 0); &#125; if (useAppTheme &amp;&amp; themeId == 0) &#123; // ...if that didn't work, try reading app:theme (for legacy reasons) if enabled themeId = a.getResourceId(R.styleable.View_theme, 0); if (themeId != 0) &#123; Log.i(LOG_TAG, "app:theme is now deprecated. " + "Please move to using android:theme instead."); &#125; &#125; a.recycle(); if (themeId != 0 &amp;&amp; (!(context instanceof ContextThemeWrapper) || ((ContextThemeWrapper) context).getThemeResId() != themeId)) &#123; // If the context isn't a ContextThemeWrapper, or it is but does not have // the same theme as we need, wrap it in a new wrapper context = new ContextThemeWrapper(context, themeId); &#125; return context; &#125; /** * An implementation of OnClickListener that attempts to lazily load a * named click handling method from a parent or ancestor context. */ private static class DeclaredOnClickListener implements View.OnClickListener &#123; private final View mHostView; private final String mMethodName; private Method mResolvedMethod; private Context mResolvedContext; public DeclaredOnClickListener(@NonNull View hostView, @NonNull String methodName) &#123; mHostView = hostView; mMethodName = methodName; &#125; @Override public void onClick(@NonNull View v) &#123; if (mResolvedMethod == null) &#123; resolveMethod(mHostView.getContext(), mMethodName); &#125; try &#123; mResolvedMethod.invoke(mResolvedContext, v); &#125; catch (IllegalAccessException e) &#123; throw new IllegalStateException( "Could not execute non-public method for android:onClick", e); &#125; catch (InvocationTargetException e) &#123; throw new IllegalStateException( "Could not execute method for android:onClick", e); &#125; &#125; @NonNull private void resolveMethod(@Nullable Context context, @NonNull String name) &#123; while (context != null) &#123; try &#123; if (!context.isRestricted()) &#123; final Method method = context.getClass().getMethod(mMethodName, View.class); if (method != null) &#123; mResolvedMethod = method; mResolvedContext = context; return; &#125; &#125; &#125; catch (NoSuchMethodException e) &#123; // Failed to find method, keep searching up the hierarchy. &#125; if (context instanceof ContextWrapper) &#123; context = ((ContextWrapper) context).getBaseContext(); &#125; else &#123; // Can't search up the hierarchy, null out and fail. context = null; &#125; &#125; final int id = mHostView.getId(); final String idText = id == View.NO_ID ? "" : " with id '" + mHostView.getContext().getResources().getResourceEntryName(id) + "'"; throw new IllegalStateException("Could not find method " + mMethodName + "(View) in a parent or ancestor Context for android:onClick " + "attribute defined on view " + mHostView.getClass() + idText); &#125; &#125;&#125; 这样就达到了将以前的TextView等转换为相关的AppCompat控件，达到兼容。 setContentView()源码流程就分析到这里,细看请自行查看源码。]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android LayoutInflater.inflate()源码流程分析]]></title>
    <url>%2FAndroid%20LayoutInflater.inflate()%E6%BA%90%E7%A0%81%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.html</url>
    <content type="text"><![CDATA[我们在根据layout文件得到View的时候都会使用LayoutInflater.from(mContext).inflate().下面我们来分析这个获取View流程。 我们知道inflate有如下函数:123inflate(@LayoutRes int resource, @Nullable ViewGroup root);inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot);inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot); 其实点进去查看可以知道，其实都到了这个方法:1inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot); 源码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125/** * Inflate a new view hierarchy from the specified XML node. Throws * &#123;@link InflateException&#125; if there is an error. * &lt;p&gt; * &lt;em&gt;&lt;strong&gt;Important&lt;/strong&gt;&lt;/em&gt; For performance * reasons, view inflation relies heavily on pre-processing of XML files * that is done at build time. Therefore, it is not currently possible to * use LayoutInflater with an XmlPullParser over a plain XML file at runtime. * * @param parser XML dom node containing the description of the view * hierarchy. * @param root Optional view to be the parent of the generated hierarchy (if * &lt;em&gt;attachToRoot&lt;/em&gt; is true), or else simply an object that * provides a set of LayoutParams values for root of the returned * hierarchy (if &lt;em&gt;attachToRoot&lt;/em&gt; is false.) * @param attachToRoot Whether the inflated hierarchy should be attached to * the root parameter? If false, root is only used to create the * correct subclass of LayoutParams for the root view in the XML. * @return The root View of the inflated hierarchy. If root was supplied and * attachToRoot is true, this is root; otherwise it is the root of * the inflated XML file. */ public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123; synchronized (mConstructorArgs) &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, "inflate"); final Context inflaterContext = mContext; final AttributeSet attrs = Xml.asAttributeSet(parser); Context lastContext = (Context) mConstructorArgs[0]; mConstructorArgs[0] = inflaterContext; View result = root; try &#123; // Look for the root node. int type; while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; // Empty &#125; if (type != XmlPullParser.START_TAG) &#123; throw new InflateException(parser.getPositionDescription() + ": No start tag found!"); &#125; final String name = parser.getName(); if (DEBUG) &#123; System.out.println("**************************"); System.out.println("Creating root view: " + name); System.out.println("**************************"); &#125; if (TAG_MERGE.equals(name)) &#123; if (root == null || !attachToRoot) &#123; throw new InflateException("&lt;merge /&gt; can be used only with a valid " + "ViewGroup root and attachToRoot=true"); &#125; rInflate(parser, root, inflaterContext, attrs, false); &#125; else &#123; // Temp is the root view that was found in the xml final View temp = createViewFromTag(root, name, inflaterContext, attrs); ViewGroup.LayoutParams params = null; if (root != null) &#123; if (DEBUG) &#123; System.out.println("Creating params from root: " + root); &#125; // Create layout params that match root, if supplied params = root.generateLayoutParams(attrs); if (!attachToRoot) &#123; // Set the layout params for temp if we are not // attaching. (If we are, we use addView, below) temp.setLayoutParams(params); &#125; &#125; if (DEBUG) &#123; System.out.println("-----&gt; start inflating children"); &#125; // Inflate all children under temp against its context. rInflateChildren(parser, temp, attrs, true); if (DEBUG) &#123; System.out.println("-----&gt; done inflating children"); &#125; // We are supposed to attach all the views we found (int temp) // to root. Do that now. if (root != null &amp;&amp; attachToRoot) &#123; root.addView(temp, params); &#125; // Decide whether to return the root that was passed in or the // top view found in xml. if (root == null || !attachToRoot) &#123; result = temp; &#125; &#125; &#125; catch (XmlPullParserException e) &#123; final InflateException ie = new InflateException(e.getMessage(), e); ie.setStackTrace(EMPTY_STACK_TRACE); throw ie; &#125; catch (Exception e) &#123; final InflateException ie = new InflateException(parser.getPositionDescription() + ": " + e.getMessage(), e); ie.setStackTrace(EMPTY_STACK_TRACE); throw ie; &#125; finally &#123; // Don't retain static reference on context. mConstructorArgs[0] = lastContext; mConstructorArgs[1] = null; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; return result; &#125; &#125; 其实就是通过XmlPullParser来解析layout.xml布局在这里通过判断，如果是merge标签就会执行如下方法:12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Recursive method used to descend down the xml hierarchy and instantiate * views, instantiate their children, and then call onFinishInflate(). * &lt;p&gt; * &lt;strong&gt;Note:&lt;/strong&gt; Default visibility so the BridgeInflater can * override it. */ void rInflate(XmlPullParser parser, View parent, Context context, AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException &#123; final int depth = parser.getDepth(); int type; while (((type = parser.next()) != XmlPullParser.END_TAG || parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123; if (type != XmlPullParser.START_TAG) &#123; continue; &#125; final String name = parser.getName(); if (TAG_REQUEST_FOCUS.equals(name)) &#123; parseRequestFocus(parser, parent); &#125; else if (TAG_TAG.equals(name)) &#123; parseViewTag(parser, parent, attrs); &#125; else if (TAG_INCLUDE.equals(name)) &#123; if (parser.getDepth() == 0) &#123; throw new InflateException("&lt;include /&gt; cannot be the root element"); &#125; parseInclude(parser, context, parent, attrs); &#125; else if (TAG_MERGE.equals(name)) &#123; throw new InflateException("&lt;merge /&gt; must be the root element"); &#125; else &#123; final View view = createViewFromTag(parent, name, context, attrs); final ViewGroup viewGroup = (ViewGroup) parent; final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs); rInflateChildren(parser, view, attrs, true); viewGroup.addView(view, params); &#125; &#125; if (finishInflate) &#123; parent.onFinishInflate(); &#125; &#125; 我这主要讲根据layout.xml获取里面的View流程，这些不同的标签不同的解析方式,在这不进行细讲，有趣的可以自行查看源码。在这我们重点看createViewFromTag函数，因为在如果layout开始标签不是merge的话也会调用这个函数创建View,可以发现最终进入：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * Creates a view from a tag name using the supplied attribute set. * &lt;p&gt; * &lt;strong&gt;Note:&lt;/strong&gt; Default visibility so the BridgeInflater can * override it. * * @param parent the parent view, used to inflate layout params * @param name the name of the XML tag used to define the view * @param context the inflation context for the view, typically the * &#123;@code parent&#125; or base layout inflater context * @param attrs the attribute set for the XML tag used to define the view * @param ignoreThemeAttr &#123;@code true&#125; to ignore the &#123;@code android:theme&#125; * attribute (if set) for the view being inflated, * &#123;@code false&#125; otherwise */ View createViewFromTag(View parent, String name, Context context, AttributeSet attrs, boolean ignoreThemeAttr) &#123; if (name.equals("view")) &#123; name = attrs.getAttributeValue(null, "class"); &#125; // Apply a theme wrapper, if allowed and one is specified. if (!ignoreThemeAttr) &#123; final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME); final int themeResId = ta.getResourceId(0, 0); if (themeResId != 0) &#123; context = new ContextThemeWrapper(context, themeResId); &#125; ta.recycle(); &#125; if (name.equals(TAG_1995)) &#123; // Let's party like it's 1995! return new BlinkLayout(context, attrs); &#125; try &#123; View view; if (mFactory2 != null) &#123; view = mFactory2.onCreateView(parent, name, context, attrs); &#125; else if (mFactory != null) &#123; view = mFactory.onCreateView(name, context, attrs); &#125; else &#123; view = null; &#125; if (view == null &amp;&amp; mPrivateFactory != null) &#123; view = mPrivateFactory.onCreateView(parent, name, context, attrs); &#125; if (view == null) &#123; final Object lastContext = mConstructorArgs[0]; mConstructorArgs[0] = context; try &#123; if (-1 == name.indexOf('.')) &#123; view = onCreateView(parent, name, attrs); &#125; else &#123; view = createView(name, null, attrs); &#125; &#125; finally &#123; mConstructorArgs[0] = lastContext; &#125; &#125; return view; &#125; catch (InflateException e) &#123; throw e; &#125; catch (ClassNotFoundException e) &#123; final InflateException ie = new InflateException(attrs.getPositionDescription() + ": Error inflating class " + name, e); ie.setStackTrace(EMPTY_STACK_TRACE); throw ie; &#125; catch (Exception e) &#123; final InflateException ie = new InflateException(attrs.getPositionDescription() + ": Error inflating class " + name, e); ie.setStackTrace(EMPTY_STACK_TRACE); throw ie; &#125; &#125; 通过这段函数可以知道到View是在这里创建的:12345678910111213141516171819202122232425262728View view;if (mFactory2 != null) &#123; view = mFactory2.onCreateView(parent, name, context, attrs);&#125; else if (mFactory != null) &#123; view = mFactory.onCreateView(name, context, attrs);&#125; else &#123; view = null;&#125;if (view == null &amp;&amp; mPrivateFactory != null) &#123; view = mPrivateFactory.onCreateView(parent, name, context, attrs);&#125;if (view == null) &#123; final Object lastContext = mConstructorArgs[0]; mConstructorArgs[0] = context; try &#123; if (-1 == name.indexOf('.')) &#123; view = onCreateView(parent, name, attrs); &#125; else &#123; view = createView(name, null, attrs); &#125; &#125; finally &#123; mConstructorArgs[0] = lastContext; &#125;&#125;return view; 可以发现View创建经过了实际是由mFactory2–&gt;Factory–&gt;mPrivateFactory的判断才进入到了onCreateView方法，在这里我们就可以知道，如果我们要拦截View的创建，我们就可以给LayoutInflater设置一个我们自定义的一个Factory即可，并且创建View的规则我们在自己的Factory类中实现即可。具体的实现方式点此查看,我们继续看onCreateView(parent, name, attrs);如果是-1 == name.indexOf(&#39;.&#39;)的，即不是自定义的View将会执行:1createView(name, "android.view.", attrs); 是自定义的则是:1view = createView(name, null, attrs); createView(String name, String prefix, AttributeSet attrs)函数如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/** * Low-level function for instantiating a view by name. This attempts to * instantiate a view class of the given &lt;var&gt;name&lt;/var&gt; found in this * LayoutInflater's ClassLoader. * * &lt;p&gt; * There are two things that can happen in an error case: either the * exception describing the error will be thrown, or a null will be * returned. You must deal with both possibilities -- the former will happen * the first time createView() is called for a class of a particular name, * the latter every time there-after for that class name. * * @param name The full name of the class to be instantiated. * @param attrs The XML attributes supplied for this instance. * * @return View The newly instantiated view, or null. */ public final View createView(String name, String prefix, AttributeSet attrs) throws ClassNotFoundException, InflateException &#123; Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name); if (constructor != null &amp;&amp; !verifyClassLoader(constructor)) &#123; constructor = null; sConstructorMap.remove(name); &#125; Class&lt;? extends View&gt; clazz = null; try &#123; Trace.traceBegin(Trace.TRACE_TAG_VIEW, name); if (constructor == null) &#123; // Class not found in the cache, see if it's real, and try to add it clazz = mContext.getClassLoader().loadClass( prefix != null ? (prefix + name) : name).asSubclass(View.class); if (mFilter != null &amp;&amp; clazz != null) &#123; boolean allowed = mFilter.onLoadClass(clazz); if (!allowed) &#123; failNotAllowed(name, prefix, attrs); &#125; &#125; constructor = clazz.getConstructor(mConstructorSignature); constructor.setAccessible(true); sConstructorMap.put(name, constructor); &#125; else &#123; // If we have a filter, apply it to cached constructor if (mFilter != null) &#123; // Have we seen this name before? Boolean allowedState = mFilterMap.get(name); if (allowedState == null) &#123; // New class -- remember whether it is allowed clazz = mContext.getClassLoader().loadClass( prefix != null ? (prefix + name) : name).asSubclass(View.class); boolean allowed = clazz != null &amp;&amp; mFilter.onLoadClass(clazz); mFilterMap.put(name, allowed); if (!allowed) &#123; failNotAllowed(name, prefix, attrs); &#125; &#125; else if (allowedState.equals(Boolean.FALSE)) &#123; failNotAllowed(name, prefix, attrs); &#125; &#125; &#125; Object[] args = mConstructorArgs; args[1] = attrs; final View view = constructor.newInstance(args); if (view instanceof ViewStub) &#123; // Use the same context when inflating ViewStub later. final ViewStub viewStub = (ViewStub) view; viewStub.setLayoutInflater(cloneInContext((Context) args[0])); &#125; return view; &#125; catch (NoSuchMethodException e) &#123; final InflateException ie = new InflateException(attrs.getPositionDescription() + ": Error inflating class " + (prefix != null ? (prefix + name) : name), e); ie.setStackTrace(EMPTY_STACK_TRACE); throw ie; &#125; catch (ClassCastException e) &#123; // If loaded class is not a View subclass final InflateException ie = new InflateException(attrs.getPositionDescription() + ": Class is not a View " + (prefix != null ? (prefix + name) : name), e); ie.setStackTrace(EMPTY_STACK_TRACE); throw ie; &#125; catch (ClassNotFoundException e) &#123; // If loadClass fails, we should propagate the exception. throw e; &#125; catch (Exception e) &#123; final InflateException ie = new InflateException( attrs.getPositionDescription() + ": Error inflating class " + (clazz == null ? "&lt;unknown&gt;" : clazz.getName()), e); ie.setStackTrace(EMPTY_STACK_TRACE); throw ie; &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125; &#125; 可以知道其实就是通过反射来进行View的创建,先在constructor缓存集合sConstructorMap里面查找对应的View的constructor进行初始化，如果没有就通过反射拿到constructor，然后缓存到sConstructorMap里面，创建View的时候是通过prefix拼接的,如果xml里面是TextView则拼接出来则是android.view.TextView,所以上面不是自定的View的话，执行的是createView(name, &quot;android.view.&quot;, attrs);，如果是自定义的话就不用拼接了。可以发现通过代码1234 constructor = clazz.getConstructor(mConstructorSignature);static final Class&lt;?&gt;[] mConstructorSignature = new Class[] &#123; Context.class, AttributeSet.class&#125;; 得知，最终创建View的构造方法是带有Context和AttributeSet参数的方法，这也就解析了我们在自定义一些View的时候，如果不重写这个带有这两个参数的方法的话将会崩溃的现象。 LayoutInflater.inflate()源码流程分析就到这里了。因为在这里读的是流程，所有很多细节的东西还是希望大家自己去源码中看看。]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android View的Touch事件分发]]></title>
    <url>%2FAndroid%20View%E7%9A%84Touch%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91.html</url>
    <content type="text"><![CDATA[事件分发的重要性我就不多说了，我们先从简到难。先看View的Touch事件分发,我自定义一个View，重写OnTouchEvent函数，然后分别设置OnTouchListener和OnClick： ACTION_DOWN = 0 ACTION_UP=1 ACTION_MOVE=2我们我们按下这个View点击一下: 可以发现执行的顺序是:OnTouchListener.DOWN -&gt; OnTouchEvent.DOWN -&gt; OnTouchListener.MOVE -&gt; OnTouchEvent.MOVE -&gt; OnTouchListener.UP-&gt; OnTouchEvent.UP-&gt; OnClickListener从这我们就可以猜想执行的优先级为OnTouchListener &gt; onTouchEvent &gt; onClick接下来我们验证这个猜想，我们把OnTouchListener的onTouch返回值改为true我在点击一下，这里大胆猜想一下onTouchEvent和onClick不会执行了，看看执行的顺序 这时候执行的顺序如下:OnTouchListener.DOWN -&gt;OnTouchListener.MOVE-&gt; OnTouchListener.UP这里验证了我的猜想，可以得到如下结论 View的Touch事件分发，OnToucherListener如果返回true的话，就说明把事件从OnToucherListener这里拦截了，后续的onTouchEvent和onClick就收不到事件了。 接下来我们把OnTouchListener的onTouch返回值改为false,让它不拦截事件，把onTouchEvent返回值改为true 我们点击一下,猜想是OnTouchListener和onTouchEvent能够接收到事件，onClick将不会触发 和我们想的一致，这时候执行顺序变为:OnTouchListener.DOWN -&gt;OnTouchEvent.DOWN-&gt; OnTouchListener.MOVE -&gt; OnTouchEvent.MOVE-&gt;OnTouchListener.UP -&gt;OnTouchEvent.UP这里我们就可能得到结论 View的Touch事件分发，如果OnToucherListener返回false，onTouchEvent返回true，就说明把事件从onTouchEvent这里拦截了，onClick就不会触发。 通过上面两个结论我们验证了我们的优先级猜想 View的Touch事件分发，执行的优先级为OnTouchListener &gt; onTouchEvent &gt; onClick，如果前两个任意一个地方返回true，那么后续将不会收到事件。 接下来我们从源码的角度分析,首先我们需要知道，你点击或者或者触摸任何一个View 都会调用 dispatchTouchEvent()函数，我们就从这里开始分析源码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * Pass the touch screen motion event down to the target view, or this * view if it is the target. * * @param event The motion event to be dispatched. * @return True if the event was handled by the view, false otherwise. */ public boolean dispatchTouchEvent(MotionEvent event) &#123; // If the event should be handled by accessibility focus first. if (event.isTargetAccessibilityFocus()) &#123; // We don't have focus or no virtual descendant has it, do not handle the event. if (!isAccessibilityFocusedViewOrHost()) &#123; return false; &#125; // We have focus and got the event, then use normal event dispatch. event.setTargetAccessibilityFocus(false); &#125; boolean result = false; if (mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onTouchEvent(event, 0); &#125; final int actionMasked = event.getActionMasked(); if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Defensive cleanup for new gesture stopNestedScroll(); &#125; if (onFilterTouchEventForSecurity(event)) &#123; if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123; result = true; &#125; //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125; &#125; if (!result &amp;&amp; mInputEventConsistencyVerifier != null) &#123; mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); &#125; // Clean up after nested scrolls if this is the end of a gesture; // also cancel it if we tried an ACTION_DOWN but we didn't want the rest // of the gesture. if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123; stopNestedScroll(); &#125; return result; &#125; 我们先要知道ListenerInfo这个是做什么的？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748static class ListenerInfo &#123; /** * Listener used to dispatch focus change events. * This field should be made private, so it is hidden from the SDK. * &#123;@hide&#125; */ protected OnFocusChangeListener mOnFocusChangeListener; /** * Listeners for layout change events. */ private ArrayList&lt;OnLayoutChangeListener&gt; mOnLayoutChangeListeners; protected OnScrollChangeListener mOnScrollChangeListener; /** * Listeners for attach events. */ private CopyOnWriteArrayList&lt;OnAttachStateChangeListener&gt; mOnAttachStateChangeListeners; /** * Listener used to dispatch click events. * This field should be made private, so it is hidden from the SDK. * &#123;@hide&#125; */ public OnClickListener mOnClickListener; /** * Listener used to dispatch long click events. * This field should be made private, so it is hidden from the SDK. * &#123;@hide&#125; */ protected OnLongClickListener mOnLongClickListener; /** * Listener used to dispatch context click events. This field should be made private, so it * is hidden from the SDK. * &#123;@hide&#125; */ protected OnContextClickListener mOnContextClickListener; /** * Listener used to build the context menu. * This field should be made private, so it is hidden from the SDK. * &#123;@hide&#125; */ protected OnCreateContextMenuListener mOnCreateContextMenuListener; private OnKeyListener mOnKeyListener; private OnTouchListener mOnTouchListener; private OnHoverListener mOnHoverListener; private OnGenericMotionListener mOnGenericMotionListener; private OnDragListener mOnDragListener; private OnSystemUiVisibilityChangeListener mOnSystemUiVisibilityChangeListener; OnApplyWindowInsetsListener mOnApplyWindowInsetsListener; &#125; 这是一个view所有事件的集合类。接下来进入这段代码,12345678910ListenerInfo li = mListenerInfo;if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true;&#125;if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true;&#125; 从这段代码我们就可以知道如果mOnTouchListener !=null并且当前view的是enable=true就会执行li.mOnTouchListener.onTouch(this, event),执行li.mOnTouchListener.onTouch(this, event)返回的false的话就会执行onTouchEvent(event)。从这我们就可以知道OnTouchListener的优先级大于onTouchEvent。接着我们点击onTouchEvent进入123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114public boolean onTouchEvent(MotionEvent event) &#123; //......代码太长 省略 switch (action) &#123; case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123; // take focus if we don't have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123; focusTaken = requestFocus(); &#125; if (prepressed) &#123; // The button is being released before we actually // showed it as pressed. Make it show the pressed // state now (before scheduling the click) to ensure // the user sees it. setPressed(true, x, y); &#125; if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123; // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) &#123; // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; performClick(); &#125; &#125; &#125; if (mUnsetPressedState == null) &#123; mUnsetPressedState = new UnsetPressedState(); &#125; if (prepressed) &#123; postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); &#125; else if (!post(mUnsetPressedState)) &#123; // If the post failed, unpress right now mUnsetPressedState.run(); &#125; removeTapCallback(); &#125; mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_DOWN: mHasPerformedLongPress = false; if (performButtonActionOnTouchDown(event)) &#123; break; &#125; // Walk up the hierarchy to determine if we're inside a scrolling container. boolean isInScrollingContainer = isInScrollingContainer(); // For views inside a scrolling container, delay the pressed feedback for // a short period in case this is a scroll. if (isInScrollingContainer) &#123; mPrivateFlags |= PFLAG_PREPRESSED; if (mPendingCheckForTap == null) &#123; mPendingCheckForTap = new CheckForTap(); &#125; mPendingCheckForTap.x = event.getX(); mPendingCheckForTap.y = event.getY(); postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); &#125; else &#123; // Not inside a scrolling container, so show the feedback right away setPressed(true, x, y); checkForLongClick(0, x, y); &#125; break; case MotionEvent.ACTION_CANCEL: setPressed(false); removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_MOVE: drawableHotspotChanged(x, y); // Be lenient about moving outside of buttons if (!pointInView(x, y, mTouchSlop)) &#123; // Outside button removeTapCallback(); if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123; // Remove any future long press/tap checks removeLongPressCallback(); setPressed(false); &#125; &#125; break; &#125; return true; &#125; return false; &#125; 可以看到，我们在MotionEvent.ACTION_UP事件里面，经过一系列的判断，然后进入到了performClick()这个函数12345678910111213141516171819202122/** * Call this view's OnClickListener, if it is defined. Performs all normal * actions associated with clicking: reporting accessibility event, playing * a sound, etc. * * @return True there was an assigned OnClickListener that was called, false * otherwise is returned. */ public boolean performClick() &#123; final boolean result; final ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this); result = true; &#125; else &#123; result = false; &#125; sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); return result; &#125; 这个函数很明显的就知道是执行onClick,从这就可以得到如下结论 onClick事件是在onTouchEvent的MotionEvent.ACTION_UP事件通过performClick()-&gt;li.mOnClickListener.onClick(this)触发的。 到这里我们就验证了我们刚才的优先级的结论。当然在onTouchEvent(MotionEvent event源码中，我们在MotionEvent.ACTION_DOWN里面可以看到长按事件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 case MotionEvent.ACTION_DOWN: //... checkForLongClick(0, x, y); break;//检测长按事件private void checkForLongClick(int delayOffset, float x, float y) &#123; if ((mViewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) &#123; mHasPerformedLongPress = false; if (mPendingCheckForLongPress == null) &#123; mPendingCheckForLongPress = new CheckForLongPress(); &#125; mPendingCheckForLongPress.setAnchor(x, y); mPendingCheckForLongPress.rememberWindowAttachCount(); postDelayed(mPendingCheckForLongPress, ViewConfiguration.getLongPressTimeout() - delayOffset); &#125; &#125; private final class CheckForLongPress implements Runnable &#123; private int mOriginalWindowAttachCount; private float mX; private float mY; @Override public void run() &#123; if (isPressed() &amp;&amp; (mParent != null) &amp;&amp; mOriginalWindowAttachCount == mWindowAttachCount) &#123; //触发长按事件 if (performLongClick(mX, mY)) &#123; mHasPerformedLongPress = true; &#125; &#125; &#125; public void setAnchor(float x, float y) &#123; mX = x; mY = y; &#125; public void rememberWindowAttachCount() &#123; mOriginalWindowAttachCount = mWindowAttachCount; &#125; &#125;public boolean performLongClick(float x, float y) &#123; mLongClickX = x; mLongClickY = y; final boolean handled = performLongClick(); mLongClickX = Float.NaN; mLongClickY = Float.NaN; return handled; &#125;public boolean performLongClick() &#123; return performLongClickInternal(mLongClickX, mLongClickY); &#125; private boolean performLongClickInternal(float x, float y) &#123; sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_LONG_CLICKED); boolean handled = false; final ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnLongClickListener != null) &#123; handled = li.mOnLongClickListener.onLongClick(View.this); &#125; if (!handled) &#123; final boolean isAnchored = !Float.isNaN(x) &amp;&amp; !Float.isNaN(y); handled = isAnchored ? showContextMenu(x, y) : showContextMenu(); &#125; if (handled) &#123; performHapticFeedback(HapticFeedbackConstants.LONG_PRESS); &#125; return handled; &#125; 从这段代码我们又可以得到如下结论 View的OnLongClickListener是在onTouchEvent的MotionEvent.ACTION_DOWN事件通过checkForLongClick() -&gt;performLongClick(mX, mY)-&gt;performLongClick() -&gt;performLongClickInternal(mLongClickX, mLongClickY) -&gt;li.mOnLongClickListener.onLongClick(View.this)的执行顺序触发的。 这样View的OnTouch事件分发机制就分析得差不多，具体的判断细节等还是需要自己查看源码。 参考链接：http://www.jianshu.com/p/98d1895c409dhttp://www.jianshu.com/p/e99b5e8bd67b]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>源码</tag>
        <tag>分发机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android ViewGroup事件分发]]></title>
    <url>%2FAndroid%20ViewGroup%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91.html</url>
    <content type="text"><![CDATA[上篇文章已经分析了Android的Touch事件分发。如果没看的建议先看一下。Android View的Touch事件分发。接下来我们开始写几种场景，得出一个初步的执行顺序，然后我们按照这个顺序开始分析。 首先我们自定义一个ViewGroup和一个View，然后重写相关事件进行打印: 场景一:正常返回super，TouchView设置click和onTouchListener事件(onTouch返回false) 这时候我们点击一下TouchView，触发事件: 可以看到触发的DOWN MOVE UP事件顺序都为:ViewGroup.dispatchTouchEvent -&gt; ViewGroup.onInterceptTouchEvent -&gt; View.dispatchTouchEvent -&gt; View.onTouch -&gt; View.onTouchEven只是在UP事件的时候最后多了一个click事件。 场景二：在场景一的基础上取消TouchView的onClick事件 这时候发现除了，执行的顺序变为了：ViewGroup.dispatchTouchEvent -&gt; ViewGroup.onInterceptTouchEvent -&gt; View.dispatchTouchEvent -&gt; View.onTouch -&gt; View.onTouchEven-&gt;ViewGroup.onTouchEven并且只有DOWN事件，其他事件就没有了。 场景三:在场景二的基础上TouchViewGroup的onInterceptTouchEvent里面返回true 这个时候就只有DOWN事件，并且顺序为:ViewGroup.dispatchTouchEvent -&gt; ViewGroup.onInterceptTouchEvent -&gt; ViewGroup.onTouchEvent 接下来我们通过源码来分析:首先从ViewGroup的dispatchTouchEvent入手123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116 @Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; //... boolean handled = false; //... //1.取消之前的手势 // Handle an initial down. if (actionMasked == MotionEvent.ACTION_DOWN) &#123; // Throw away all previous state when starting a new touch gesture. // The framework may have dropped the up or cancel event for the previous gesture // due to an app switch, ANR, or some other state change. cancelAndClearTouchTargets(ev); resetTouchState(); &#125; //2.判断是否拦截 // Check for interception. final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) &#123; //DOWN //父类是否拦截 getParent().requestDisallowInterceptTouchEvent();来改变值 final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125; &#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true; &#125; //.... //3.0 如果是不取消不拦截为down，并且dispatchTransformedTouchEvent返回为true的时候会为 mFirstTouchTarget赋值 // Check for cancelation. final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; // Update list of touch targets for pointer down, if needed. final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0; TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; //3.1 如果不取消并且不拦截的情况下， if (!canceled &amp;&amp; !intercepted) &#123; if (actionMasked == MotionEvent.ACTION_DOWN || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;// 3.2 DOWN的时候 //... if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123; //... final View[] children = mChildren; for (int i = childrenCount - 1; i &gt;= 0; i--) &#123;//3.3 反序for循环，为了先拿到上层的view //... //3.4 拿到child final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex); //... //3.5 根据child给newTouchTarget赋值 DOWN的时候因为 mFirstTouchTarget==null 所以进不去 返回的是null newTouchTarget = getTouchTarget(child); &#125; //... //3.6. 执行操作 是执行自己的dispatchTouchEvent还是child的dispatchTouchEvent if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; //... //3.7 子View如果返回true添加一个newTouchTarget 并且为mFirstTouchTarget赋值 newTouchTarget = addTouchTarget(child, idBitsToAssign); //.... &#125; &#125; &#125; &#125;//... // Dispatch to touch targets. if (mFirstTouchTarget == null) &#123;//执行自身的dispatchTouchEvent // No touch targets so treat this as an ordinary view. handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); &#125; else &#123;// mFirstTouchTarget已经赋值 // Dispatch to touch targets, excluding the new touch target if we already // dispatched to it. Cancel touch targets if necessary. TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) &#123; final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;//执行完3.7操作的 handled = true; &#125; else &#123; final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) &#123; handled = true; &#125; if (cancelChild) &#123; if (predecessor == null) &#123; mFirstTouchTarget = next; &#125; else &#123; predecessor.next = next; &#125; target.recycle(); target = next; continue; &#125; &#125; predecessor = target; target = next; &#125; &#125; return handled; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/** * Cancels and clears all touch targets. */ private void cancelAndClearTouchTargets(MotionEvent event) &#123; if (mFirstTouchTarget != null) &#123; boolean syntheticEvent = false; if (event == null) &#123; final long now = SystemClock.uptimeMillis(); event = MotionEvent.obtain(now, now, MotionEvent.ACTION_CANCEL, 0.0f, 0.0f, 0); event.setSource(InputDevice.SOURCE_TOUCHSCREEN); syntheticEvent = true; &#125; for (TouchTarget target = mFirstTouchTarget; target != null; target = target.next) &#123; resetCancelNextUpFlag(target.child); dispatchTransformedTouchEvent(event, true, target.child, target.pointerIdBits); &#125; clearTouchTargets(); if (syntheticEvent) &#123; event.recycle(); &#125; &#125; &#125; //清楚所有的TouchTarget /** * Clears all touch targets. */ private void clearTouchTargets() &#123; TouchTarget target = mFirstTouchTarget; if (target != null) &#123; do &#123; TouchTarget next = target.next; target.recycle(); target = next; &#125; while (target != null); mFirstTouchTarget = null; &#125; &#125; //根据childVie得到TouchTarget /** * Gets the touch target for specified child view. * Returns null if not found. */ private TouchTarget getTouchTarget(@NonNull View child) &#123; // DOWN的时候因为 mFirstTouchTarget==null 所以进不去 返回的是null for (TouchTarget target = mFirstTouchTarget; target != null; target = target.next) &#123; if (target.child == child) &#123; return target; &#125; &#125; return null; &#125; /** * Transforms a motion event into the coordinate space of a particular child view, * filters out irrelevant pointer ids, and overrides its action if necessary. * If child is null, assumes the MotionEvent will be sent to this ViewGroup instead. */ private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) &#123; //伪代码 final boolean handled; if (child == null) &#123;//执行View.dispatchTouchEvent 也就是自己的dispatchTouchEvent handled = super.dispatchTouchEvent(event); &#125; else &#123;//执行child的dispatchTouchEvent handled = child.dispatchTouchEvent(event); &#125; return handled; &#125; //添加TouchTarget 并且给mFirstTouchTarget赋值 /** * Adds a touch target for specified child to the beginning of the list. * Assumes the target child is not already present. */ private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) &#123; final TouchTarget target = TouchTarget.obtain(child, pointerIdBits); target.next = mFirstTouchTarget; mFirstTouchTarget = target; return target; &#125; 当DOWN的时候，从注释和方法名可以看出，会调用cancelAndClearTouchTargets,然后在调用clearTouchTargets使mFirstTouchTarget = null用来废弃上一次的触摸手势。 接着判断父类需不需要拦截，先通过(mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0来判断，在这里可以通过getParent().requestDisallowInterceptTouchEvent(boolean disallowIntercept)来改变值，如果上面为判断为false再通过onInterceptTouchEvent的返回值来确定,这个函数默认情况下返回false。 检测是否为取消事件，如果不是取消、不拦截并且为 DOWN事件的时候，就会对childView一个反序的for循环来遍历，并且执行dispatchTransformedTouchEvent操作，这个操作用来执行dispatchTouchEvent,如果childView是null的话将执行View.dispatchTouchEvent,也就是自己的dispatchTouchEvent,反之执行childView的dispatchTouchEvent，如果执行dispatchTransformedTouchEvent返回的值是true那么将会调用addTouchTarget()为这个childView生成一个TouchTarget并且执行mFirstTouchTarget = target将之赋值于mFirstTouchTarget ，然后跳出for循环遍历，这个mFirstTouchTarget是用于判断后续的事件move up等事件是否进行拦截触发函数。 判断操作，首先判断mFirstTouchTarget是否为null,如果是DOWN事件，不拦截不取消并且dispatchTransformedTouchEvent返回了true，那么将会不进入这个判断，如果不是，那么将会在这执行自身的dispatchTouchEvent函数并且将返回值赋于handled返回。进入else语句，在里面将其mFirstTouchTarget进行next遍历,里面的if语句则是DOWN事件下的dispatchTransformedTouchEvent返回true的情况，直接将其赋值，然后返回，里面的else语句则是，调用dispatchTransformedTouchEvent,然后将其返回值返回。 到这里，ViewGroups事件分发源码的流程就分析了，我们根据这个来说说上面的场景。 场景一：我们在TouchViewGroup的dispatchTouchEvent正常返回super,DOWN事件先触发TouchViewGroup的dispatchTouchEvent，然后就执行onInterceptTouchEvent是否拦截，onInterceptTouchEvent返回的是super，也就是false,所以就会通过dispatchTransformedTouchEvent来执行TouchView的dispatchTouchEvent，后面就是View的Touch事件分发了，View流程将会按照dispatchTouchEvent-&gt;onTouchListener - &gt; onTouchEvent的顺序执行，因为设置了点击事件，所以在这里就返回了true,这个时候就会通过addTouchTarget()给mFirstTouchTarget赋值，下面就直接返回了true。然后在MOVE和UP事件的时候，也是首先执行dispatchTouchEvent，调用super然后调用onInterceptTouchEvent询问是否拦截，还是false,但是这里因为不是DOWN事件，所以就不会进入判断对其childView反遍历，因为在DOWN的时候mFirstTouchTarget赋值了，所以这时候进入第4步的else语句里面，这时候就对其遍历执行dispatchTransformedTouchEvent，也就是dispatchTouchEvent，然后将其返回。 场景2:我们取消了点击事件，那么在DOWN的时候就不会给mFirstTouchTarget赋值，这个时候将会进入第4步的if判断里面，直接调用dispatchTransformedTouchEvent,所以事件就不会有拦截，最终返回false，所以后续将不会接受到任何事件 场景3:我们在TouchViewGroup的时候是在onInterceptTouchEvent返回true，所以我们intercepted=true，这时候就不会给mFirstTouchTarget赋值，这个时候就调用自身的dispatchTransformedTouchEvent，同样的返回false，后续将不会接受到事件。 通过源码的角度我们也知道了为什么会这么执行，初步有点模糊，我们需要通过项目慢慢的来完善对它的认知。希望对大家有所帮助。 参考链接：http://www.jianshu.com/p/98d1895c409d http://www.jianshu.com/p/e99b5e8bd67b]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>源码</tag>
        <tag>分发机制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Handler源码分析]]></title>
    <url>%2FAndroid%20Handler%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</url>
    <content type="text"><![CDATA[Handler：主要用于将Message加入到队列MessageQueue中（按照时间排序）,Looper和MessageQueue中间的桥梁。 MessageQueue：Message消息队列。通过Handler加入新的Message,通过Looper循环不断调用next()拿出要消费的Message来触发Handler.dispatchMessage(msg)然后在回收消费的Message。 Looper ：通过ThreadLocal来保证每个线程只有一个Looper。通过Looper.prepare();和Looper.loop();来开启死循环不断取出要消费的Message。 如下图所示: Handler.sendMessage() --&gt;sendMessageDelyed()--&gt; MessageQueue.enqueueMessage() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException("Message must have a target."); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + " This message is already in use."); &#125; synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + " sending message to a Handler on a dead thread"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true; &#125; 如下图所示: Looper.loop():123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */ public static void loop() &#123; // 获取线程的 Looper 对象 final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; // 获取队列 final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; // 死循环不断的获取 消息队列中的消息 Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println("&gt;&gt;&gt;&gt;&gt; Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what); &#125; final long traceTag = me.mTraceTag; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; try &#123; // 通过 handler 去执行 Message 这个时候就调用了 handleMessage 方法 msg.target.dispatchMessage(msg); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logging != null) &#123; logging.println("&lt;&lt;&lt;&lt;&lt; Finished to " + msg.target + " " + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, "Thread identity changed from 0x" + Long.toHexString(ident) + " to 0x" + Long.toHexString(newIdent) + " while dispatching to " + msg.target.getClass().getName() + " " + msg.callback + " what=" + msg.what); &#125; // 回收消息 msg.recycleUnchecked(); &#125; &#125; 避免handler引起的内存泄漏问题：调用handler.removeCallbacksAndMessages(null)清空消息队列,在置handler为null。因为里面的Message被引用，所以handler只让它置为null是没有用的。 epoll唤醒分析: http://blog.csdn.net/ashqal/article/details/32107099]]></content>
      <categories>
        <category>源码分析</category>
      </categories>
      <tags>
        <tag>Handler</tag>
        <tag>android</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View（8） -- 汽车之家折叠列表]]></title>
    <url>%2F%E8%87%AA%E5%AE%9A%E4%B9%89View%EF%BC%888%EF%BC%89%20--%20%E6%B1%BD%E8%BD%A6%E4%B9%8B%E5%AE%B6%E6%8A%98%E5%8F%A0%E5%88%97%E8%A1%A8.html</url>
    <content type="text"><![CDATA[先看看汽车之家折叠列表的效果图 接着看看实现的效果图 在这篇文章中主要采用ViewDragHelper这个类，这个是系统提供的一个处理view拖动的一个类。具体请查看相关资料，在这就不多说。先来解析实现的思路，view的移动采用ViewDragHelper即可，如果下方是一般的View的话就差不多了，但是如果是ListView或者RecyclerView之类的话主要处理一个事件拦截的逻辑。首先要清楚ListView或者RecyclerView在处理事件的时候调用了getParent().requestDisallowInterceptTouchEvent(true);请求父布局不拦截事件，所以当拦截的时候不能让ListView或者RecyclerView接受到MOVE事件。逻辑很简单，就是当下面的ListView或者RecyclerView到顶部 并且是下拉的时候就需要使用ViewDragHelper来响应拖动，如果上面的菜单是打开状态的话那么也需要响应，这时候就需要拦截MOVE事件来处理拖动。逻辑就是这么简单，但是细节的东西有很多，不能马虎并且熟悉相关的api。 接下来开始撸码这里我选择继承FrameLayout,在初始化的时候创建ViewDragHelper，资源加载完毕了得到需要拖动的mDragView，在测量之后获取到最大拖动的距离，也就是上方菜单的高度,当手指抬起的时候判断是需要关闭还是打开1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class VerticalDragListView @JvmOverloads constructor(context: Context, attrs: AttributeSet? = null, @AttrRes defStyleAttr: Int = 0) : FrameLayout(context, attrs, defStyleAttr) &#123; private var mDragView: View? = null//拖动的view private var mMenuViewHeight: Int = 0 //拖动的view 高度 private var mMenuIsOpen: Boolean = false//是否打开 private var mViewDragHelper: ViewDragHelper? = null //拖动的辅助类 private val mCallback: ViewDragHelper.Callback = object : ViewDragHelper.Callback() &#123; //指定view是否可以拖动 override fun tryCaptureView(child: View, pointerId: Int): Boolean &#123; return mDragView == child &#125; //返回移动的距离 override fun clampViewPositionVertical(child: View?, top: Int, dy: Int): Int &#123; //滑动的范围只能是在menu的高度 var t: Int = top if (top &lt;= 0) t = 0 if (top &gt;= mMenuViewHeight) t = mMenuViewHeight return t &#125; //手松开的时候回调 打开还是关闭 override fun onViewReleased(releasedChild: View?, xvel: Float, yvel: Float) &#123; //打开菜单 if (mDragView!!.top &gt;= mMenuViewHeight / 2) &#123; mViewDragHelper?.settleCapturedViewAt(0, mMenuViewHeight) mMenuIsOpen = true &#125; else &#123;//关闭菜单 mViewDragHelper?.settleCapturedViewAt(0, 0) mMenuIsOpen = false &#125; invalidate() &#125; &#125; //响应滚动 override fun computeScroll() &#123; if (mViewDragHelper!!.continueSettling(true)) invalidate() &#125; init &#123; mViewDragHelper = ViewDragHelper.create(this, mCallback) &#125; override fun onFinishInflate() &#123; super.onFinishInflate() if (childCount != 2) throw RuntimeException("childCount只能包含两个子布局") mDragView = getChildAt(1) &#125; override fun onLayout(changed: Boolean, left: Int, top: Int, right: Int, bottom: Int) &#123; super.onLayout(changed, left, top, right, bottom) if (changed) mMenuViewHeight = getChildAt(0).measuredHeight &#125; override fun onTouchEvent(event: MotionEvent?): Boolean &#123; mViewDragHelper?.processTouchEvent(event) return true &#125;&#125; 在这需要注意一点，当手指松开判断打开或者关闭菜单需要调用invalidate()并且重写computeScroll()函数来响应。 如果下方的view不是ListView或者RecyclerView之类的话，到这就可以了，但是实际开发中，下方一般是这种，所以就需要按照上面说的处理事件拦截123456789101112131415161718192021222324252627282930313233343536373839404142434445 private var mDownY: Float = 0.0f override fun onInterceptTouchEvent(ev: MotionEvent?): Boolean &#123; // 菜单打开要拦截 if (mMenuIsOpen) &#123; return true &#125; // 向下滑动拦截，不让ListView或者RecyclerView做处理 // 谁拦截谁 父View拦截子View ，但是子 View 可以调这个方法 // requestDisallowInterceptTouchEvent 请求父View不要拦截，改变的其实就是 mGroupFlags 的值 when (ev!!.action) &#123; MotionEvent.ACTION_DOWN -&gt; &#123; mDownY = ev.y // 让 DragHelper 拿一个完整的事件 mViewDragHelper!!.processTouchEvent(ev) &#125; MotionEvent.ACTION_MOVE -&gt; &#123; val moveY = ev.y if (moveY - mDownY &gt; 0 &amp;&amp; !canChildScrollUp()) &#123; // 向下滑动 &amp;&amp; 滚动到了顶部，拦截不让ListView或者RecyclerView做处理 return true &#125; &#125; &#125; return super.onInterceptTouchEvent(ev) &#125;/** * @return Whether it is possible for the child view of this layout to * * scroll up. Override this if the child view is a custom view. */ fun canChildScrollUp(): Boolean &#123; if (android.os.Build.VERSION.SDK_INT &lt; 14) &#123; if (mDragView is AbsListView) &#123; val absListView = mDragView as AbsListView return absListView.childCount &gt; 0 &amp;&amp; (absListView.firstVisiblePosition &gt; 0 || absListView.getChildAt(0) .top &lt; absListView.paddingTop) &#125; else &#123; return ViewCompat.canScrollVertically(mDragView, -1) || mDragView!!.scrollY &gt; 0 &#125; &#125; else &#123; return ViewCompat.canScrollVertically(mDragView, -1) &#125; &#125; 这里需要注意，如果不在ACTION_DOWN的时候调用mViewDragHelper.processTouchEvent(ev)的话，那么ViewDragHelper将会报错，将不会触发拖动事件从字面意思都可以看出需要一个完整的事件，所以需要在ACTION_DOWN的时候调用ViewDragHelper.processTouchEvent(ev) 在一步步的分析之下，这个效果就慢慢的完成了。有了新需求的时候，在动手应该理清思路，然后想好使用相关的api，处理一些手势可以使用OnGestureListener,处理拖动可以使用ViewDragHelper，这些都是系统封装好的辅助类，应该要合理的利用这些辅助类。相信如果不使用这些辅助类也可以写出这些效果，但是那样的话也会浪费大量的事件和精力，而且很容易出错。 本文源码下载地址：https://github.com/ChinaZeng/CustomView]]></content>
      <categories>
        <category>自定义view</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>自定义view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View（7） -- 酷狗侧滑菜单]]></title>
    <url>%2F%E8%87%AA%E5%AE%9A%E4%B9%89View%EF%BC%887%EF%BC%89%20--%20%E9%85%B7%E7%8B%97%E4%BE%A7%E6%BB%91%E8%8F%9C%E5%8D%95.html</url>
    <content type="text"><![CDATA[上一篇我们自定义了一个流式布局的ViewGroup,我们为了熟悉自定义ViewGroup,就继续自定义ViewGroup。这篇的内容是是仿照酷狗的侧滑菜单。我们写代码之前，先想清楚是怎么实现，解析实现的步骤。实现侧滑的方式很多种，在这里我选择继承HorizontalScrollView，为什么继承这个呢？因为继承这个的话，我们就不用写childView的move meause layout，这样就节约了很大的代码量和事件，因为内部HorizontalScrollView已经封装好了。我们在这个控件里面放置两个childView，一个是menu,一个是content。然后我们处理拦截和快速滑动事件就可以了。思路想清楚了我们就开始撸码。首先我们自定义一个属性，用于打开的时候content还有多少可以看到，也就是打开的时候menu距离右边的距离。123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;declare-styleable name="SkiddingMenuLayout"&gt; &lt;attr name="menuRightMargin" format="dimension"/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 在初始化的时候我们通过menuRightMargin属性获取menu真正的宽度123456789101112131415161718192021public SkiddingMenuLayout(Context context) &#123; this(context, null); &#125; public SkiddingMenuLayout(Context context, AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public SkiddingMenuLayout(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); // 初始化自定义属性 TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.SkiddingMenuLayout); float rightMargin = array.getDimension( R.styleable.SkiddingMenuLayout_menuRightMargin, DisplayUtil.dip2px(context, 50)); // 菜单页的宽度是 = 屏幕的宽度 - 右边的一小部分距离（自定义属性） mMenuWidth = (int) (DisplayUtil.getScreenWidth(context) - rightMargin); array.recycle(); &#125; 接着我们在布局加载完毕的时候我们指定menu和content的宽度12345678910111213141516171819202122232425//xml 布局解析完毕回调的方法 @Override protected void onFinishInflate() &#123; super.onFinishInflate(); //指定宽高 //先拿到整体容器 ViewGroup container = (ViewGroup) getChildAt(0); int childCount = container.getChildCount(); if (childCount != 2) throw new RuntimeException("只能放置两个子View"); //菜单 mMenuView = container.getChildAt(0); ViewGroup.LayoutParams meauParams = mMenuView.getLayoutParams(); meauParams.width = mMenuWidth; //7.0一下的不加这句代码是正常的 7.0以上的必须加 mMenuView.setLayoutParams(meauParams); //内容页 mContentView = container.getChildAt(1); ViewGroup.LayoutParams contentParams = mContentView.getLayoutParams(); contentParams.width = DisplayUtil.getScreenWidth(getContext()); //7.0一下的不加这句代码是正常的 7.0以上的必须加 mContentView.setLayoutParams(contentParams); &#125; 这里有一个细节，我们在刚进入的时候，菜单默认是关闭的，所以我们需要调用scrollTo()函数移动一下位置，但是发现在onFinishInflate()函数里面调用没有作用,这个是为什么呢？因为我们在xml加载完毕之后，才会真正的执行View的绘制流程，这时候调用scrollTo()这个函数其实是执行了代码的，但是在onLaout()摆放childView的时候，又默认回到了(0,0)位置，所以我们应该在onLayout()之后调用这个函数123456@Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; super.onLayout(changed, l, t, r, b); //进入是关闭状态 scrollTo(mMenuWidth, 0); &#125; 初始化完毕了，接下来我们进行事件的拦截，MOVE的时候相应滑动事件，UP的时候判断是关闭还是打开，然后调用函数即可12345678910111213141516171819202122232425262728293031323334//手指抬起是二选一，要么关闭要么打开 @Override public boolean onTouchEvent(MotionEvent ev) &#123; // 当菜单打开的时候，手指触摸右边内容部分需要关闭菜单，还需要拦截事件（打开情况下点击内容页不会响应点击事件） if (ev.getAction() == MotionEvent.ACTION_UP) &#123; // 只需要管手指抬起 ，根据我们当前滚动的距离来判断 int currentScrollX = getScrollX(); if (currentScrollX &gt; mMenuWidth / 2) &#123; // 关闭 closeMenu(); &#125; else &#123; // 打开 openMenu(); &#125; return true; &#125; return super.onTouchEvent(ev); &#125; /** * 打开菜单 滚动到 0 的位置 */ private void openMenu() &#123; // smoothScrollTo 有动画 smoothScrollTo(0, 0); &#125; /** * 关闭菜单 滚动到 mMenuWidth 的位置 */ private void closeMenu() &#123; smoothScrollTo(mMenuWidth, 0); &#125; 到这的话，滑动事件和打开关闭事件都完成了，接下来我们就处理一个效果的问题，这里当从左往右滑动的时候，是慢慢打开菜单，这时候content是有一个慢慢的缩放,menu有一个放大和透明度变小，而反过来关闭菜单的话就是相反的效果，content慢慢放大，menu缩小和透明度变大。这里还有一个细节，就是menu慢慢的退出和进入，滑动的距离不是和移动的距离相同的，所以这里还有一个平移。接下来重写onScrollChanged()函数，然后计算出一个梯度值来做处理12345678910111213141516171819202122232425262728293031323334353637 //滑动改变触发 @Override protected void onScrollChanged(int l, int t, int oldl, int oldt) &#123; super.onScrollChanged(l, t, oldl, oldt);// //抽屉效果 两种一样// ViewCompat.setTranslationX(mMenuView, l);// ViewCompat.setX(mMenuView, l);// Log.e("zzz", "l-&gt;" + l + " t-&gt;" + t + " oldl-&gt;" + oldl + " oldt-&gt;" + oldt); //主要看l 手指从左往右滑动 由大变小 //计算一个梯度值 1-&gt;0 float scale = 1.0f * l / mMenuWidth; //酷狗侧滑效果...// //右边的缩放 最小是0.7f ，最大是1.0f float rightScale = 0.7f + 0.3f * scale; //设置mContentView缩放的中心点位置 ViewCompat.setPivotX(mContentView, 0); ViewCompat.setPivotY(mContentView, mContentView.getHeight() / 2); //设置右边缩放 ViewCompat.setScaleX(mContentView, rightScale); ViewCompat.setScaleY(mContentView, rightScale); //菜单 //透明度是半透明到全透明 0.5f-1.0f float alpha = 0.5f + (1.0f - scale) * 0.5f; ViewCompat.setAlpha(mMenuView, alpha); //缩放 0.7-1.0 float leftScale = 0.7f + 0.3f * (1 - scale); ViewCompat.setScaleX(mMenuView, leftScale); ViewCompat.setScaleY(mMenuView, leftScale); //退出按钮在右边 ViewCompat.setTranslationX(mMenuView, 0.2f * l); &#125; 这样的话我们就完成了效果，但是我们还有几个细节没有处理，首先是快速滑动的问题，还有一个是当打开menu的时候，点击content需要关闭菜单，而不是相应对应的事件。接下来我们对这两个问题进行处理。 快速滑动问题，这个问题我们采用GestureDetector这个类来做处理，这个类可以处理很多收拾问题:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/** * The listener that is used to notify when gestures occur. * If you want to listen for all the different gestures then implement * this interface. If you only want to listen for a subset it might * be easier to extend &#123;@link SimpleOnGestureListener&#125;. */ public interface OnGestureListener &#123; /** * Notified when a tap occurs with the down &#123;@link MotionEvent&#125; * that triggered it. This will be triggered immediately for * every down event. All other events should be preceded by this. * * @param e The down motion event. */ boolean onDown(MotionEvent e); /** * The user has performed a down &#123;@link MotionEvent&#125; and not performed * a move or up yet. This event is commonly used to provide visual * feedback to the user to let them know that their action has been * recognized i.e. highlight an element. * * @param e The down motion event */ void onShowPress(MotionEvent e); /** * Notified when a tap occurs with the up &#123;@link MotionEvent&#125; * that triggered it. * * @param e The up motion event that completed the first tap * @return true if the event is consumed, else false */ boolean onSingleTapUp(MotionEvent e); /** * Notified when a scroll occurs with the initial on down &#123;@link MotionEvent&#125; and the * current move &#123;@link MotionEvent&#125;. The distance in x and y is also supplied for * convenience. * * @param e1 The first down motion event that started the scrolling. * @param e2 The move motion event that triggered the current onScroll. * @param distanceX The distance along the X axis that has been scrolled since the last * call to onScroll. This is NOT the distance between &#123;@code e1&#125; * and &#123;@code e2&#125;. * @param distanceY The distance along the Y axis that has been scrolled since the last * call to onScroll. This is NOT the distance between &#123;@code e1&#125; * and &#123;@code e2&#125;. * @return true if the event is consumed, else false */ boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY); /** * Notified when a long press occurs with the initial on down &#123;@link MotionEvent&#125; * that trigged it. * * @param e The initial on down motion event that started the longpress. */ void onLongPress(MotionEvent e); /** * Notified of a fling event when it occurs with the initial on down &#123;@link MotionEvent&#125; * and the matching up &#123;@link MotionEvent&#125;. The calculated velocity is supplied along * the x and y axis in pixels per second. * * @param e1 The first down motion event that started the fling. * @param e2 The move motion event that triggered the current onFling. * @param velocityX The velocity of this fling measured in pixels per second * along the x axis. * @param velocityY The velocity of this fling measured in pixels per second * along the y axis. * @return true if the event is consumed, else false */ boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY); &#125; /** * The listener that is used to notify when a double-tap or a confirmed * single-tap occur. */ public interface OnDoubleTapListener &#123; /** * Notified when a single-tap occurs. * &lt;p&gt; * Unlike &#123;@link OnGestureListener#onSingleTapUp(MotionEvent)&#125;, this * will only be called after the detector is confident that the user's * first tap is not followed by a second tap leading to a double-tap * gesture. * * @param e The down motion event of the single-tap. * @return true if the event is consumed, else false */ boolean onSingleTapConfirmed(MotionEvent e); /** * Notified when a double-tap occurs. * * @param e The down motion event of the first tap of the double-tap. * @return true if the event is consumed, else false */ boolean onDoubleTap(MotionEvent e); /** * Notified when an event within a double-tap gesture occurs, including * the down, move, and up events. * * @param e The motion event that occurred during the double-tap gesture. * @return true if the event is consumed, else false */ boolean onDoubleTapEvent(MotionEvent e); &#125; /** * The listener that is used to notify when a context click occurs. When listening for a * context click ensure that you call &#123;@link #onGenericMotionEvent(MotionEvent)&#125; in * &#123;@link View#onGenericMotionEvent(MotionEvent)&#125;. */ public interface OnContextClickListener &#123; /** * Notified when a context click occurs. * * @param e The motion event that occurred during the context click. * @return true if the event is consumed, else false */ boolean onContextClick(MotionEvent e); &#125; 这里我们主要是响应onFling()这个函数，然后判断当前是打开还是关闭状态，在根据快速滑动的手势来执行打开还是关闭的操作:12345678910111213141516171819202122232425262728293031 @Override public boolean onTouchEvent(MotionEvent ev) &#123; if (mGestureDetector.onTouchEvent(ev))//快速滑动触发了下面的就不要执行了 return true; //.... &#125;//快速滑动 private GestureDetector.OnGestureListener mOnGestureListener = new GestureDetector.SimpleOnGestureListener() &#123; @Override public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) &#123; //快速滑动回调 //打开的时候从右到左滑动关闭 关闭的时候从左往右打开// Log.e("zzz", "velocityX-&gt;" + velocityX); // &gt;0 从左往右边滑动 &lt;0 从右到左 if (mMenuIsOpen) &#123; if (velocityX &lt; 0) &#123; closeMenu(); return true; &#125; &#125; else &#123; if (velocityX &gt; 0) &#123; openMenu(); return true; &#125; &#125; return super.onFling(e1, e2, velocityX, velocityY); &#125; &#125;; 接下来处理menu打开状态下点击content关闭menu，这里我们需要用到onInterceptTouchEvent。当打开状态的时候，我们就把这个事件拦截，然后关闭菜单即可。但是这里有一个问题，当我们拦截了DOWN事件之后，后面的MOVE UP事件都会被拦截并且相应自身的onTouchEvent事件，所以这里我们需要添加一个判断值，判断是否拦截，然后让其onTouchEvent是否继续执行操作123456789101112131415161718@Override public boolean onInterceptTouchEvent(MotionEvent ev) &#123; isIntercept = false; if (mMenuIsOpen &amp;&amp; ev.getX() &gt; mMenuWidth) &#123;//打开状态 触摸右边关闭 isIntercept = true;//拦截的话就不执行自己的onTouchEvent closeMenu(); return true; &#125; return super.onInterceptTouchEvent(ev); &#125; @Override public boolean onTouchEvent(MotionEvent ev) &#123; if (isIntercept)//拦截的话就不执行自己的onTouchEvent return true; //...&#125; 根据我们提出需求，然后分析需求，再完成需求。这一步步我们慢慢进行渗透，最终完成效果，完成之后你会发现其实也就那么一回事。当我们有新需求的时候，我们应该不要恐惧，应该欣然乐观的接收，再慢慢分析，最终完成。这样的话我们才能提高我们的技术。 本文源码下载地址:https://github.com/ChinaZeng/CustomView]]></content>
      <categories>
        <category>自定义view</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>自定义view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View（6） -- 流式布局]]></title>
    <url>%2F%E8%87%AA%E5%AE%9A%E4%B9%89View%EF%BC%886%EF%BC%89%20--%20%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80.html</url>
    <content type="text"><![CDATA[先看效果图： 上几次都是自定义的view，这期我们来自定义一个简单的ViewGroup。和自定义view不同的是，viewGroup一般情况下是管理childView，所以主要是重写onMeause()来测量childView宽高，从而设置自身宽高，然后重写onLayout来摆放childView的位置，我们一般不对viewGroup进行绘制，如果特殊情况需要绘制，重写dispatchDraw()来进行重绘，因为viewGroup在不设置设置背景的情况下是不会调用onDraw()的，具体请看源码。 接下来进行我们这篇文章的主题，先理清楚思路，我们实现的效果就是一个容器里面的childView挨着挨着的从左往右摆放，如果摆放的时候这个childView的宽度加上这行前面的childView宽度大于当前设置的宽度的时候，那么就需要换行。初始化和属性我就不说了，如需要可以自行添加，这里我们要考略到childView的margin,所以我们仿照LinearLayout来重写generateLayoutParams函数来设置一个带有margin属性的LayoutParams12345// 设置自己需要的LayoutParams @Override public LayoutParams generateLayoutParams(AttributeSet attrs) &#123; return new MarginLayoutParams(getContext(), attrs); &#125; 重写onMeause()来进行childView的遍历测量，并且设置自生的宽高，因为我们考略到下面要重写onLayout来摆放childView的位置，难免会有一番计算，我们为了不重复计算，所以写了一个List来进行对childView以行为单位来组装，具体如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 private List&lt;List&lt;View&gt;&gt; mChildViews = new ArrayList&lt;&gt;(); // 指定宽高 @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); // 清空集合 mChildViews.clear(); int childCount = getChildCount(); // 获取到宽度 int width = MeasureSpec.getSize(widthMeasureSpec); // 高度需要计算 int height = getPaddingTop() + getPaddingBottom(); // 一行的宽度 int lineWidth = getPaddingLeft(); ArrayList&lt;View&gt; childViews = new ArrayList&lt;&gt;(); mChildViews.add(childViews); // 子View高度不一致的情况下 int maxHeight = 0; for (int i = 0; i &lt; childCount; i++) &#123; // for循环测量子View View childView = getChildAt(i); if (childView.getVisibility() == GONE) &#123; continue; &#125; // 这段话执行之后就可以获取子View的宽高，因为会调用子View的onMeasure measureChild(childView, widthMeasureSpec, heightMeasureSpec); // margin值 ViewGroup.LayoutParams 没有 就用系统的MarginLayoutParams // LinearLayout有自己的 LayoutParams 会复写一个非常重要的方法 MarginLayoutParams params = (MarginLayoutParams) childView.getLayoutParams(); // 什么时候需要换行，一行不够的情况下 考虑 margin if (lineWidth + (childView.getMeasuredWidth() + params.rightMargin + params.leftMargin) &gt; width) &#123; // 换行,累加高度 加上一行条目中最大的高度 height += maxHeight; //下面重新初始化 maxHeight = childView.getMeasuredHeight() + params.bottomMargin + params.topMargin; lineWidth = childView.getMeasuredWidth() + params.rightMargin + params.leftMargin; childViews = new ArrayList&lt;&gt;(); mChildViews.add(childViews); &#125; else &#123; lineWidth += childView.getMeasuredWidth() + params.rightMargin + params.leftMargin; maxHeight = Math.max(childView.getMeasuredHeight() + params.bottomMargin + params.topMargin, maxHeight); &#125; childViews.add(childView); &#125; height += maxHeight;//不要忘记最后一行的高度// Log.e(&quot;TAG&quot;, &quot;width -&gt; &quot; + width + &quot; height-&gt; &quot; + height); // 根据子View计算和指定自己的宽高 setMeasuredDimension(width, height); &#125; 然后我们根据上面的组装的List数据来进行对childView进行摆放12345678910111213141516171819202122232425262728 @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int left, top = getPaddingTop(), right, bottom; for (List&lt;View&gt; childViews : mChildViews) &#123; left = getPaddingLeft(); int maxHeight = 0; for (View childView : childViews) &#123; if (childView.getVisibility() == GONE) &#123; continue; &#125; MarginLayoutParams params = (MarginLayoutParams) childView.getLayoutParams(); left += params.leftMargin; int childTop = top + params.topMargin; right = left + childView.getMeasuredWidth(); bottom = childTop + childView.getMeasuredHeight();// Log.e("TAG", "left -&gt; " + left + " top-&gt; " + childTop + " right -&gt; " + right + " bottom-&gt; " + bottom); // 摆放 childView.layout(left, childTop, right, bottom); // left 叠加 left += childView.getMeasuredWidth() + params.rightMargin; // 不断的叠加top值 int childHeight = childView.getMeasuredHeight() + params.topMargin + params.bottomMargin; maxHeight = Math.max(maxHeight, childHeight); &#125; top += maxHeight; &#125; &#125; 主要的逻辑代码已经写的很清楚了，细致一看就能很容易的理解。这样的画效果就实现了，但是我们在实际开发的过程中，一般是后台获取到一个List数据，然后我们在设置值，这里推荐一个设计模式就是Adapter模式。这样的话我们就可以自定义自己的View，轻松的降低了代码的耦合，并且复用效果也好,我们申明一个`Adapter’类123456789101112131415/** * Email 240336124@qq.com * Created by Darren on 2017/6/11. * Version 1.0 * Description: 流式布局的Adapter */public abstract class BaseAdapter &#123; // 1.有多少个条目 public abstract int getCount(); // 2.getView通过position public abstract View getView(int position,ViewGroup parent);&#125; 这里就简单写了，然后我们在容器中添加setAdapter()函数1234567891011121314151617181920/** * 设置Adapter * * @param adapter */ public void setAdapter(BaseAdapter adapter) &#123; if (adapter == null) &#123; throw new NullPointerException("adapter is null"); &#125; // 清空所有子View removeAllViews(); mAdapter = adapter; // 获取数量 int childCount = mAdapter.getCount(); for (int i = 0; i &lt; childCount; i++) &#123; // 通过位置获取View View childView = mAdapter.getView(i, this); addView(childView); &#125; &#125; 然后我们使用就和ListView类似了：12345678910111213141516171819202122232425262728293031private TagLayout mTagLayout; private List&lt;String&gt; mItems; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_taglayout); mTagLayout = (TagLayout) findViewById(R.id.taglayout); mItems = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 20; i++) &#123; mItems.add("ABC"+i); &#125; mTagLayout.setAdapter(new BaseAdapter() &#123; @Override public int getCount() &#123; return mItems.size(); &#125; @Override public View getView(int position, ViewGroup parent) &#123; TextView tagTv = (TextView) LayoutInflater.from(TagLayoutActivity.this) .inflate(R.layout.item_tag, parent, false); tagTv.setText(mItems.get(position)); // 操作ListView的方式差不多 return tagTv; &#125; &#125;); &#125; 这样的话我们就简单的实现了流式布局的效果，如果需要单选多选之类的，在这基础上添加就可以了。接下来再具体的总结下自定义view和自定义viewGroup的套路: ######View的自定义套路 初始化，自定义属性，获取自定义属性(配置属性) onMeasure()方法用于测量计算自己的宽高，前提是继承自View，如果是继承自系统已有的 TextView , Button,已经给你计算好了宽高，就可以跳过这个步骤(设置宽高) onDraw() 用于绘制自己的显示(View绘制) onTouch() 用于与用户交互(事件分发) ######ViewGroup的自定义套路 自定义属性，获取自定义属性，很少有这种需求(配置属性)2.onMeasure()方法，for循环测量子View，根据子View的宽高来计算自己的宽高(设置宽高) onLayout()用来摆放子View，前提是不是GONE的情况 onDraw()一般不需要，默认情况下是不会调用，如果你要绘制需要实现dispatchDraw()方法(View绘制) 在很多情况下不会继承自ViewGroup ，往往是继承 系统已经提供好的ViewGroup 如 ViewPager ScrollView RelativeLayout,这样的话onMeause() onLayout()一般都可以跳过，相应的重写一些方法来实现自己的需求。比如侧滑菜单可以继承LinearLayout 或者RelativeLayout等来重写onInterceptTouchEvent来实现。 这篇文章到这就结束了 ，希望对大家有所提升。 下载地址:https://github.com/ChinaZeng/CustomView]]></content>
      <categories>
        <category>自定义view</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>自定义view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View（5） -- 评分控件RatingBar]]></title>
    <url>%2F%E8%87%AA%E5%AE%9A%E4%B9%89View%EF%BC%885%EF%BC%89%20--%20%E8%AF%84%E5%88%86%E6%8E%A7%E4%BB%B6RatingBar.html</url>
    <content type="text"><![CDATA[先看效果图:在我们画这个控件之前，我们想想一下怎么实现这个，显示对星星的处理，我们是自己绘制还是使用图片？其实都是可以的，但是我们为了更加快速的完成这个，我们选择了使用图片来完成。先自定义属性，在这个例子中我定义如下：123456789101112131415&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;declare-styleable name="RatingBar"&gt; &lt;!--未选中引用--&gt; &lt;attr name="starNormal" format="reference" /&gt; &lt;!--选中引用--&gt; &lt;attr name="starFocus" format="reference" /&gt; &lt;!--最大的分数--&gt; &lt;attr name="gradeNumber" format="integer" /&gt; &lt;!--当前的分数--&gt; &lt;attr name="currentGrade" format="integer" /&gt; &lt;!--星星之间的间距--&gt; &lt;attr name="statPadding" format="dimension" /&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 我们在初始化的时候获取相关数据:1234567891011121314151617181920212223242526272829303132333435363738 private Bitmap mStarFocusBitmap, mStarNormalBitmap; private int mGradeNumber;//最大分数 private int mCurrentGrade;//当前分数 1开始的 最少为1分 private int mStarPadding;//间距 public RatingBar(Context context) &#123; this(context, null); &#125; public RatingBar(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public RatingBar(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.RatingBar); int starNormalId = array.getResourceId(R.styleable.RatingBar_starNormal, 0); if (starNormalId == 0) &#123; throw new RuntimeException("请设置属性 starNormal "); &#125; mStarNormalBitmap = BitmapFactory.decodeResource(getResources(), starNormalId); int starFocusId = array.getResourceId(R.styleable.RatingBar_starFocus, 0); if (starFocusId == 0) &#123; throw new RuntimeException("请设置属性 starFocus "); &#125; mStarFocusBitmap = BitmapFactory.decodeResource(getResources(), starFocusId); mGradeNumber = array.getInt(R.styleable.RatingBar_gradeNumber, 0); mStarPadding = array.getDimensionPixelOffset(R.styleable.RatingBar_statPadding, DisplayUtil.dip2px(context, 5)); mCurrentGrade = array.getInt(R.styleable.RatingBar_currentGrade, 1); array.recycle(); &#125;&#125; 接下来我们设置宽高，本例中就直接写了，在实际开发中如有需要在修改12345678910@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); // 高度 一张图片的高度 int height = mStarFocusBitmap.getHeight() + getPaddingTop() + getPaddingBottom(); int width = mStarFocusBitmap.getWidth() * mGradeNumber + getPaddingLeft() + getPaddingRight() + mStarPadding * (mGradeNumber - 1); setMeasuredDimension(width, height); &#125; 接下来调用onDraw函数绘制:1234567891011121314@Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); for (int i = 0; i &lt; mGradeNumber; i++) &#123; if (i &lt; mCurrentGrade) &#123; canvas.drawBitmap(mStarFocusBitmap, getPaddingLeft() + i * mStarFocusBitmap.getWidth() + i * mStarPadding, getPaddingTop(), null); &#125; else &#123; canvas.drawBitmap(mStarNormalBitmap, getPaddingLeft() + i * mStarFocusBitmap.getWidth() + i * mStarPadding, getPaddingTop(), null); &#125; &#125; &#125; 我们进行测试:12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;com.zzw.customview.view.RatingBar android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerInParent="true" app:currentGrade="2" app:gradeNumber="5" app:statPadding="10dp" app:starFocus="@mipmap/star_selected" app:starNormal="@mipmap/star_normal" /&gt;&lt;/RelativeLayout&gt; 效果图如下： 这时候只是一个静态的，点击的时候并没有变化，我们接下来进行onTouchEvent监听，然后进行改变值重绘:123456789101112131415@Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: case MotionEvent.ACTION_MOVE: //计算下标 int pos = (int) (x / (mStarFocusBitmap.getWidth() + mStarPadding)); if (pos &lt; 0) pos = 0; if (pos &gt;= mGradeNumber) pos = mGradeNumber - 1; mCurrentGrade = pos + 1; invalidate(); break; &#125; return true; &#125; 我们为什么要加1呢？因为我们mCurrentGrade表示的是评分的分数，所以用下标加1，这个时候我们效果就达到了，但是我们不要忘记优化。因为我们返回了true,所以在滑动的时候一直接受到move的事件，就一直进行调用了invalidate重绘 ，我们上次也说过invalidate会做很多事情，所以我们就要减少重绘的此时，我们应该加上判断：1234567891011121314151617@Override public boolean onTouchEvent(MotionEvent event) &#123; switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: case MotionEvent.ACTION_MOVE: //计算下标 int pos = (int) (x / (mStarFocusBitmap.getWidth() + mStarPadding)); if (pos &lt; 0) pos = 0; if (pos &gt;= mGradeNumber) pos = mGradeNumber - 1; if (pos != mCurrentGrade - 1) &#123;//分数-1 等于 坐标pos mCurrentGrade = pos + 1; invalidate(); &#125; break; &#125; return true; &#125; 这样的画就优雅了很多，当然也不要忘记bitmap的回收，我们将暴露出函数来给使用者在activity的onDestory生命周期调用。12345678910111213/** * 回收 */ public void recycle() &#123; if (mStarFocusBitmap != null) mStarFocusBitmap.recycle(); if (mStarNormalBitmap != null) mStarNormalBitmap.recycle(); mStarFocusBitmap=null; mStarNormalBitmap=null; &#125; 在activity里面调用:12345@Override protected void onDestroy() &#123; super.onDestroy(); mRatingBar.recycle(); &#125; 这样的话对于强迫症患者心里就舒坦多了。当然，我也是一个强迫症换患者。但是有时候我们也不能一定要追求极致，比如在获取位置的时候，我有一个想法，就是根据星星的范围精确的获取当前的位置,比如下面这样: 当时我就写了一个小算法：123456789101112131415161718192021222324252627282930313233/** * 计算位置 * * @param x * @return */ private int comPos(float x) &#123; int startX = getPaddingLeft(); if (x &lt; startX) &#123; return 0; &#125; if (x &gt; getWidth() - getPaddingRight()) &#123; return mGradeNumber; &#125; int pos = 0; for (int i = 0; i &lt; mGradeNumber; i++) &#123; int endX; if (i == 0 || i == mGradeNumber - 1) &#123;//第0个位置的后面的x endX = startX + mStarFocusBitmap.getWidth() + mStarPadding / 2; &#125; else &#123; endX = startX + mStarFocusBitmap.getWidth() + mStarPadding; &#125; if (x &lt; endX) &#123; pos = i; break; &#125; startX = endX; &#125; return pos; &#125; 这样的画就能够准确的拿到星星的位置，但是这样的弊端就是一个for循环，将会耗费更多的时间，所以最后还是改为了一个模糊的计算位置的方式。所以有时候也不能太强迫自己，不要钻牛角尖。这篇文章结束了，希望对大家有所帮助! 下载链接:https://github.com/ChinaZeng/CustomView]]></content>
      <categories>
        <category>自定义view</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>自定义view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View（4） -- 字体变色]]></title>
    <url>%2F%E8%87%AA%E5%AE%9A%E4%B9%89View%EF%BC%884%EF%BC%89%20--%20%E5%AD%97%E4%BD%93%E5%8F%98%E8%89%B2.html</url>
    <content type="text"><![CDATA[初始化我就不说了，先思考我们需要什么属性，这里我就随便写了两个，一个是变色的颜色，一个是正常的颜色，当然也可以是默认的字体颜色，我们在attr里面申明1234567891011121314151617181920212223242526&lt;declare-styleable name="ColorTrackTextView"&gt; &lt;attr name="originColor" format="color" /&gt; &lt;attr name="changeColor" format="color" /&gt; &lt;/declare-styleable&gt; private int mOriginColor;//不变化的颜色 private int mChangeColor;//变化的颜色 private Paint mOriginPaint, mChangePaint; private void init(Context context, AttributeSet attrs) &#123; TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.ColorTrackTextView); mOriginColor = ta.getColor(R.styleable.ColorTrackTextView_originColor, Color.BLACK); mChangeColor = ta.getColor(R.styleable.ColorTrackTextView_changeColor, Color.RED); ta.recycle(); mOriginPaint = new Paint(); mOriginPaint.setColor(mOriginColor); mOriginPaint.setAntiAlias(true); mOriginPaint.setTextSize(getTextSize()); mChangePaint = new Paint(); mChangePaint.setColor(mChangeColor); mChangePaint.setAntiAlias(true); mChangePaint.setTextSize(getTextSize()); &#125; 因为我们选择了继承的是TextView，所以我们就不进行 onMeasure()，我们重写onDraw(),覆盖原有的绘制逻辑，我们自己来绘制，这里我们主要使用canvas.clipRect(rect)这个函数来实现裁剪，我们先来测试:123456789101112131415161718192021222324252627282930313233//思路：利用clipRect 来裁剪 使用两个画笔 @Override protected void onDraw(Canvas canvas) &#123;// super.onDraw(canvas); //不使用TextView的绘制 自己画 canvas.save(); int mid = 500; Rect rect = new Rect(0, 0, mid, getHeight()); canvas.clipRect(rect); String text = getText().toString(); int x = (int) (getPaddingLeft() + getWidth() / 2 - mOriginPaint.measureText(text) / 2); int y = getPaddingTop() + DisplayUtil.getTextBaseLine(getHeight(), mOriginPaint); canvas.drawText(text, x, y, mChangePaint); canvas.restore(); canvas.save(); rect.set(mid, 0, getWidth(), getHeight()); canvas.clipRect(rect); canvas.drawText(text, x, y, mOriginPaint); canvas.restore(); &#125; &lt;com.zzw.customview.view.ColorTrackTextView xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/colortv" android:layout_width="match_parent" android:layout_height="match_parent" android:layout_gravity="center_horizontal" android:gravity="center" android:text="1111111" android:textSize="50sp" app:changeColor="@color/colorAccent" app:originColor="@color/colorPrimary" /&gt; 可以看到，我们是有效果的，因为我们考略到要和 ViewPager 一起配合使用，所以我们定义一个float类型的mCurrentProgress属性，用于表示当前的滑动进度，在设置一个方向，颜色是从左到右变化还是从右到左的变化123456789//不同的朝向 public static final int DIRECTION_LEFT_TO_RIGHT = 1;//从左边变色 public static final int DIRECTION_RIGHT_TO_LEFT = 2;//从右边变色 private int mDirection = DIRECTION_LEFT_TO_RIGHT; //当前进度 private float mCurrentProgress; 接下来我们修改onDraw()以及优化一下赘余代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445 //思路：利用clipRect 来裁剪 使用两个画笔 @Override protected void onDraw(Canvas canvas) &#123;// super.onDraw(canvas); //不使用TextView的绘制 自己画 int mid = comMiddle(); if (mDirection == DIRECTION_LEFT_TO_RIGHT) &#123; drawText(canvas, mChangePaint, 0, mid); //画左边 颜色 drawText(canvas, mOriginPaint, mid, getWidth());//画右边 &#125; else &#123; mid = getWidth() - mid; drawText(canvas, mChangePaint, mid, getWidth());//画右边 颜色 drawText(canvas, mOriginPaint, 0, mid); //画左边 &#125; &#125; /** * 根据当前进度算出中间值 * * @return */ private int comMiddle() &#123; return (int) (mCurrentProgress * getWidth()); &#125; /** * 根据start end 确定rect绘制文字 * * @param canvas * @param paint * @param start * @param end */ private void drawText(Canvas canvas, Paint paint, int start, int end) &#123; canvas.save(); Rect rect = new Rect(start, 0, end, getHeight());//确定区域 canvas.clipRect(rect); String text = getText().toString(); int x = (int) (getPaddingLeft() + getWidth() / 2 - paint.measureText(text) / 2); int y = getPaddingTop() + DisplayUtil.getTextBaseLine(getHeight(), paint); canvas.drawText(text, x, y, paint); canvas.restore(); &#125; 接下来我们进行测试1234567891011121314151617181920212223public void leftToRight(View view) &#123; mColorTrackTextView.setDirection(ColorTrackTextView.DIRECTION_LEFT_TO_RIGHT); startAnim(0, 1); &#125; public void RightToLeft(View view) &#123; mColorTrackTextView.setDirection(ColorTrackTextView.DIRECTION_RIGHT_TO_LEFT); startAnim(0, 1); &#125; private void startAnim(float startPro, float endPro) &#123; ValueAnimator animator = ObjectAnimator.ofFloat(startPro, endPro); animator.setDuration(2000); animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; float currentProgress = (float) animation.getAnimatedValue(); mColorTrackTextView.setCurrentProgress(currentProgress); &#125; &#125;); animator.start(); &#125; 就会得到如下图的效果: 感觉离成功近了一步，这里我们顺便优化了一个性能的问题，因为是不端的调用setCurrentProgress()方法进行重新绘制，所以这里我们加个判断:1234567public void setCurrentProgress(float currentProgress) &#123; if (mCurrentProgress == currentProgress)//当前进度相同就不执行下一步 return; this.mCurrentProgress = currentProgress; invalidate(); &#125; 让它重复的时候不进行重绘，这只是一个小细节,接下来我们和ViewPager配合使用。我们在开发中一般遇到的是根据一个数据源，然后动态的添加Fragment和ViewPager进行关联，这里我们模拟这个场景。我们使用一个LinearLayout来管理这些字体变色的view， ViewPager的OnPageChangeListener来管理字体变色,布局为下:123456789101112131415161718192021&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="fill_parent" android:layout_height="fill_parent" android:orientation="vertical"&gt; &lt;LinearLayout android:layout_width="match_parent" android:orientation="horizontal" android:paddingTop="10dp" android:paddingBottom="10dp" android:id="@+id/indicator_view" android:layout_height="wrap_content"/&gt; &lt;android.support.v4.view.ViewPager android:layout_width="match_parent" android:layout_height="0dp" android:id="@+id/view_pager" android:layout_weight="1" /&gt;&lt;/LinearLayout&gt; 然后我们在代码中动态的添加:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117package com.zzw.customview;import android.graphics.Color;import android.os.Bundle;import android.support.v4.app.Fragment;import android.support.v4.app.FragmentPagerAdapter;import android.support.v4.view.ViewPager;import android.support.v7.app.AppCompatActivity;import android.util.Log;import android.view.View;import android.view.ViewGroup;import android.widget.LinearLayout;import com.zzw.customview.view.ColorTrackTextView;import java.util.ArrayList;import java.util.List;/** * Created by zzw on 2017/6/15. * Version: * Des: 字体变色和viewpager配合使用 */public class ViewPagerActivity extends AppCompatActivity &#123; private String[] items = &#123;"热点", "推荐", "社会", "图片", "科技", "运动"&#125;; private LinearLayout mIndicatorContainer;// 变成通用的 private List&lt;ColorTrackTextView&gt; mIndicators; private ViewPager mViewPager; @Override public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_view_pager); mIndicators = new ArrayList&lt;&gt;(); mIndicatorContainer = (LinearLayout) findViewById(R.id.indicator_view); mViewPager = (ViewPager) findViewById(R.id.view_pager); initIndicator(); initViewPager(); &#125; /** * 初始化ViewPager */ private void initViewPager() &#123; mViewPager.setAdapter(new FragmentPagerAdapter(getSupportFragmentManager()) &#123; @Override public Fragment getItem(int position) &#123; return ItemFragment.newInstance(items[position]); &#125; @Override public int getCount() &#123; return items.length; &#125; @Override public void destroyItem(ViewGroup container, int position, Object object) &#123; &#125; &#125;); mViewPager.addOnPageChangeListener(new ViewPager.OnPageChangeListener() &#123; @Override public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123; Log.e("TAG", "position -&gt; " + position + " positionOffset -&gt; " + positionOffset + " positionOffsetPixels-&gt;" + positionOffsetPixels); // position 代表当前的位置 // positionOffset 代表滚动的 0 - 1 百分比 左滑 1-&gt;0 右滑-&gt; 0-1 // 1.左边 位置 position ColorTrackTextView left = mIndicators.get(position); left.setDirection(ColorTrackTextView.DIRECTION_RIGHT_TO_LEFT); left.setCurrentProgress(1 - positionOffset); try &#123; ColorTrackTextView right = mIndicators.get(position + 1); right.setDirection(ColorTrackTextView.DIRECTION_LEFT_TO_RIGHT); right.setCurrentProgress(positionOffset); &#125; catch (Exception e) &#123; &#125; &#125; @Override public void onPageSelected(int position) &#123; &#125; @Override public void onPageScrollStateChanged(int state) &#123; &#125; &#125;); &#125; /** * 初始化可变色的指示器 */ private void initIndicator() &#123; for (int i = 0; i &lt; items.length; i++) &#123; // 动态添加颜色跟踪的TextView LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); params.weight = 1; ColorTrackTextView colorTrackTextView = new ColorTrackTextView(this); // 设置颜色 colorTrackTextView.setTextSize(20); colorTrackTextView.setChangeColor(Color.RED); colorTrackTextView.setText(items[i]); colorTrackTextView.setLayoutParams(params); // 把新的加入LinearLayout容器 mIndicatorContainer.addView(colorTrackTextView); // 加入集合 mIndicators.add(colorTrackTextView); &#125; &#125; 这里我们发现左右滑动的时候可以实现了，但是点击tab的时候还会出现上一个没有变色的情况,这里我就不上图了，我们直接写一个函数，在选中之后把重新设置颜色即可。12345678910private void selectPos(int pos) &#123; for (int i = 0; i &lt; mIndicators.size(); i++) &#123; ColorTrackTextView colorTrackTextView = mIndicators.get(i); if (i == pos) &#123; colorTrackTextView.setCurrentProgress(1.0f); &#125; else &#123; colorTrackTextView.setCurrentProgress(0.0f); &#125; &#125; &#125; 最后要说的是，优化问题，在这篇文章中我们在绘制的过程中就已经进行优化了，我们要养成这种好习惯，不管是代码上还是性能上。下载地址:https://github.com/ChinaZeng/CustomView 参考链接:http://www.jianshu.com/p/6e4b3eebbba0]]></content>
      <categories>
        <category>自定义view</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>自定义view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View（3） -- 字母索引]]></title>
    <url>%2F%E8%87%AA%E5%AE%9A%E4%B9%89View%EF%BC%883%EF%BC%89%20--%20%E5%AD%97%E6%AF%8D%E7%B4%A2%E5%BC%95.html</url>
    <content type="text"><![CDATA[效果图: 自定义view的流程，具体请点此查看：自定义view套路我们先重写构造器，然后重写onMeasure函数进行测量设置宽高，在本例中，宽我是根据padding和测量一个字母w的宽度来设置的，高度就是默认的，因为一般是设置为match_parent.123456789101112131415161718192021222324252627public AlphabeticalIndexView(Context context) &#123; this(context, null); &#125; public AlphabeticalIndexView(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public AlphabeticalIndexView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(context); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int w = (int) (getPaddingLeft() + getPaddingRight() + DisplayUtil.getTextWidth("W", mPaint)); int h = getMeasuredHeight(); setMeasuredDimension(w, h); &#125; private void init(Context context) &#123; mPaint = new Paint(); mPaint.setAntiAlias(true); mPaint.setTextSize(DisplayUtil.sp2px(context, 15)); &#125; 因为不是viewGroup，所以不必重写onLayout函数,我们直接进入onDraw12345678910111213141516171819@Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // 每个字母所占用的高度 for (int i = 0; i &lt; mLetters.length; i++) &#123; String letter = mLetters[i]; if (letter.equals(mCurrentTouchLetter)) mPaint.setColor(Color.BLUE); else mPaint.setColor(Color.GRAY); // 获取字体的宽度 float measureTextWidth = mPaint.measureText(letter); // 获取内容的宽度 int contentWidth = getWidth() - getPaddingLeft() - getPaddingRight(); canvas.drawText(letter, getPaddingLeft() + (contentWidth - measureTextWidth) / 2, getPaddingTop() + mSingLetterHeight * i + DisplayUtil.getTextBaseLine(mPaint), mPaint); &#125; &#125; 这里可能有点疑惑，为什么要用内容的宽度减去字体的宽度然后除于2，这是因为每个字母的宽度都不一样，如果不这样做的画，那么比如I就会和A W等字母左对齐，我们这样做的目的就是为了都居中。这样我们就实现了一个静态的页面没我们要让他触摸改变，我们就重写onTouchEvent进行操作，并且添加相应的回调。1234567891011121314151617181920212223242526272829303132333435363738@Override public boolean onTouchEvent(MotionEvent ev) &#123; switch (ev.getAction()) &#123; case MotionEvent.ACTION_DOWN: case MotionEvent.ACTION_MOVE: // 获取当前手指触摸的Y位置 float fingerY = ev.getY(); int pos = (int) (fingerY / mSingLetterHeight); if (pos &gt; -1 &amp;&amp; pos &lt; mLetters.length &amp;&amp; !mLetters[pos].equals(mCurrentTouchLetter)) &#123; mCurrentTouchLetter = mLetters[pos]; triggerTouchListener(true); invalidate(); &#125; break; case MotionEvent.ACTION_UP: triggerTouchListener(false); break; &#125; return true; &#125; private void triggerTouchListener(boolean isTouch) &#123; if (mTouchListener != null) mTouchListener.onTouch(mCurrentTouchLetter, isTouch); &#125; // 设置触摸监听 private SideBarTouchListener mTouchListener; public void setOnSideBarTouchListener(SideBarTouchListener touchListener) &#123; this.mTouchListener = touchListener; &#125; public interface SideBarTouchListener &#123; void onTouch(String letter, boolean isTouch); &#125; 这样我们就可以实现了这个功能点。优化思路一个view绘制出来我们还需要进行优化，这一步是非常重要的。在本例中，我们的优化主要是在 onTouchEvent里面，因为我们知道，invalidate函数是一个一个做了很多事情的函数，具体请看:Android invalidate流程分析 我们要减少它的调用，所以我们应该先判断一下，如果当前的这个索引和触摸的这个不一样的话才调用invalidate，这样的话就优雅很多了。在本例中我没有将需要改变的属性，比如字体大小、选中颜色、默认颜色等提取在attr里面，需要的请自行添加。参考:Android字母索引列表 源码github下载地址:https://github.com/ChinaZeng/CustomView]]></content>
      <categories>
        <category>自定义view</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>自定义view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View（2） -- 58同城加载动画]]></title>
    <url>%2F%E8%87%AA%E5%AE%9A%E4%B9%89View%EF%BC%882%EF%BC%89%20--%2058%E5%90%8C%E5%9F%8E%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB.html</url>
    <content type="text"><![CDATA[先上图 思考步骤还是和上一篇讲的一样，相同的套路：自定义View（1）–QQ运动计步器 构造器不说了，正常情况一般三个都会写，这篇我没从attr里面写东西，所以这一步跳过了，我们直接来要真正思考的地方：首先我们这里实现的话有很多种方式，可以用图片，可以自己绘制，这里我们选择自己绘制，但是绘制的话，我们又要考虑这个动画是需要我们自己算坐标然后重绘？还是写成单独的一个view然后通过动画实现，这里我选择了后者，原因有三个：第一个是如果在 view内部写相关的移动旋转逻辑的话，计算量不用说增加了，这个是很费时间的，而且很容易出错；第二个是因为你不停的调用invalidate，看了源码的都知道，调用这个函数的会做很多工作，造成不必要的gpu耗费，这样不好；第三个是实用性，如果以后我们需要这样一个图像，我们可以直接把这个形状的view复制过去就可以使用，所以我们理清思路。首先，上面跳动的view作为一个单独的view，下面的弧形阴影也做为一个单独的view,然后在外层通过一个viewGroup把他们组装起来并且控制相关的代码和其性能的优化。我们先绘制图形的 view，也就是上下跳动的哪个view。我们 需要组装，所以我们肯定要重写onMeasure设置其宽高，这里我打算指定他的高度和宽度为圆的半径的两倍:1234567891011121314151617181920212223242526272829303132333435363738394041424344@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); setMeasuredDimension(measureWidth(widthMeasureSpec), measureHeight(heightMeasureSpec)); &#125; /** * Determines the width of this view * * @param measureSpec A measureSpec packed into an int * @return The width of the view, honoring constraints from measureSpec */ private int measureWidth(int measureSpec) &#123; int result = 0; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); if (specMode == MeasureSpec.EXACTLY) &#123; result = specSize; &#125; else &#123; result = mRadio * 2; &#125; return result; &#125; /** * Determines the height of this view * * @param measureSpec A measureSpec packed into an int * @return The height of the view, honoring constraints from measureSpec */ private int measureHeight(int measureSpec) &#123; int result = 0; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); if (specMode == MeasureSpec.EXACTLY) &#123; result = specSize; &#125; else &#123; result = 2 * mRadio; &#125; return result; &#125; 接下来我们绘制图形，考略到我们需要变换不同形状的view,所以我写的时候分别写了三个绘制不同图案的函数，然后添加一个flag判断绘谁即可1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); initCenterPoint(); if (mFlog == 0) drawCircle(canvas); else if (mFlog == 1) drawRect(canvas); else drawTriangle(canvas); &#125; private void initCenterPoint() &#123; if (mCenterX == -1 || mCenterY == -1) &#123; mCenterX = getMeasuredWidth() / 2; mCenterY = getMeasuredHeight() / 2; // setPivotX(mCenterX); // setPivotY(mCenterY); &#125; &#125; /** * 画圆 * * @param canvas */ private void drawCircle(Canvas canvas) &#123; canvas.drawCircle(mCenterX, mCenterY, mRadio, mCirclePaint); &#125; /** * 画正方形 * * @param canvas */ private void drawRect(Canvas canvas) &#123; Rect rect = new Rect(mCenterX - mRadio, mCenterY - mRadio, mCenterX + mRadio, mCenterY + mRadio); canvas.drawRect(rect, mRectPaint); &#125; public void setFlog(int mFlog) &#123; this.mFlog = mFlog; invalidate(); &#125; /** * 绘制三角形 * * @param canvas */ private void drawTriangle(Canvas canvas) &#123; Path path = new Path(); path.moveTo(mCenterX, mCenterY - mRadio); path.lineTo(mCenterX - mRadio, mCenterY + mRadio); path.lineTo(mCenterX + mRadio, mCenterY + mRadio); canvas.drawPath(path, mTrianglePaint); &#125; 测试一下这个图案已经绘制完成了，接下来我们绘制下面的阴影，同样的我们需要先测量，我这里设置宽高为半径值的2/3,宽为两倍的半径: 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); setMeasuredDimension(measureWidth(widthMeasureSpec), measureHeight(heightMeasureSpec)); &#125; /** * Determines the width of this view * * @param measureSpec A measureSpec packed into an int * @return The width of the view, honoring constraints from measureSpec */ private int measureWidth(int measureSpec) &#123; int result = 0; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); if (specMode == MeasureSpec.EXACTLY) &#123; result = specSize; &#125; else &#123; result = mRadio * 2; &#125; return result; &#125; /** * Determines the height of this view * * @param measureSpec A measureSpec packed into an int * @return The height of the view, honoring constraints from measureSpec */ private int measureHeight(int measureSpec) &#123; int result = 0; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); if (specMode == MeasureSpec.EXACTLY) &#123; result = specSize; &#125; else &#123; result = 2 * mRadio / 3; &#125; return result; &#125; 接下来我们绘制图案，我在绘制这个图案的时候是采用drawArc的方式，所以我们需要计算一下它的范围,我这采用的方案如下:因为我们要上面的那块横线挨着物块view掉下的位置，所以rect的中心点就是这个,然后计算如下：12345int left = getWidth() / 2 - mRadio; int top = -getHeight() / 2; int right = getWidth() / 2 + mRadio; int bottom = getHeight() / 2; mRectF = new RectF(left, top, right, bottom); 其实getHeight就是2/3的半径我们绘制的时候，绘制180°即可，:1234567891011@Override protected void onDraw(Canvas canvas) &#123; if (mRectF == null) &#123; int left = getWidth() / 2 - mRadio; int top = -getHeight() / 2; int right = getWidth() / 2 + mRadio; int bottom = getHeight() / 2; mRectF = new RectF(left, top, right, bottom); &#125; canvas.drawArc(mRectF, 0, 180, false, mArcPaint); &#125; 最后我们将这两个图案组装起来，加上动画即可:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 public void startAnim() &#123; if (mAnimatorSet == null) &#123; mAnimatorSet = new AnimatorSet(); //up ObjectAnimator rotationAnim = ObjectAnimator.ofFloat(mShapeView, "rotation", 0.0f, 360.0f); rotationAnim.setDuration(JUMP_UP_TIME); rotationAnim.setInterpolator(new AccelerateDecelerateInterpolator());//先快后慢 ObjectAnimator translationAnimUp = ObjectAnimator.ofFloat(mShapeView, "translationY", 0, -JUMP_MAX_HEIGHT); translationAnimUp.setDuration(JUMP_UP_TIME); translationAnimUp.setInterpolator(new AccelerateDecelerateInterpolator());//先快后慢 ObjectAnimator scaleXAnimUp = ObjectAnimator.ofFloat(mArcView, "scaleX", 1.0f, 0.2f); scaleXAnimUp.setDuration(JUMP_UP_TIME); scaleXAnimUp.setInterpolator(new AccelerateDecelerateInterpolator());//先快后慢 ObjectAnimator scaleYAnimUp = ObjectAnimator.ofFloat(mArcView, "scaleY", 1.0f, 0.2f); scaleYAnimUp.setDuration(JUMP_UP_TIME); scaleYAnimUp.setInterpolator(new AccelerateDecelerateInterpolator());//先快后慢 //down ObjectAnimator translationAnimDown = ObjectAnimator.ofFloat(mShapeView, "translationY", -JUMP_MAX_HEIGHT, 0); translationAnimDown.setDuration(JUMP_UP_TIME); translationAnimDown.setInterpolator(new AccelerateInterpolator());//先慢后快 ObjectAnimator scaleXAnimXDown = ObjectAnimator.ofFloat(mArcView, "scaleX", 0.2f, 1.0f); scaleXAnimXDown.setDuration(JUMP_UP_TIME); scaleXAnimXDown.setInterpolator(new AccelerateInterpolator());//先慢后快 ObjectAnimator scaleYAnimDown = ObjectAnimator.ofFloat(mArcView, "scaleY", 0.2f, 1.0f); scaleYAnimDown.setDuration(JUMP_UP_TIME); scaleYAnimDown.setInterpolator(new AccelerateInterpolator());//先慢后快 mAnimatorSet.play(translationAnimUp) .with(rotationAnim) .with(scaleXAnimUp) .with(scaleYAnimUp) .before(translationAnimDown) .before(scaleXAnimXDown) .before(scaleYAnimDown); mAnimatorSet.addListener(new AnimatorListenerAdapter() &#123; @Override public void onAnimationEnd(Animator animation) &#123; super.onAnimationEnd(animation); mFlog++;//圆形 0--&gt;1方形 --&gt;2 三角形 --&gt;3-&gt;0----&gt; if (mFlog &gt; 2) &#123; mFlog = 0; &#125; mShapeView.setFlog(mFlog); startAnim(); &#125; &#125;); &#125; mAnimatorSet.start();&#125; 这样的话效果实现了，感觉没什么问题了。但是不要忘记了优化优化 在这里我们主要优化这个动画对应Activity的生命周期 ,让其可见的时候加载动画，不可见的时候停止动画。主要使用Application.ActivityLifecycleCallbacks这个接口实现,具体实现的代码如下：123456789101112131415161718192021222324252627@Override protected void onAttachedToWindow() &#123; mActivity.getApplication().registerActivityLifecycleCallbacks(animLifecyleCallback); super.onAttachedToWindow(); &#125; @Override protected void onDetachedFromWindow() &#123; mActivity.getApplication().unregisterActivityLifecycleCallbacks(animLifecyleCallback); super.onDetachedFromWindow(); &#125; private SimpleActivityLifecycleCallbacks animLifecyleCallback = new SimpleActivityLifecycleCallbacks() &#123; @Override public void onActivityResumed(Activity activity) &#123; // 页面第一次启动的时候不会执行 if (activity == mActivity) startAnim(); super.onActivityResumed(activity); &#125; @Override public void onActivityPaused(Activity activity) &#123; if (activity == mActivity) stopAnim(); super.onActivityPaused(activity); &#125; &#125;; 这样就更加优雅了。源码github下载地址:https://github.com/ChinaZeng/CustomView]]></content>
      <categories>
        <category>自定义view</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>自定义view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View（1）--QQ运动计步器]]></title>
    <url>%2F%E8%87%AA%E5%AE%9A%E4%B9%89View%EF%BC%881%EF%BC%89--QQ%E8%BF%90%E5%8A%A8%E8%AE%A1%E6%AD%A5%E5%99%A8.html</url>
    <content type="text"><![CDATA[无图无真像: 在我们画一个图形之前，我们需要思考，我们先要解析他的步骤，然后根据步骤一步一步来完成。 思考：我们绘制View的一般基本流程为: 1.根据我们的需要，是需要new出来还是在布局文件里面添加，从而得到相应的构造方法。2.我们需要什么属性？3.我们是否需要测量？4.如果是viewGroup我们需要是否要通过onLayout方法来摆放childView的位置？5.调用onDraw()的时候先画什么，在画什么?然后调用相应的API完成相应的步骤即可。6.性能优化。 我们从这个基本流程出发 我们希望这个view能够new出来，也能够在布局文件里面添加使用,所以构造函数如下:123456789101112public QQSportStepView(Context context) &#123; this(context, null); &#125; public QQSportStepView(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public QQSportStepView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; 2.我们需要什么属性？在这个view里面，我想实现的是希望其他人可以自己设置文字颜色，线条宽度，弧度大小等等，所以我们在att里面定义: 并且在初始化的时候解析出来：12345678910111213141516171819202122232425262728293031private int mBottomColor;//底层圆的颜色private int mTopColor;//顶层圆的颜色private int mTextColor;//文字颜色private int mMaxStepNum;//最大步数private int mCurrentStepNum;//当前步数private int mTextSize;//文字大小private int mCircleRadio;//圆的半径private int mCircleStrokeWidth;//圆线条的宽度private float mArcAngle;//弧度大小private float mStartAngle;//通过幅度计算出开始的角度位置private void initAttrs(Context context, AttributeSet attrs) &#123; TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.QQSportStep); mBottomColor = ta.getColor(R.styleable.QQSportStep_bottomColor, Color.BLUE); mTopColor = ta.getColor(R.styleable.QQSportStep_topColor, Color.RED); mTextColor = ta.getColor(R.styleable.QQSportStep_textColor, Color.RED); mMaxStepNum = ta.getInteger(R.styleable.QQSportStep_maxStepNum, 0); mCurrentStepNum = ta.getInteger(R.styleable.QQSportStep_currentStepNum, 0); mTextSize = ta.getDimensionPixelSize(R.styleable.QQSportStep_textSize, DisplayUtil.sp2px(context, 17)); mCircleRadio = ta.getDimensionPixelSize(R.styleable.QQSportStep_circleRadio, DisplayUtil.dip2px(context, 100)); mArcAngle = ta.getFloat(R.styleable.QQSportStep_arcAngle, 270.0f); if (mArcAngle &gt; 360.0f || mArcAngle &lt; -360.0f) mArcAngle = 360.0f; mCircleStrokeWidth = ta.getDimensionPixelOffset(R.styleable.QQSportStep_circleStrokeWidth, DisplayUtil.dip2px(context, 5)); ta.recycle();&#125; 3.我们是否需要测量？因为这个view使用的时候一般是写好的固定的大小，所以不必要测量，所以我就没重写onMeasure方法4.因为这是个view，没有childView，所以不用重写onLayout方法5.解析步骤：我将这个view解析为三个步骤 1.画底部的圆弧2.画顶部的圆弧3.画文字 然后重写onDraw画底部的圆弧： 1234567891011121314if (mRectF == null) &#123; int centerX = getWidth() / 2; int centerY = getHeight() / 2; mRectF = new RectF(centerX - mCircleRadio, centerY mCircleRadio, centerX + mCircleRadio, centerY + mCircleRadio); &#125; //1.画底部的圆 float gapAngle = mArcAngle - 180.0f; if (mArcAngle &gt;= 0) &#123;//大于0表示在上方 mStartAngle = 180.0f - gapAngle / 2; &#125; else &#123;//小于0表示在下方 mStartAngle = -gapAngle / 2; &#125; canvas.drawArc(mRectF, mStartAngle, mArcAngle, false, mBottomPaint); 画顶部的圆弧123456//2.画顶部的圆弧 float currentAngle = (float) mCurrentStepNum / mMaxStepNum * mArcAngle; canvas.drawArc(mRectF, mStartAngle, currentAngle, false, mTopPaint); if (mMaxStepNum &lt;= 0) return; 画文字12345String step = String.valueOf(mCurrentStepNum); int dx = (getWidth() - DisplayUtil.getTextWidth(step, mTextPaint)) / 2; int baseLine = getHeight() / 2 + DisplayUtil.getTextBaseLine(mTextPaint); // 绘制步数文字 canvas.drawText(step, dx, baseLine, mTextPaint); 5.性能优化(这一步很重要，请不要忽略它)我们现在已经可以在手机屏幕上呈现一个静态的view了，但是我们要让他动起来，这里有两种方式，一种是在view内部写实现，一种是在view外部实现，为了降低耦合，我们最好是将动画实现的效果从外部实现。在动画的时候，一定是View不停的调用onDraw方法重绘，所以我们将重复的操作提取出来，一次就行了，不用每一次都在执行，比如：画笔初始化、一些计算等,这样能够降低gpu的消耗，当然如果实现的效果比较复杂的画，可以使用双缓冲的绘图方式来牺牲内存来换取时间，这样gpu就不会起伏太大。 最后我们在外部使用ValueAnimator来实现动画:1234567891011121314int maxStepNun = 100000;qqSportStepView.setMaxStepNum(maxStepNun);ValueAnimator valueAnimator = new ValueAnimator();valueAnimator.setDuration(2000);valueAnimator.setIntValues(0, maxStepNun);valueAnimator.setInterpolator(new DecelerateInterpolator());valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; int value = (int) animation.getAnimatedValue(); qqSportStepView.setCurrentStepNum(value); &#125;&#125;);valueAnimator.start(); 总结：我们在做自定义一个view的时候，一定要先理清楚思路，我们要实现什么效果？我们要达到什么目的？然后在解析相应的步骤，最后调用相关的api一步步完成即可。参考:自定义View - 仿QQ运动步数进度效果 本文源码下载地址:https://github.com/ChinaZeng/CustomView]]></content>
      <categories>
        <category>自定义view</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>自定义view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图]]></title>
    <url>%2F%E5%9B%BE.html</url>
    <content type="text"><![CDATA[图(Graph) 是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E)，其中，G表示一个图,V是图G中顶点的集合，E是图G中边的集合。 图的特性 线性表中我们把数据元素叫元素，树中将数据元素叫结点，在图中的数据元素我们称之为顶点(Vertex)。 线性表中可以没有数据元素，成为空表。树中可以没有结点，叫做空树。 线性表中，相邻的数据元素之间具有线性关系。树结构中，相邻两层的结点具有层次关系。而在图中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的。 无向图 有向图 图的权 连通图 图的度 图的存储结构 ：主要有两种方式，一种是邻接矩阵,一种是邻接表。 邻接矩阵: 邻接矩阵表示无向图 邻接矩阵表示有向图 邻接矩阵表示有权值的图 邻接表: 邻接表表示无向图 邻接表表示有向图 邻接表表示有权值的图 JAVA利用邻接矩阵实现简单的图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class Graph &#123; private int vertexSize;//顶点数量 5个顶点 private int[] vertexs;//顶点 v0 v1 v2 v3 v4 private int[][] matrix;//邻接矩阵 private static final int MAX_WEIGHT = 1000; //表示无穷 public Graph(int vertexSize) &#123; this.vertexSize = vertexSize; matrix = new int[vertexSize][vertexSize]; vertexs = new int[vertexSize]; for (int i = 0; i &lt; vertexSize; i++) &#123; vertexs[i] = i; &#125; &#125; /** * 获取index顶点的的出度 * * @param index 顶点index */ public int getOutDegree(int index) &#123; int degree = 0; for (int i = 0; i &lt; matrix[index].length; i++) &#123; int weight = matrix[index][i]; if (weight != 0 &amp;&amp; weight != MAX_WEIGHT) &#123; degree++; &#125; &#125; return degree; &#125; /** * 获取index顶点的的入度 * * @param index 顶点index */ public int getInDegree(int index) &#123; int degree = 0; for (int i = 0; i &lt; matrix[index].length; i++) &#123; int weight = matrix[i][index]; if (weight != 0 &amp;&amp; weight != MAX_WEIGHT) &#123; degree++; &#125; &#125; return degree; &#125; /** * 获取v1到v2的权值 * * @return v1到v2的权值权值 */ public int getWeight(int v1, int v2) &#123; int weight = matrix[v1][v2]; return weight == 0 ? 0 : (weight == MAX_WEIGHT ? -1 : weight); &#125; public static void main(String[] args) &#123; Graph graph = new Graph(5);//v0 -&gt; v4 int[] v0 = new int[]&#123;0, MAX_WEIGHT, MAX_WEIGHT, MAX_WEIGHT, 6&#125;; int[] v1 = new int[]&#123;9, 0, 3, MAX_WEIGHT, MAX_WEIGHT&#125;; int[] v2 = new int[]&#123;2, MAX_WEIGHT, 0, 5, MAX_WEIGHT&#125;; int[] v3 = new int[]&#123;MAX_WEIGHT, MAX_WEIGHT, MAX_WEIGHT, 0, 1&#125;; int[] v4 = new int[]&#123;MAX_WEIGHT, MAX_WEIGHT, MAX_WEIGHT, MAX_WEIGHT, 0&#125;; graph.matrix[0] = v0; graph.matrix[1] = v1; graph.matrix[2] = v2; graph.matrix[3] = v3; graph.matrix[4] = v4; int v1OutDegree = graph.getOutDegree(1); System.out.println("v1的出度 = " + v1OutDegree);//v1的出度 = 2 int v0InDegree = graph.getInDegree(1); System.out.println("v0的入度 = " + v0InDegree);//v0的入度 = 2 int v02v4Weight = graph.getWeight(0, 4); System.out.println("v0到v4的权值 = " + v02v4Weight);//v0到v4的权值 = 6 &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树（Tree）以及二叉树的遍历]]></title>
    <url>%2F%E6%A0%91%EF%BC%88Tree%EF%BC%89%E4%BB%A5%E5%8F%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86.html</url>
    <content type="text"><![CDATA[树(tree) 是一种抽象数据类型（ADT）或是实作这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n&gt;0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。 树的特点: 每个节点有零个或多个子节点； 没有父节点的节点称为根节点； 每一个非根节点有且只有一个父节点； 除了根节点外，每个子节点可以分为多个不相交的子树； 常用到的术语: 节点的度：一个节点含有的子树的个数称为该节点的度（上图 A-&gt;2 B-&gt;3 J-&gt;0)； 树的度：一棵树中，最大的节点的度称为树的度（上图B节点 3个度 最大）； 叶节点或终端节点：度为零的节点（上图A K O P）； 父亲节点或父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点（上图A是BC的父节点 B是DEF的父节点）； 孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点（上图BC是A的子节点 DEF是B的子节点）`； 兄弟节点：具有相同父节点的节点互称为兄弟节点（上图BC DEF LM是相互的兄弟节点 ）； 节点的层次：从根开始定义起，根为第1层，根的子节点为第2层，以此类推（上图A为第1层 BC第2层 DEFGH第三层 ...）； 树的高度或深度 ：树中节点的最大层次（上图为5层）； 堂兄弟节点：父节点在同一层的节点互为堂兄弟（上图FG为堂兄弟节点）； 森林：由m（m&gt;=0）棵互不相交的树的集合称为森林； 种类 无序树：树中任意节点的子节点之间没有顺序关系，这种树称为无序树，也称为自由树； 有序树：树中任意节点的子节点之间有顺序关系，这种树称为有序树； 二叉树：每个节点最多含有两个子树的树称为二叉树； 完全二叉树：对于一颗二叉树，假设其深度为d（d&gt;1）。除了第d层外，其它各层的节点数目均已达最大值，且第d层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树； 满二叉树：所有叶节点都在最底层的完全二叉树(下图所示)； 平衡二叉树：当且仅当任何节点的两棵子树的高度差不大于1的二叉树； 排序二叉树(二叉查找树)（英语：Binary Search Tree），也称二叉搜索树、有序二叉树)； …… 二叉树的性质: 在二叉树的第i层上至多有2^(i-1)个结点。 2. 深度为k的二叉树之多有(2^k)-1个结点。 对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点树为n2，则n0=n2+1。 具有n个结点的完全二叉树的深度为（logn）+1。 如果对一棵有n个结点的完全二叉树的结点按层序号遍历，对任意结点i有：如果i=1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲是结点i/2。如果2i&gt;n，则结点i无左孩子；否则其左孩子是结点2i。如果2i+1&gt;n，则结点i无右孩子；否则其右孩子是结点2i+1. 二叉树的表示方法： 双亲表示法在每个结点中，附设一个指示器指示其双亲结点到链表中的位置。这种方式返回来找父节点不方便 孩子表示法:也不助于查找父节点 孩子兄弟表示法： 比较好的表示方案:借用HashMap的思想,一个组head表示父节点,一组都是该父节点的子节点。 二叉树的遍历: 前序遍历：若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。 中–&gt;左–&gt;右 中序遍历：若二叉树为空，则空操作返回，否则从根结点开始，中序遍历根节点的左子树，然后访问根结点，再中序遍历根结点的右子树。左–&gt;中–&gt;右 后序遍历:若二叉树为空，则空操作返回，否则从左到右先叶子后节点的方式遍历访问左子树和右子树，最后是访问根结点。左–&gt;右–&gt;中 层次遍历：若二叉树为空，则空操作返回，否则从树的第一层开始，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。一层一层的遍历 JAVA实现一个简单的二叉树的遍历123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180public class BinaryTree &#123; private TreeNode root = null; public BinaryTree()&#123; root = new TreeNode(1, "A"); &#125; /** * 构建二叉树 * A * B C * D E F */ public void createBinaryTree()&#123; TreeNode nodeB = new TreeNode(2, "B"); TreeNode nodeC = new TreeNode(3, "C"); TreeNode nodeD = new TreeNode(4, "D"); TreeNode nodeE = new TreeNode(5, "E"); TreeNode nodeF = new TreeNode(6, "F"); root.leftChild = nodeB; root.rightChild = nodeC; nodeB.leftChild = nodeD; nodeB.rightChild = nodeE; nodeC.rightChild = nodeF; &#125; /** * 求二叉树的高度 * @author Administrator * */ public int getHeight()&#123; return getHeight(root); &#125; private int getHeight(TreeNode node) &#123; if(node == null)&#123; return 0; &#125;else&#123; int i = getHeight(node.leftChild); int j = getHeight(node.rightChild); return (i&lt;j)?j+1:i+1; &#125; &#125; /** * 获取二叉树的结点数 * @author Administrator * */ public int getSize()&#123; return getSize(root); &#125; private int getSize(TreeNode node) &#123; if(node == null)&#123; return 0; &#125;else&#123; return 1+getSize(node.leftChild)+getSize(node.rightChild); &#125; &#125; /** * 前序遍历——迭代 * @author Administrator * */ public void preOrder(TreeNode node)&#123; if(node == null)&#123; return; &#125;else&#123; System.out.println("preOrder data:"+node.getData()); preOrder(node.leftChild); preOrder(node.rightChild); &#125; &#125; /** * 前序遍历——非迭代 */ public void nonRecOrder(TreeNode node)&#123; if(node == null)&#123; return; &#125; Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); stack.push(node); while(!stack.isEmpty())&#123; //出栈和进栈 TreeNode n = stack.pop();//弹出根结点 //压入子结点 System.out.println("nonRecOrder data"+n.getData()); if(n.rightChild!=null)&#123; stack.push(n.rightChild); &#125; if(n.leftChild!=null)&#123; stack.push(n.leftChild); &#125; &#125; &#125; /** * 中序遍历——迭代 * @author Administrator * */ public void midOrder(TreeNode node)&#123; if(node == null)&#123; return; &#125;else&#123; midOrder(node.leftChild); System.out.println("midOrder data:"+node.getData()); midOrder(node.rightChild); &#125; &#125; /** * 后序遍历——迭代 * @author Administrator * */ public void postOrder(TreeNode node)&#123; if(node == null)&#123; return; &#125;else&#123; postOrder(node.leftChild); postOrder(node.rightChild); System.out.println("postOrder data:"+node.getData()); &#125; &#125; public class TreeNode&#123; private int index; private String data; private TreeNode leftChild; private TreeNode rightChild; public int getIndex() &#123; return index; &#125; public void setIndex(int index) &#123; this.index = index; &#125; public String getData() &#123; return data; &#125; public void setData(String data) &#123; this.data = data; &#125; public TreeNode(int index,String data)&#123; this.index = index; this.data = data; this.leftChild = null; this.rightChild = null; &#125; &#125; public static void main(String[] args)&#123; BinaryTree binaryTree = new BinaryTree(); binaryTree.createBinaryTree(); int height = binaryTree.getHeight(); System.out.println("treeHeihgt:"+height); int size = binaryTree.getSize(); System.out.println("treeSize:"+size);// binaryTree.preOrder(binaryTree.root);// binaryTree.midOrder(binaryTree.root);// binaryTree.postOrder(binaryTree.root); binaryTree.nonRecOrder(binaryTree.root); &#125;&#125; 水平有限，文中有什么不对或者有什么建议希望大家能够指出，谢谢！]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈（Stack源码分析）]]></title>
    <url>%2F%E6%A0%88%EF%BC%88Stack%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%89.html</url>
    <content type="text"><![CDATA[栈(stack) 从数据结构的角度理解：是一组数据的存放方式，特点为LIFO，即后进先出（Last in, first out）。在这种数据结构中，数据像积木那样一层层堆起来，后面加入的数据就放在最上层。使用的时候，最上层的数据第一个被用掉，这就叫做”后进先出”。 从代码运行方式角度理解：是调用栈，表示函数或子例程像堆积木一样存放，以实现层层调用。程序运行的时候，总是先完成最上层的调用，然后将它的值返回到下一层调用，直至完成整个调用栈，返回最后的结果。 从内存区域的角度上理解：是存放数据的一种内存区域。程序运行的时候，需要内存空间存放数据。一般来说，系统会划分出两种不同的内存空间：一种叫做stack（栈），另一种叫做heap（堆）。参考链接:Stack的三种含义 (图片均来源于网络) 本文所述是站在数据结构的角度。栈可以通过链表和数组实现，先看通过数组实现的方式。 可以通过查看Stack源码学习 可以看到Stack是Vector的子类，Vector本身是一个可增长的线程安全的对象数组（ a growable array of objects） 里面主要是如下方法12345678910E push(E item) 把项压入堆栈顶部。 E pop() 移除堆栈顶部的对象，并作为此函数的值返回该对象。 E peek() 查看堆栈顶部的对象，但不从堆栈中移除它。 boolean empty() 测试堆栈是否为空。 int search(Object o) 返回对象在堆栈中的位置，以 1 为基数。 push123456789101112131415/** * Pushes an item onto the top of this stack. This has exactly * the same effect as: * &lt;blockquote&gt;&lt;pre&gt; * addElement(item)&lt;/pre&gt;&lt;/blockquote&gt; * * @param item the item to be pushed onto this stack. * @return the &lt;code&gt;item&lt;/code&gt; argument. * @see java.util.Vector#addElement */ public E push(E item) &#123; addElement(item); return item; &#125; 就是调用了Vector的addElement12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Adds the specified component to the end of this vector, * increasing its size by one. The capacity of this vector is * increased if its size becomes greater than its capacity. * * &lt;p&gt;This method is identical in functionality to the * &#123;@link #add(Object) add(E)&#125; * method (which is part of the &#123;@link List&#125; interface). * * @param obj the component to be added */ public synchronized void addElement(E obj) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = obj; &#125;/** * This implements the unsynchronized semantics of ensureCapacity. * Synchronized methods in this class can internally call this * method for ensuring capacity without incurring the cost of an * extra synchronization. * * @see #ensureCapacity(int) */ private void ensureCapacityHelper(int minCapacity) &#123; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity); &#125; 就是判断是否扩容，然后赋值即可 pop和peek123456789101112131415161718192021222324252627282930313233/** * Removes the object at the top of this stack and returns that * object as the value of this function. * * @return The object at the top of this stack (the last item * of the &lt;tt&gt;Vector&lt;/tt&gt; object). * @throws EmptyStackException if this stack is empty. */ public synchronized E pop() &#123; E obj; int len = size(); obj = peek(); removeElementAt(len - 1); return obj; &#125; /** * Looks at the object at the top of this stack without removing it * from the stack. * * @return the object at the top of this stack (the last item * of the &lt;tt&gt;Vector&lt;/tt&gt; object). * @throws EmptyStackException if this stack is empty. */ public synchronized E peek() &#123; int len = size(); if (len == 0) throw new EmptyStackException(); return elementAt(len - 1); &#125; Vector中1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 /** * Deletes the component at the specified index. Each component in * this vector with an index greater or equal to the specified * &#123;@code index&#125; is shifted downward to have an index one * smaller than the value it had previously. The size of this vector * is decreased by &#123;@code 1&#125;. * * &lt;p&gt;The index must be a value greater than or equal to &#123;@code 0&#125; * and less than the current size of the vector. * * &lt;p&gt;This method is identical in functionality to the &#123;@link #remove(int)&#125; * method (which is part of the &#123;@link List&#125; interface). Note that the * &#123;@code remove&#125; method returns the old value that was stored at the * specified position. * * @param index the index of the object to remove * @throws ArrayIndexOutOfBoundsException if the index is out of range * (&#123;@code index &lt; 0 || index &gt;= size()&#125;) */ public synchronized void removeElementAt(int index) &#123; modCount++; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + " &gt;= " + elementCount); &#125; else if (index &lt; 0) &#123; throw new ArrayIndexOutOfBoundsException(index); &#125; int j = elementCount - index - 1; if (j &gt; 0) &#123; System.arraycopy(elementData, index + 1, elementData, index, j); &#125; elementCount--; elementData[elementCount] = null; /* to let gc do its work */ &#125; /** * Returns the component at the specified index. * * &lt;p&gt;This method is identical in functionality to the &#123;@link #get(int)&#125; * method (which is part of the &#123;@link List&#125; interface). * * @param index an index into this vector * @return the component at the specified index * @throws ArrayIndexOutOfBoundsException if the index is out of range * (&#123;@code index &lt; 0 || index &gt;= size()&#125;) */ public synchronized E elementAt(int index) &#123; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + " &gt;= " + elementCount); &#125; return elementData(index); &#125;@SuppressWarnings("unchecked") E elementData(int index) &#123; return (E) elementData[index]; &#125; 先调用peek()得到需要出栈的对象，也就是数组顶部的对象，在调用Vector的removeElementAt移除。 empty123456789/** * Tests if this stack is empty. * * @return &lt;code&gt;true&lt;/code&gt; if and only if this stack contains * no items; &lt;code&gt;false&lt;/code&gt; otherwise. */ public boolean empty() &#123; return size() == 0; &#125; search12345678910111213141516171819202122/** * Returns the 1-based position where an object is on this stack. * If the object &lt;tt&gt;o&lt;/tt&gt; occurs as an item in this stack, this * method returns the distance from the top of the stack of the * occurrence nearest the top of the stack; the topmost item on the * stack is considered to be at distance &lt;tt&gt;1&lt;/tt&gt;. The &lt;tt&gt;equals&lt;/tt&gt; * method is used to compare &lt;tt&gt;o&lt;/tt&gt; to the * items in this stack. * * @param o the desired object. * @return the 1-based position from the top of the stack where * the object is located; the return value &lt;code&gt;-1&lt;/code&gt; * indicates that the object is not on the stack. */ public synchronized int search(Object o) &#123; int i = lastIndexOf(o); if (i &gt;= 0) &#123; return size() - i; &#125; return -1; &#125; 参考链接:java.util.Stack类简介 接下来看看使用链式的方式实现代码表示:1234567 private Node top = null;private int number = 0;class Node &#123; public T Item; public Node Next;&#125; 入栈：将top的指向换为入栈的对象，然后将这个入栈的对象指向上一个入栈的对象即可。 代码表示:1234567public void push(T node) &#123; Node oldFirst = top; top = new Node(); top.Item = node; top.Next = oldFirst; number++; &#125; 出栈：根据出栈的对象得到next，然后top指向即可。代码表示:123456public T pop() &#123; T item = top.Item; top = top.Next; number--; return item; &#125; 一个伪代码类表示:12345678910111213141516171819202122232425262728293031/** * Created by zzw on 2017/6/27. * Version: * Des: */public class StackLinkedList&lt;T&gt; &#123; private Node top = null; private int number = 0; class Node &#123; public T Item; public Node Next; &#125; public void push(T node) &#123; Node oldFirst = top; top = new Node(); top.Item = node; top.Next = oldFirst; number++; &#125; public T pop() &#123; T item = top.Item; top = top.Next; number--; return item; &#125;&#125; 参考连接:浅谈算法和数据结构: 一 栈和队列 水平有限，文中有什么不对或者有什么建议希望大家能够指出，谢谢！]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkedHashMap和LruCache源码分析]]></title>
    <url>%2FLinkedHashMap%E5%92%8CLruCache%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</url>
    <content type="text"><![CDATA[LinkedHashMap是HashMap的子类，与HashMap有着同样的存储结构，但它加入了一个双向链表的头结点，将所有put到LinkedHashMap的节点一一串成了一个双向循环链表，因此它保留了节点插入的顺序。可以按照访问顺序和插入顺序来进行排序。LruCahe就是基于LinkedHashMap来实现的。(图片均来源于网络) 建议先阅读HashMap源码分析在来阅读此篇文章。先看看结构图，这有助于我们阅读源码： HashMap里面进行key value绑定的类是HashMapEntry,在LinkedHashMap则是LinkedHashMapEntry，它继承HashMapEntry的一个类并且重写recordAccess recordRemoval来进行重新指向进行排序，里面remove函数主要对自身在链表中进行移除，addBefore(LinkedHashMapEntry&lt;K,V&gt; existingEntry)则是将自身插入到existingEntry之前。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * LinkedHashMap entry. */ private static class LinkedHashMapEntry&lt;K,V&gt; extends HashMapEntry&lt;K,V&gt; &#123; // These fields comprise the doubly linked list used for iteration. LinkedHashMapEntry&lt;K,V&gt; before, after; LinkedHashMapEntry(int hash, K key, V value, HashMapEntry&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125; /** * Removes this entry from the linked list. */ // 对自身在链表中进行移除 private void remove() &#123; before.after = after; after.before = before; &#125; /** * Inserts this entry before the specified existing entry in the list. */ //插入到LinkedHashMapEntry existingEntry之前 private void addBefore(LinkedHashMapEntry&lt;K,V&gt; existingEntry) &#123; after = existingEntry; before = existingEntry.before; before.after = this; after.before = this; &#125; /** * This method is invoked by the superclass whenever the value * of a pre-existing entry is read by Map.get or modified by Map.set. * If the enclosing Map is access-ordered, it moves the entry * to the end of the list; otherwise, it does nothing. */ void recordAccess(HashMap&lt;K,V&gt; m) &#123; LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m; if (lm.accessOrder) &#123; lm.modCount++; remove(); addBefore(lm.header); &#125; &#125; void recordRemoval(HashMap&lt;K,V&gt; m) &#123; remove(); &#125; &#125; 有了上面的概念来看LinkedHashMap的操作就相对比较容易了。LinkedHashMap put的时候是调用HashMap的put函数，只是自身实现了addEntry() createEntry()来实现自身的逻辑 HashMap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 /** * Associates the specified value with the specified key in this map. * If the map previously contained a mapping for the key, the old * value is replaced. * * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or * &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;. * (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map * previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.) */ public V put(K key, V value) &#123; if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; if (key == null) return putForNullKey(value); int hash = sun.misc.Hashing.singleWordWangJenkinsHash(key); int i = indexFor(hash, table.length); for (HashMapEntry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; //调用子类LinkedHashMapEntry的recordAccess方法 e.recordAccess(this); return oldValue; &#125; &#125; modCount++; //调用LinkedHashMap.addEntry方法 addEntry(hash, key, value, i); return null; &#125; /** * Adds a new entry with the specified key, value and hash code to * the specified bucket. It is the responsibility of this * method to resize the table if appropriate. * * Subclass overrides this to alter the behavior of put method. */ void addEntry(int hash, K key, V value, int bucketIndex) &#123; //扩容 if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length); hash = (null != key) ? sun.misc.Hashing.singleWordWangJenkinsHash(key) : 0; bucketIndex = indexFor(hash, table.length); &#125; //增加新的key value 调用LinkedHashMap.createEntry createEntry(hash, key, value, bucketIndex); &#125; LinkedHashMap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 /** * This override alters behavior of superclass put method. It causes newly * allocated entry to get inserted at the end of the linked list and * removes the eldest entry if appropriate. */ void addEntry(int hash, K key, V value, int bucketIndex) &#123; // Previous Android releases called removeEldestEntry() before actually // inserting a value but after increasing the size. // The RI is documented to call it afterwards. // **** THIS CHANGE WILL BE REVERTED IN A FUTURE ANDROID RELEASE **** //得到需要移除的对象 // Remove eldest entry if instructed LinkedHashMapEntry&lt;K,V&gt; eldest = header.after; //需要移除的对象是否是自身 if (eldest != header) &#123; boolean removeEldest; size++; try &#123; //得到是否移除的对象的标识 removeEldest = removeEldestEntry(eldest); &#125; finally &#123; size--; &#125; if (removeEldest) &#123; //调用HashMap的removeEntryForKey进行移除 removeEntryForKey(eldest.key); &#125; &#125; //调用HashMap的addEntry super.addEntry(hash, key, value, bucketIndex); &#125; protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) &#123; return false; &#125; /** * Like addEntry except that this version is used when creating entries * as part of Map construction or "pseudo-construction" (cloning, * deserialization). This version needn't worry about resizing the table. * * Subclass overrides this to alter the behavior of HashMap(Map), * clone, and readObject. */ //增加新的key value void createEntry(int hash, K key, V value, int bucketIndex) &#123; HashMapEntry&lt;K,V&gt; e = table[bucketIndex]; table[bucketIndex] = new HashMapEntry&lt;&gt;(hash, key, value, e); size++; &#125; 我们主要看LinkedHashMap里面的东西，涉及到HashMap的就不重复说了。如果key已经在该LinkedHashMap里面put了，那么将会重新进行赋值，并且调用LinkedHashMapEntry.recordAccess()进行排序，排序方式如果是访问顺序(accessOrder==true)，将会将其在链表中移除，然后添加到链尾部。最后在返回oldValue。如果key不存在，则会调用LinkedHashMap.addEntry,先得到需要移除的对象，就是header.after，接着判断需要移除的对象是否是自身，如果不是自生并且removeEldestEntry()函数返回的是true的话，那么将会调用HashMap的removeEntryForKey移除。移除这里后面在讲。接着调用HashMap.addEntry进行扩容，在调用LinkedHashMap.createEntry,这一步就是重新new一个HashMapEntry,添加到链尾就可以了。如图所示： remove过程也是调用HashMap.remove,然后调用LinkedHashMapEntry.recordRemoval函数来进行删除 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Removes the mapping for the specified key from this map if present. * * @param key key whose mapping is to be removed from the map * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or * &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;. * (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map * previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.) */ public V remove(Object key) &#123; Entry&lt;K,V&gt; e = removeEntryForKey(key); return (e == null ? null : e.getValue()); &#125; /** * Removes and returns the entry associated with the specified key * in the HashMap. Returns null if the HashMap contains no mapping * for this key. */ final Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123; if (size == 0) &#123; return null; &#125; int hash = (key == null) ? 0 : sun.misc.Hashing.singleWordWangJenkinsHash(key); int i = indexFor(hash, table.length); HashMapEntry&lt;K,V&gt; prev = table[i]; HashMapEntry&lt;K,V&gt; e = prev; while (e != null) &#123; HashMapEntry&lt;K,V&gt; next = e.next; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; modCount++; size--; if (prev == e) table[i] = next; else prev.next = next; //调用LinkedHashMapEntry.recordRemoval e.recordRemoval(this); return e; &#125; prev = e; e = next; &#125; return e; &#125; LinkedHashMapEntry中:1234567891011/** * Removes this entry from the linked list. */ private void remove() &#123; before.after = after; after.before = before; &#125;void recordRemoval(HashMap&lt;K,V&gt; m) &#123; remove(); &#125; 很简单，就是进行一个指向。如图所示: get1234567891011121314151617181920212223/** * Returns the value to which the specified key is mapped, * or &#123;@code null&#125; if this map contains no mapping for the key. * * &lt;p&gt;More formally, if this map contains a mapping from a key * &#123;@code k&#125; to a value &#123;@code v&#125; such that &#123;@code (key==null ? k==null : * key.equals(k))&#125;, then this method returns &#123;@code v&#125;; otherwise * it returns &#123;@code null&#125;. (There can be at most one such mapping.) * * &lt;p&gt;A return value of &#123;@code null&#125; does not &lt;i&gt;necessarily&lt;/i&gt; * indicate that the map contains no mapping for the key; it's also * possible that the map explicitly maps the key to &#123;@code null&#125;. * The &#123;@link #containsKey containsKey&#125; operation may be used to * distinguish these two cases. */ public V get(Object key) &#123; //调用HashMap的getEntry LinkedHashMapEntry&lt;K,V&gt; e = (LinkedHashMapEntry&lt;K,V&gt;)getEntry(key); if (e == null) return null; e.recordAccess(this); return e.value; &#125; 通过HashMap.getEntry获取对应的值，然后调用LinkedHashMapEntry.recordAccess排序。 有了LinkedHashMap的基础我们来看LruCache的源码就很好理解了 put1234567891011121314151617181920212223242526272829303132/** * Caches &#123;@code value&#125; for &#123;@code key&#125;. The value is moved to the head of * the queue. * * @return the previous value mapped by &#123;@code key&#125;. */ public final V put(K key, V value) &#123; if (key == null || value == null) &#123; throw new NullPointerException("key == null || value == null"); &#125; V previous; synchronized (this) &#123; putCount++; //根据key, value获取大小，我们需要重写sizeOf自行赋值 size += safeSizeOf(key, value); //加入到LinkedHashMap previous = map.put(key, value); //如果key已经存在了previous 就！=null 就移除刚加的大小 if (previous != null) &#123; size -= safeSizeOf(key, previous); &#125; &#125; if (previous != null) &#123; //重写移除的逻辑 entryRemoved(false, key, previous, value); &#125; //根据maxSize去除多余的元素 trimToSize(maxSize); return previous; &#125; remove12345678910111213141516171819202122232425/** * Removes the entry for &#123;@code key&#125; if it exists. * * @return the previous value mapped by &#123;@code key&#125;. */ public final V remove(K key) &#123; if (key == null) &#123; throw new NullPointerException("key == null"); &#125; V previous; synchronized (this) &#123; //从LinkedHashMap中移除 previous = map.remove(key); if (previous != null) &#123; size -= safeSizeOf(key, previous); &#125; &#125; if (previous != null) &#123; entryRemoved(false, key, previous, null); &#125; return previous; &#125; get12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * Returns the value for &#123;@code key&#125; if it exists in the cache or can be * created by &#123;@code #create&#125;. If a value was returned, it is moved to the * head of the queue. This returns null if a value is not cached and cannot * be created. */ public final V get(K key) &#123; if (key == null) &#123; throw new NullPointerException("key == null"); &#125; V mapValue; synchronized (this) &#123; //从LinkedHashMap中取出元素 mapValue = map.get(key); if (mapValue != null) &#123; hitCount++; return mapValue; &#125; missCount++; &#125; /* * Attempt to create a value. This may take a long time, and the map * may be different when create() returns. If a conflicting value was * added to the map while create() was working, we leave that value in * the map and release the created value. */ //如果没有这个key，那么你可以重写create来创建一个新的value V createdValue = create(key); if (createdValue == null) &#123; return null; &#125; //新的创建的value 添加到LinkedHashMap synchronized (this) &#123; createCount++; mapValue = map.put(key, createdValue); if (mapValue != null) &#123; // There was a conflict so undo that last put map.put(key, mapValue); &#125; else &#123; size += safeSizeOf(key, createdValue); &#125; &#125; if (mapValue != null) &#123; entryRemoved(false, key, createdValue, mapValue); return mapValue; &#125; else &#123; trimToSize(maxSize); return createdValue; &#125; &#125; 参考链接:Java容器框架分析(七)——LinkedHashSet与LinkedHashMap【Java集合源码剖析】LinkedHashmap源码剖析 水平有限，文中有什么不对或者有什么建议希望大家能够指出，谢谢！]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap源码分析]]></title>
    <url>%2FHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</url>
    <content type="text"><![CDATA[HashMap是一个很经典的键值对集合，从它的广泛应用程度和源码的学习角度上我们不得不去解析它。我们先看一下HashMap的存储结构((图片均来源于网络))，这有助于我们阅读源码 HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对以及指引的下一个Entry123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/** @hide */ // Android added. static class HashMapEntry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; HashMapEntry&lt;K,V&gt; next; int hash; /** * Creates new entry. */ HashMapEntry(int h, K k, V v, HashMapEntry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; Object k1 = getKey(); Object k2 = e.getKey(); if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) &#123; Object v1 = getValue(); Object v2 = e.getValue(); if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2))) return true; &#125; return false; &#125; public final int hashCode() &#123; return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue()); &#125; public final String toString() &#123; return getKey() + "=" + getValue(); &#125; /** * This method is invoked whenever the value in an entry is * overwritten by an invocation of put(k,v) for a key k that's already * in the HashMap. */ void recordAccess(HashMap&lt;K,V&gt; m) &#123; &#125; /** * This method is invoked whenever the entry is * removed from the table. */ void recordRemoval(HashMap&lt;K,V&gt; m) &#123; &#125; &#125; 初始化过程1234567891011121314151617181920212223242526272829303132333435363738394041/** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and load factor. * * @param initialCapacity the initial capacity * @param loadFactor the load factor * @throws IllegalArgumentException if the initial capacity is negative * or the load factor is nonpositive */ public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) &#123; initialCapacity = MAXIMUM_CAPACITY; &#125; else if (initialCapacity &lt; DEFAULT_INITIAL_CAPACITY) &#123; initialCapacity = DEFAULT_INITIAL_CAPACITY; &#125; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); // Android-Note: We always use the default load factor of 0.75f. // This might appear wrong but it's just awkward design. We always call // inflateTable() when table == EMPTY_TABLE. That method will take "threshold" // to mean "capacity" and then replace it with the real threshold (i.e, multiplied with // the load factor). threshold = initialCapacity; init(); &#125;/** * Initialization hook for subclasses. This method is called * in all constructors and pseudo-constructors (clone, readObject) * after HashMap has been initialized but before any entries have * been inserted. (In the absence of this method, readObject would * require explicit knowledge of subclasses.) */ void init() &#123; &#125; 主要就是进行一个赋值put过程:12345678910111213141516171819202122232425262728293031323334353637383940/** * Associates the specified value with the specified key in this map. * If the map previously contained a mapping for the key, the old * value is replaced. * * @param key key with which the specified value is to be associated * @param value value to be associated with the specified key * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or * &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;. * (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map * previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.) */ public V put(K key, V value) &#123; if (table == EMPTY_TABLE) &#123; //初始化table inflateTable(threshold); &#125; if (key == null)//put key==null的值 return putForNullKey(value); //根据key得到hash int hash = sun.misc.Hashing.singleWordWangJenkinsHash(key); //根据hash得到下标 int i = indexFor(hash, table.length); //进行next链表检测key是否已经存在 for (HashMapEntry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; //如果key已经存在 将重新赋值 if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; //添加新的值 addEntry(hash, key, value, i); return null; &#125; 首先检测是否是空的装HashMapEntry数组的table，如果是空的将调用inflateTable进行初始化1234567891011121314151617/** * Inflates the table. */ private void inflateTable(int toSize) &#123; // Find a power of 2 &gt;= toSize int capacity = roundUpToPowerOf2(toSize); // Android-changed: Replace usage of Math.min() here because this method is // called from the &lt;clinit&gt; of runtime, at which point the native libraries // needed by Float.* might not be loaded. float thresholdFloat = capacity * loadFactor; if (thresholdFloat &gt; MAXIMUM_CAPACITY + 1) &#123; thresholdFloat = MAXIMUM_CAPACITY + 1; &#125; threshold = (int) thresholdFloat; table = new HashMapEntry[capacity]; &#125; 接着检测key==null，如果为null,将调用putForNullKey函数给key==null的key赋值12345678910111213141516/** * Offloaded version of put for null keys */ private V putForNullKey(V value) &#123; for (HashMapEntry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; addEntry(0, null, value, 0); return null; &#125; 从这就可以看出 HashMap的key可以为null接下来就到了HashMap的关键地方，HashMap自己实现了一个key的Hash值计算，然后根据计算出的hash值和当前容器的table的长度进行&amp;运算得到index，然后根据这个index确定需要放置的位置。123456789 int hash = sun.misc.Hashing.singleWordWangJenkinsHash(key); int i = indexFor(hash, table.length);/** * Returns index for hash code h. */ static int indexFor(int h, int length) &#123; // assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;; return h &amp; (length-1); &#125; 这样计算的目的是为了根据hash值和table.length进行分组，也就是上面图示那样，然后通过链式的结构链接，这样的话就缩短了大量的查询时间。拿到了所在的组，也就是下标位置，就拿到这个下标的HashMapEntry,然后进行next遍历，如果有存在的key就重新赋值返回即可。123456789for (HashMapEntry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; 如果没有存在的key，那么先判断是否扩容1234567891011121314151617/** * Adds a new entry with the specified key, value and hash code to * the specified bucket. It is the responsibility of this * method to resize the table if appropriate. * * Subclass overrides this to alter the behavior of put method. */ void addEntry(int hash, K key, V value, int bucketIndex) &#123; //判断扩容 if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length);//扩容以及数据重组 hash = (null != key) ? sun.misc.Hashing.singleWordWangJenkinsHash(key) : 0; bucketIndex = indexFor(hash, table.length); &#125; //创建一个新的Entry添加 createEntry(hash, key, value, bucketIndex); &#125; 扩容的方式为当前容量的两倍123456789101112131415161718192021222324252627/** * Rehashes the contents of this map into a new array with a * larger capacity. This method is called automatically when the * number of keys in this map reaches its threshold. * * If current capacity is MAXIMUM_CAPACITY, this method does not * resize the map, but sets threshold to Integer.MAX_VALUE. * This has the effect of preventing future calls. * * @param newCapacity the new capacity, MUST be a power of two; * must be greater than current capacity unless current * capacity is MAXIMUM_CAPACITY (in which case value * is irrelevant). */ void resize(int newCapacity) &#123; HashMapEntry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; HashMapEntry[] newTable = new HashMapEntry[newCapacity]; transfer(newTable); table = newTable; threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1); &#125; 我们分组（下标）是根据table.length和key的hash值来决定的，所以在扩容之后，table.length变化了对应的分组（下标）就变化了，所以这时候需要重新组装数据123456789101112131415/** * Transfers all entries from current table to newTable. */ void transfer(HashMapEntry[] newTable) &#123; int newCapacity = newTable.length; for (HashMapEntry&lt;K,V&gt; e : table) &#123; while(null != e) &#123; HashMapEntry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; &#125; &#125; &#125; 组装的方式如下图所示 最后根据hash key value index得到一个新的HashMapEntry对象,将原来组(下标)的HashMapEntry作为这个新的对象的next指向即可。1234567891011121314151617181920212223/** * Like addEntry except that this version is used when creating entries * as part of Map construction or "pseudo-construction" (cloning, * deserialization). This version needn't worry about resizing the table. * * Subclass overrides this to alter the behavior of HashMap(Map), * clone, and readObject. */ void createEntry(int hash, K key, V value, int bucketIndex) &#123; HashMapEntry&lt;K,V&gt; e = table[bucketIndex]; table[bucketIndex] = new HashMapEntry&lt;&gt;(hash, key, value, e); size++; &#125;/** * Creates new entry. */ HashMapEntry(int h, K k, V v, HashMapEntry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h; &#125; 有了put的分析，get过程理解就比较轻松了12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * Returns the value to which the specified key is mapped, * or &#123;@code null&#125; if this map contains no mapping for the key. * * &lt;p&gt;More formally, if this map contains a mapping from a key * &#123;@code k&#125; to a value &#123;@code v&#125; such that &#123;@code (key==null ? k==null : * key.equals(k))&#125;, then this method returns &#123;@code v&#125;; otherwise * it returns &#123;@code null&#125;. (There can be at most one such mapping.) * * &lt;p&gt;A return value of &#123;@code null&#125; does not &lt;i&gt;necessarily&lt;/i&gt; * indicate that the map contains no mapping for the key; it's also * possible that the map explicitly maps the key to &#123;@code null&#125;. * The &#123;@link #containsKey containsKey&#125; operation may be used to * distinguish these two cases. * * @see #put(Object, Object) */ public V get(Object key) &#123; if (key == null) return getForNullKey(); Entry&lt;K,V&gt; entry = getEntry(key); return null == entry ? null : entry.getValue(); &#125;/** * Offloaded version of get() to look up null keys. Null keys map * to index 0. This null case is split out into separate methods * for the sake of performance in the two most commonly used * operations (get and put), but incorporated with conditionals in * others. */ private V getForNullKey() &#123; if (size == 0) &#123; return null; &#125; for (HashMapEntry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) return e.value; &#125; return null; &#125;/** * Returns the entry associated with the specified key in the * HashMap. Returns null if the HashMap contains no mapping * for the key. */ final Entry&lt;K,V&gt; getEntry(Object key) &#123; if (size == 0) &#123; return null; &#125; int hash = (key == null) ? 0 : sun.misc.Hashing.singleWordWangJenkinsHash(key); for (HashMapEntry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; return null; &#125; 先判断key值是否是null，如果是null的话那么将在第0组（下标）查找，如果不是的话就通过key的hash和table.length得到对应的组（下标）查找，查找的过程就是对其HashMapEntry进行next遍历查找判断即可。 remove过程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Removes the mapping for the specified key from this map if present. * * @param key key whose mapping is to be removed from the map * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or * &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;. * (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map * previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.) */ public V remove(Object key) &#123; Entry&lt;K,V&gt; e = removeEntryForKey(key); return (e == null ? null : e.getValue()); &#125; /** * Removes and returns the entry associated with the specified key * in the HashMap. Returns null if the HashMap contains no mapping * for this key. */ final Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123; if (size == 0) &#123; return null; &#125; int hash = (key == null) ? 0 : sun.misc.Hashing.singleWordWangJenkinsHash(key); int i = indexFor(hash, table.length); HashMapEntry&lt;K,V&gt; prev = table[i]; HashMapEntry&lt;K,V&gt; e = prev; while (e != null) &#123; HashMapEntry&lt;K,V&gt; next = e.next; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; modCount++; size--; if (prev == e) table[i] = next; else prev.next = next; e.recordRemoval(this); return e; &#125; prev = e; e = next; &#125; return e; &#125; remove过程也是先得到对应的组（下标），然后申明一个HashMapEntry零时变量prev记录上一个指标，对当前组的HashMapEntry进行next遍历，在遍历过程中将值赋予prev，然后判断key相同重新将其prev的next指向接下来的哪个HashMapEntry即可。如图所示: 参考链接：HashMap实现原理及源码分析HashMap的扩容机制—resize() 水平有限，文中有什么不对或者有什么建议希望大家能够指出，谢谢！]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[队列(Queue)]]></title>
    <url>%2F%E9%98%9F%E5%88%97(Queue).html</url>
    <content type="text"><![CDATA[队列(Queue) 队列（Queue）是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素成为出队。因为队列只允许在一段插入，在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out）线性表。本文图片均来自网络 队列(Queue)和栈(Stack)一样也有链表和数组两种实现。 链表实现 入列代码表示：1234567891011public void enqueue(T item) &#123; Node oldLast = last; last = new Node(); last.item = item; if (isEmpty()) &#123; top = last; &#125; else &#123; oldLast.next = last; &#125; number++; &#125; 出列代码表示：12345678public T dequeue() &#123; T temp = top.item; top = top.next; number--; if (isEmpty()) last = null; return temp; &#125; 完整的伪代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Created by zzw on 2017/6/28. * Version: * Des: */public class MyQuery&lt;T&gt; &#123; private Node top; private Node last; private int number; class Node &#123; T item; Node next; &#125; public T dequeue() &#123; T temp = top.item; top = top.next; number--; if (isEmpty()) last = null; return temp; &#125; public void enqueue(T item) &#123; Node oldLast = last; last = new Node(); last.item = item; if (isEmpty()) &#123; top = last; &#125; else &#123; oldLast.next = last; &#125; number++; &#125; private boolean isEmpty() &#123; return size() == 0; &#125; private int size() &#123; return number; &#125;&#125; 图示如下： 使用数组实现的称为顺序储存，这种方式出队复杂度高并且容易假溢出。入列1234public E enqueue(E item) &#123; addElement(item); return item; &#125; 出列123456789public E dequeue() &#123; if (size() &lt;= front) return null; E obj = elementAt(front); setElementAt(null, front); front++; return obj; &#125; 完整伪代码(继承Vector实现):123456789101112131415161718192021222324/** * Created by zzw on 2017/6/28. * Version: * Des: */public class MyQuery&lt;E&gt; extends Vector&lt;E&gt; &#123; int front = 0; public E enqueue(E item) &#123; addElement(item); return item; &#125; public E dequeue() &#123; if (size() &lt;= front) return null; E obj = elementAt(front); setElementAt(null, front); front++; return obj; &#125;&#125; 如下图所示： 看看队列在Android里面的使用Handle消息队列使用Handle的时候都要使用Looper.loop()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167 /** * Run the message queue in this thread. Be sure to call * &#123;@link #quit()&#125; to end the loop. */ public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println("&gt;&gt;&gt;&gt;&gt; Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what); &#125; final long traceTag = me.mTraceTag; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; try &#123; msg.target.dispatchMessage(msg); &#125; finally &#123; if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logging != null) &#123; logging.println("&lt;&lt;&lt;&lt;&lt; Finished to " + msg.target + " " + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, "Thread identity changed from 0x" + Long.toHexString(ident) + " to 0x" + Long.toHexString(newIdent) + " while dispatching to " + msg.target.getClass().getName() + " " + msg.callback + " what=" + msg.what); &#125; msg.recycleUnchecked(); &#125; &#125;//MessageQueue中 Message next() &#123; // Return here if the message loop has already quit and been disposed. // This can happen if the application tries to restart a looper after quit // which is not supported. final long ptr = mPtr; if (ptr == 0) &#123; return null; &#125; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; // Stalled by a barrier. Find the next asynchronous message in the queue. do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, "Returning message: " + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; // Process the quit message now that all pending messages have been handled. if (mQuitting) &#123; dispose(); return null; &#125; // If first time idle, then get the number of idlers to run. // Idle handles only run if the queue is empty or if the first message // in the queue (possibly a barrier) is due to be handled in the future. if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // Run the idle handlers. // We only ever reach this code block during the first iteration. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, "IdleHandler threw exception", t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; &#125; &#125; Handle 异步处理中用来存放Message对象的数据结构，按照“先进先出”的原则存放消息。存放并非实际意义的保存，而是将Message对象以链表的方式串联起来的。MessageQueue对象不需要我们自己创建，而是有Looper对象对其进行管理，一个线程最多只可以拥有一个MessageQueue。在Lopper方法中：出现了一个死循环，从队列中不断的取出message，执行msg.target.dispatchMessage(msg); EventBus在EventBus里面中，将消息封装成一个PendingPost12345678910final class PendingPost &#123; private final static List&lt;PendingPost&gt; pendingPostPool = new ArrayList&lt;PendingPost&gt;(); Object event; Subscription subscription; PendingPost next; private PendingPost(Object event, Subscription subscription) &#123; this.event = event; this.subscription = subscription; &#125;&#125; 在使用队列PendingPostQueue进行管理12345678910111213141516171819202122232425262728293031323334final class PendingPostQueue &#123; private PendingPost head; private PendingPost tail; synchronized void enqueue(PendingPost pendingPost) &#123; if (pendingPost == null) &#123; throw new NullPointerException("null cannot be enqueued"); &#125; if (tail != null) &#123; tail.next = pendingPost; tail = pendingPost; &#125; else if (head == null) &#123; head = tail = pendingPost; &#125; else &#123; throw new IllegalStateException("Head present, but no tail"); &#125; notifyAll(); &#125; synchronized PendingPost poll() &#123; PendingPost pendingPost = head; if (head != null) &#123; head = head.next; if (head == null) &#123; tail = null; &#125; &#125; return pendingPost; &#125; synchronized PendingPost poll(int maxMillisToWait) throws InterruptedException &#123; if (head == null) &#123; wait(maxMillisToWait); &#125; return poll(); &#125;&#125; Handler发送消息12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455final class HandlerPoster extends Handler &#123; private final PendingPostQueue queue; private final int maxMillisInsideHandleMessage; private final EventBus eventBus; private boolean handlerActive; HandlerPoster(EventBus eventBus, Looper looper, int maxMillisInsideHandleMessage) &#123; super(looper); this.eventBus = eventBus; this.maxMillisInsideHandleMessage = maxMillisInsideHandleMessage; queue = new PendingPostQueue(); &#125; void enqueue(Subscription subscription, Object event) &#123; PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event); synchronized (this) &#123; queue.enqueue(pendingPost); if (!handlerActive) &#123; handlerActive = true; if (!sendMessage(obtainMessage())) &#123; throw new EventBusException("Could not send handler message"); &#125; &#125; &#125; &#125; @Override public void handleMessage(Message msg) &#123; boolean rescheduled = false; try &#123; long started = SystemClock.uptimeMillis(); while (true) &#123; PendingPost pendingPost = queue.poll(); if (pendingPost == null) &#123; synchronized (this) &#123; // Check again, this time in synchronized pendingPost = queue.poll(); if (pendingPost == null) &#123; handlerActive = false; return; &#125; &#125; &#125; eventBus.invokeSubscriber(pendingPost); long timeInMethod = SystemClock.uptimeMillis() - started; if (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123; if (!sendMessage(obtainMessage())) &#123; throw new EventBusException("Could not send handler message"); &#125; rescheduled = true; return; &#125; &#125; &#125; finally &#123; handlerActive = rescheduled; &#125; &#125;&#125; 这里面有个死循环，不断的取出event，通过eventBus.invokeSubscriber(pendingPost);执行相关函数。 相关参考链接：浅谈算法和数据结构: 一 栈和队列队列在Android中的使用 水平有限，文中有什么不对或者有什么建议希望大家能够指出，谢谢！]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性表（ArrayList 和 LinkedList源码分析）]]></title>
    <url>%2F%E7%BA%BF%E6%80%A7%E8%A1%A8%EF%BC%88ArrayList%20%E5%92%8C%20LinkedList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%89.html</url>
    <content type="text"><![CDATA[线性表（linear list） 是数据结构的一种，一个线性表是n个具有相同特性的数据元素的有限序列。 线性表的相邻元素之间存在着序偶关系。a1是a2的前驱，ai+1 是ai的后继，a1没有前驱，an没有后继 n为线性表的长度 ，若n==0时，线性表为空表 存储结构：1. 数序存储结构 2. 链式存储结构 (图片均来源于网络) 顺序存储结构 特点: 存储位置连续，可以很方便计算各个元素的地址如每个元素占C个存储单元，那么Loc(An) = Loc(An-1) + C -&gt; Loc(An) = Loc(A1）+（i-1）*C 优点：查询很快 缺点：插入和删除效率慢 在JAVA里面基本的顺序存储结构线性表是数组，ArrayList是基于它来完成对象的存储，来分析一下ArrayList(Android里面的)的源码 初始化过程：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124 /** * Default initial capacity. */ private static final int DEFAULT_CAPACITY = 10; /** * Shared empty array instance used for empty instances. */ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; /** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == EMPTY_ELEMENTDATA will be expanded to * DEFAULT_CAPACITY when the first element is added. * * Package private to allow access from java.util.Collections. */ transient Object[] elementData; /** * The size of the ArrayList (the number of elements it contains). * * @serial */ private int size; /** * Constructs an empty list with the specified initial capacity. * * @param initialCapacity the initial capacity of the list * @throws IllegalArgumentException if the specified initial capacity * is negative */ public ArrayList(int initialCapacity) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); this.elementData = new Object[initialCapacity]; &#125; /** * Constructs an empty list with an initial capacity of ten. */ public ArrayList() &#123; super(); this.elementData = EMPTY_ELEMENTDATA; &#125; /** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */ public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); size = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125;``` 从初始化的过程可以很明显的看出来，就是对内部的一个`数组`对象`elementData `进行初始化。`add`过程：```java/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;) */ public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125;private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; /** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; /** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; add()的时候先判断当前数据容量是否足够，如果不足够那么扩容，扩容的值等于当前数组长度右移一位，也就是x2，然后添加到指定位置即可。addAll()也是同样的方式，在这就不贴代码，可以自行查看一下源码。 remove过程:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * Removes the element at the specified position in this list. * Shifts any subsequent elements to the left (subtracts one from their * indices). * * @param index the index of the element to be removed * @return the element that was removed from the list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E remove(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); modCount++; E oldValue = (E) elementData[index]; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; &#125; /** * Removes the first occurrence of the specified element from this list, * if it is present. If the list does not contain the element, it is * unchanged. More formally, removes the element with the lowest index * &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null ? get(i)==null : o.equals(get(i)))&lt;/tt&gt; * (if such an element exists). Returns &lt;tt&gt;true&lt;/tt&gt; if this list * contained the specified element (or equivalently, if this list * changed as a result of the call). * * @param o element to be removed from this list, if present * @return &lt;tt&gt;true&lt;/tt&gt; if this list contained the specified element */ public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125;/* * Private remove method that skips bounds checking and does not * return the value removed. */ private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work &#125; remove过程就是得到对应的值的下标，然后将该下标之后的数据都向前移动一个坐标，最后一个赋值为null set过程1234567891011121314151617/** * Replaces the element at the specified position in this list with * the specified element. * * @param index index of the element to replace * @param element element to be stored at the specified position * @return the element previously at the specified position * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E set(int index, E element) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); E oldValue = (E) elementData[index]; elementData[index] = element; return oldValue; &#125; set()直接将其赋值即可 get过程:12345678910111213/** * Returns the element at the specified position in this list. * * @param index index of the element to return * @return the element at the specified position in this list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E get(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); return (E) elementData[index]; &#125; get()就直接将数组里面值取出来即可。 从源码的角度我们更加的熟悉了顺序线性表的优缺点：查询很快，插入和删除效率慢。 链式存储结构 特点:用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。 优点：插入和删除效率高 缺点：查询效率低 插入和删除只需改变next指向的地址即可，所以增删效率比较高。 如上图那样，如果需要查找第9个元素，那么将要从第一个一直指向第九个，所以查找效率低。 链式存储结构又包含循环链表、双向循环链表、单向循环链表等。单向循环链表就是上图那样的,一个指针对应下一个指针，直到结束，就如上面的那张图所示。循环链表 : 将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相连的单链表称为单循环链表，简称循环链表 双向循环链表: 双向循环链表是单向循环链表的每个结点中，再设置一个指向其前驱结点的指针域 LinkedList是一个双向循环链表，来看看LinkedList的源码 在LinkedList里面有一个Node类，这个类就是用来确定上一个指针prev和下一个指针next1234567891011private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125; add 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** * Appends the specified element to the end of this list. * * &lt;p&gt;This method is equivalent to &#123;@link #addLast&#125;. * * @param e element to be appended to this list * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;) */ public boolean add(E e) &#123; linkLast(e); return true; &#125;/** * Inserts the specified element at the specified position in this list. * Shifts the element currently at that position (if any) and any * subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public void add(int index, E element) &#123; checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index)); &#125;/** * Links e as last element. */ void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++; &#125; /** * Links e as last element. */ void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++; &#125;/** * Inserts element e before non-null Node succ. */ void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++; &#125;/** * Returns the (non-null) Node at the specified element index. */ Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125; &#125; 可以很直观的看出，add的时候，将new出一个新的Node对象newNode，然后把上一个Node对象last的next指向它，然后又将last重新赋值。当指定位置add的时候，就需要先找个这个位置的Node对象，然后更改next和prev即可。在指定下标插入的话那么将先判断这个下标是在前半段还是后半段，如果是前半段的话就从头开始next遍历查找，如果是后半部的就从尾prev遍历。add操作如下图所示 remove:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * Removes the first occurrence of the specified element from this list, * if it is present. If this list does not contain the element, it is * unchanged. More formally, removes the element with the lowest index * &#123;@code i&#125; such that * &lt;tt&gt;(o==null ? get(i)==null : o.equals(get(i)))&lt;/tt&gt; * (if such an element exists). Returns &#123;@code true&#125; if this list * contained the specified element (or equivalently, if this list * changed as a result of the call). * * @param o element to be removed from this list, if present * @return &#123;@code true&#125; if this list contained the specified element */ public boolean remove(Object o) &#123; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false; &#125; /** * Unlinks non-null node x. */ E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element; &#125;/** * Removes the element at the specified position in this list. Shifts any * subsequent elements to the left (subtracts one from their indices). * Returns the element that was removed from the list. * * @param index the index of the element to be removed * @return the element previously at the specified position * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E remove(int index) &#123; checkElementIndex(index); return unlink(node(index)); &#125; 和add差不多，找出相应的Node对象，然后重新对前后的Node重新进行指向即可。 remove主要操作所下图所示 get:123456789101112131415161718192021222324252627282930/** * Returns the element at the specified position in this list. * * @param index index of the element to return * @return the element at the specified position in this list * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E get(int index) &#123; checkElementIndex(index); return node(index).item; &#125; /** * Returns the (non-null) Node at the specified element index. */ Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125; &#125; 判断这个下标是在前半段还是后半段，如果是前半段的话就从头开始next遍历查找，如果是后半部的就从尾prev遍历。 set:12345678910111213141516/** * Replaces the element at the specified position in this list with the * specified element. * * @param index index of the element to replace * @param element element to be stored at the specified position * @return the element previously at the specified position * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public E set(int index, E element) &#123; checkElementIndex(index); Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal; &#125; 先查找Node,然后重新赋值即可。 水平有限，文中有什么不对或者有什么建议希望大家能够指出，谢谢！]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
